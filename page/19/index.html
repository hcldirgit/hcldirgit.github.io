<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>失落的乐章</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="失落的乐章的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="失落的乐章">
<meta property="og:url" content="https://hcldirgit.github.io/page/19/index.html">
<meta property="og:site_name" content="失落的乐章">
<meta property="og:description" content="失落的乐章的Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失落的乐章">
<meta name="twitter:description" content="失落的乐章的Blog">
  
    <link rel="alternative" href="/atom.xml" title="失落的乐章" type="application/atom+xml">
  
  
    <link rel="icon" href="https://github.com/hcldirgit/image/blob/master/0.png?raw=true">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">失落的乐章</a></h1>
		</hgroup>

		
		<p class="header-subtitle">技术面前，永远都是学生。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ansible/" style="font-size: 10.42px;">Ansible</a> <a href="/tags/Apache/" style="font-size: 18.33px;">Apache</a> <a href="/tags/Cacti/" style="font-size: 11.67px;">Cacti</a> <a href="/tags/DNS/" style="font-size: 13.33px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/FTP/" style="font-size: 11.25px;">FTP</a> <a href="/tags/Git/" style="font-size: 10.83px;">Git</a> <a href="/tags/HA集群/" style="font-size: 11.67px;">HA集群</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/Jenkins/" style="font-size: 10.42px;">Jenkins</a> <a href="/tags/LAMP/" style="font-size: 19.58px;">LAMP</a> <a href="/tags/LNMP/" style="font-size: 17.08px;">LNMP</a> <a href="/tags/LVS/" style="font-size: 16.67px;">LVS</a> <a href="/tags/Linux/" style="font-size: 19.17px;">Linux</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux安全/" style="font-size: 14.17px;">Linux安全</a> <a href="/tags/Memcached/" style="font-size: 11.25px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 15.42px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nagios/" style="font-size: 11.67px;">Nagios</a> <a href="/tags/Nginx/" style="font-size: 17.92px;">Nginx</a> <a href="/tags/OpenStack/" style="font-size: 11.25px;">OpenStack</a> <a href="/tags/Php/" style="font-size: 14.58px;">Php</a> <a href="/tags/Puppet/" style="font-size: 11.25px;">Puppet</a> <a href="/tags/Python/" style="font-size: 14.58px;">Python</a> <a href="/tags/Redis/" style="font-size: 16.25px;">Redis</a> <a href="/tags/Resin/" style="font-size: 10px;">Resin</a> <a href="/tags/Saltstack/" style="font-size: 10px;">Saltstack</a> <a href="/tags/Samba/" style="font-size: 12.08px;">Samba</a> <a href="/tags/Squid/" style="font-size: 14.58px;">Squid</a> <a href="/tags/Tomcat/" style="font-size: 13.75px;">Tomcat</a> <a href="/tags/Zabbix/" style="font-size: 15.83px;">Zabbix</a> <a href="/tags/haproxy/" style="font-size: 12.5px;">haproxy</a> <a href="/tags/keepalived/" style="font-size: 12.92px;">keepalived</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/shell练习/" style="font-size: 18.75px;">shell练习</a> <a href="/tags/正则表达式/" style="font-size: 12.92px;">正则表达式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">失落的乐章</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">失落的乐章</h1>
			</hgroup>
			
			<p class="header-subtitle">技术面前，永远都是学生。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-MySQL/32. mysql一主多从同步配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/32. mysql一主多从同步配置/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.789Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/32. mysql一主多从同步配置/">
        mysql一主多从同步配置
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;master：192.168.101<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MYSQL版本：5.1.48-community-log</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slave1:192.168.2.182<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MYSQL版本：5.1.48-community-log</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slave2:192.168.2.111<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MYSQL版本：5.1.48-community-log</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;so…1 vs 2。</p>
<h2 id="二、master和-slave上的相关配置"><a href="#二、master和-slave上的相关配置" class="headerlink" title="二、master和 slave上的相关配置"></a>二、master和 slave上的相关配置</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3台上都一样：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>在/etc目录下可能无my.cnf文件，从/user/share/mysql目录中拷贝my-medium.cnf 到/etc并修改成my.cnf</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost etc]<span class="comment"># cp /usr/share/mysql/my-medium.cnf my.cnf</span></div><div class="line">[root@localhost etc]<span class="comment"># ll |grep my</span></div><div class="line">-rwxr-xr-x 1 root root 5204 Feb 13 22:52 my_bak</div><div class="line">-rwxr-xr-x 1 root root 4765 Jul 10 23:07 my.cnf</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;master 上;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@mysql101 ~]<span class="comment"># vi /etc/my.cnf</span></div></pre></td></tr></table></figure>
<h3 id="1-修改master上的配置文件my-cnf。"><a href="#1-修改master上的配置文件my-cnf。" class="headerlink" title="1.修改master上的配置文件my.cnf。"></a>1.修改master上的配置文件my.cnf。</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在[mysqld]下添加如下字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server-id = 1</div><div class="line"><span class="built_in">log</span>-bin=mysql-bin</div><div class="line">binlog-do-db=YYY //需要同步的数据库</div><div class="line">binlog-ignore-db=mysql //被忽略的数据库</div><div class="line">binlog-ignore-db=information-schema //被忽略的数据库</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在master上为slave添加一个同步账号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; grant replication slave on *.* to <span class="string">'affairlog'</span>@<span class="string">'192.168.2.182'</span> identified by <span class="string">'pwd123'</span>;</div><div class="line">//在slave1上登陆成功</div><div class="line">mysql&gt; grant replication slave on *.* to <span class="string">'affairlog'</span>@<span class="string">'192.168.2.111'</span> identified by <span class="string">'pwd123'</span>;</div><div class="line">//在slave2上登陆成功</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存后，重启master的mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql restart;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用show master status命令查看日志情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show master status\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">File: mysql-bin.000087</div><div class="line">Position: 106</div><div class="line">Binlog_Do_DB: YYY</div><div class="line">Binlog_Ignore_DB: mysql,information-schema</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="2-修改slave1上的配置文件my-cnf。"><a href="#2-修改slave1上的配置文件my-cnf。" class="headerlink" title="2.修改slave1上的配置文件my.cnf。"></a>2.修改slave1上的配置文件my.cnf。</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在[mysqld]下添加如下字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@mysql182 ~]<span class="comment"># vi /etc/my.cnf</span></div><div class="line">server-id=182</div><div class="line">master-host=192.168.3.101</div><div class="line">master-user= affairlog</div><div class="line">master-password=pwd123</div><div class="line">master-port=3306</div><div class="line">master-connect-retry=60</div><div class="line">replicate-do-db=YYY //同步的数据库</div><div class="line">replicate-ignore-db=mysql //被忽略的数据库</div><div class="line">replicate-ignore-db=information-schema //被忽略的数据库</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存后，重启slave的mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql restart;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;修改slave2上的配置文件my.cnf，和上面类似，只是把server-id改下，为了方便，我都用了相应的ip某位，</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;所以，slave2上我设置的server-id是111。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在进入两个slave机中的mysql。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">mysql&gt;start slave;</div><div class="line">mysql&gt;show slave status\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</div><div class="line">Master_Host: 192.168.3.101</div><div class="line">Master_User: affairlog</div><div class="line">Master_Port: 3306</div><div class="line">Connect_Retry: 60</div><div class="line">Master_Log_File: mysql-bin.000087</div><div class="line">Read_Master_Log_Pos: 106</div><div class="line">Relay_Log_File: vm111-relay-bin.000002</div><div class="line">Relay_Log_Pos: 251</div><div class="line">Relay_Master_Log_File: mysql-bin.000087</div><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: Yes</div><div class="line">Replicate_Do_DB: YYY</div><div class="line">Replicate_Ignore_DB: mysql,information-schema</div><div class="line">Replicate_Do_Table:</div><div class="line">Replicate_Ignore_Table:</div><div class="line">Replicate_Wild_Do_Table:</div><div class="line">Replicate_Wild_Ignore_Table:</div><div class="line">Last_Errno: 0</div><div class="line">Last_Error:</div><div class="line">Skip_Counter: 0</div><div class="line">Exec_Master_Log_Pos: 106</div><div class="line">Relay_Log_Space: 406</div><div class="line">Until_Condition: None</div><div class="line">Until_Log_File:</div><div class="line">Until_Log_Pos: 0</div><div class="line">Master_SSL_Allowed: No</div><div class="line">Master_SSL_CA_File:</div><div class="line">Master_SSL_CA_Path:</div><div class="line">Master_SSL_Cert:</div><div class="line">Master_SSL_Cipher:</div><div class="line">Master_SSL_Key:</div><div class="line">Seconds_Behind_Master: 0</div><div class="line">Master_SSL_Verify_Server_Cert: No</div><div class="line">Last_IO_Errno: 0</div><div class="line">Last_IO_Error:</div><div class="line">Last_SQL_Errno: 0</div><div class="line">Last_SQL_Error:</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>如果两个slave中的Slave_IO_Running、Slave_SQL_Running状态均为Yes则表明设置成功。</strong></p>
<h2 id="三、可能遇到的问题："><a href="#三、可能遇到的问题：" class="headerlink" title="三、可能遇到的问题："></a>三、可能遇到的问题：</h2><h3 id="问题1：Slave-IO-Running-No或者Slave-SQL-Running-No"><a href="#问题1：Slave-IO-Running-No或者Slave-SQL-Running-No" class="headerlink" title="问题1：Slave_IO_Running: No或者Slave_SQL_Running: No"></a>问题1：Slave_IO_Running: No或者Slave_SQL_Running: No</h3><h4 id="停掉slave服务"><a href="#停掉slave服务" class="headerlink" title="停掉slave服务"></a>停掉slave服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; slave stop;</div><div class="line">Query OK, 0 rows affected (2.01 sec)</div></pre></td></tr></table></figure>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li>在master上查看。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show master status\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">File: mysql-bin.000087</div><div class="line">Position: 1845</div><div class="line">Binlog_Do_DB: YYY</div><div class="line">Binlog_Ignore_DB: mysql,information-schema</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<ol>
<li>到slave上手动同步。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt;change master to</div><div class="line">&gt;master_host=<span class="string">'192.168.3.101'</span>,</div><div class="line">&gt;master_user=<span class="string">'affairlog'</span>,</div><div class="line">&gt;master_password=<span class="string">'pwd123'</span>,</div><div class="line">&gt;master_log_file=<span class="string">'mysql-bin.000087'</span>,</div><div class="line">&gt;master_log_pos=1845;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure>
<h4 id="启动slave服务"><a href="#启动slave服务" class="headerlink" title="启动slave服务"></a>启动slave服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; slave start;</div></pre></td></tr></table></figure>
<h4 id="再次查看Slave-IO-Running、Slave-SQL-Running状态，为Yes则表明设置成功。"><a href="#再次查看Slave-IO-Running、Slave-SQL-Running状态，为Yes则表明设置成功。" class="headerlink" title="再次查看Slave_IO_Running、Slave_SQL_Running状态，为Yes则表明设置成功。"></a>再次查看Slave_IO_Running、Slave_SQL_Running状态，为Yes则表明设置成功。</h4><h3 id="问题2：RROR-1198-HY000-This-operation-cannot-be-performed-with-a-running-slave-run-STOP-SLAVE-first"><a href="#问题2：RROR-1198-HY000-This-operation-cannot-be-performed-with-a-running-slave-run-STOP-SLAVE-first" class="headerlink" title="问题2：RROR 1198 (HY000): This operation cannot be performed with a running slave; run STOP SLAVE first"></a>问题2：RROR 1198 (HY000): This operation cannot be performed with a running slave; run STOP SLAVE first</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;错误重现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt;change master to</div><div class="line">&gt;master_host=<span class="string">'192.168.3.101'</span>,</div><div class="line">&gt;master_user=<span class="string">'affairlog'</span>,</div><div class="line">&gt;master_password=<span class="string">'pwd123'</span>,</div><div class="line">&gt;master_log_file=<span class="string">'mysql-bin.000087'</span>,</div><div class="line">&gt;master_log_pos=1845;</div><div class="line">ERROR 1198 (HY000): This operation cannot be performed with a running slave; run STOP SLAVE first</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：</p>
<ol>
<li>停掉slave服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; slave stop;</div><div class="line">Query OK, 0 rows affected (2.01 sec)</div></pre></td></tr></table></figure>
<ol>
<li>重置slave服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; reset stop;</div><div class="line">Query OK, 0 rows affected (2.01 sec)</div></pre></td></tr></table></figure>
<ol>
<li>再执行一次change命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt;change master to</div><div class="line">&gt;master_host=<span class="string">'192.168.3.101'</span>,</div><div class="line">&gt;master_user=<span class="string">'affairlog'</span>,</div><div class="line">&gt;master_password=<span class="string">'pwd123'</span>,</div><div class="line">&gt;master_log_file=<span class="string">'mysql-bin.000087'</span>,</div><div class="line">&gt;master_log_pos=1845;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure>
<ol>
<li>启动slave服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; slave start;</div></pre></td></tr></table></figure>
<p>5．再次查看Slave_IO_Running、Slave_SQL_Running状态，为Yes则表明设置成功。</p>
<h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Slave_IO_Running：连接到主库，并读取主库的日志到本地，生成本地日志文件</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Slave_SQL_Running:读取本地日志文件，并执行日志里的SQL命令。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/31. mysql5.1的RBR和SBR的优缺点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/31. mysql5.1的RBR和SBR的优缺点/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.788Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/31. mysql5.1的RBR和SBR的优缺点/">
        mysql5.1的RBR和SBR的优缺点
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MySQL 5.1 中，在复制方面的改进就是引进了新的复制技术：基于行的复制。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;简言之，这种新技术就是关注表中发生变化的记录，而非以前的照抄 binlog 模式。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从 MySQL 5.1.12 开始，可以用以下三种模式来实现：</p>
<ul>
<li>基于SQL语句的复制(statement-based replication, SBR)</li>
<li>基于行的复制(row-based replication, RBR)</li>
<li>混合模式复制(mixed-based replication, MBR)。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;相应地，binlog的格式也有三种：</p>
<ul>
<li>STATEMENT</li>
<li>ROW</li>
<li>MIXED</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MBR 模式中，SBR 模式是默认的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在运行时可以动态的改变binlog的格式，以下几种情况不能动态修改binlog格式：</p>
<ul>
<li>存储过程或者触发器中间。 </li>
<li>使用NDB engine类型的表</li>
<li>。 当前会话试用RBR模式，并且已打开了临时表。 </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果binlog采用了MIXED 模式，那么在以下几种情况下会自动将binlog的模式由 SBR模式改成RBR模式。</p>
<ul>
<li>当DML语句更新一个NDB engine表时。 </li>
<li>当写操作中包含UUID()函数时。 </li>
<li>2个或两个以上包含AUTO_INCREMENT字段的表被更新时。 </li>
<li>进行INSERT DELAYED语句操作数据时。 </li>
<li>使用UDF时。 </li>
<li>视图中必须要求使用RBR时，例如创建视图是使用了UUID()函数。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;设定主从复制模式的方法非常简单，只要在以前设定复制配置的基础上，再加一个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binlog_format=<span class="string">'STATEMENT'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binlog_format=<span class="string">'ROW'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binlog_format=<span class="string">'MIXED'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在线动态修改binlog的格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'STATEMENT'</span>;</div><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'ROW'</span>;</div><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'MIXED'</span>;</div><div class="line">mysql&gt; SET GLOBAL binlog_format = <span class="string">'STATEMENT'</span>;</div><div class="line">mysql&gt; SET GLOBAL bin log_format = <span class="string">'ROW'</span>;</div><div class="line">mysql&gt; SET GLOBAL binlog_format = <span class="string">'MIXED'</span>;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SBR和RBR两种模式各自的优缺点：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SBR 的优点：</p>
<ul>
<li>历史悠久，技术成熟。</li>
<li>binlog文件较小。</li>
<li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况。 </li>
<li>binlog可以用于实时的还原，而不仅仅用于复制。 </li>
<li>主从版本可以不一样，从服务器版本可以比主服务器版本高。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SBR 的缺点：</p>
<ul>
<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。 </li>
<li>调用具有不确定因素的 UDF 时复制也可能出问题 </li>
<li>使用以下函数的语句也无法被复制：<ul>
<li>LOAD_FILE()</li>
<li>UUID()</li>
<li>USER()</li>
<li>FOUND_ROWS()</li>
<li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项) </li>
</ul>
</li>
<li>INSERT … SELECT 会产生比 RBR 更多的行级锁</li>
<li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁 </li>
<li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句 </li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响 </li>
<li>存储函数(不是存储过程)在被调用的同时也会执行一次 NOW() 函数，这个可以说是坏事也可能是好事 </li>
<li>确定了的 UDF 也需要在从服务器上执行 </li>
<li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错 </li>
<li>执行复杂语句如果出错的话，会消耗更多资源</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RBR 的优点：</p>
<ul>
<li>任何情况都可以被复制，这对复制来说是最安全可靠的 </li>
<li>和其他大多数数据库系统的复制技术一样 </li>
<li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多 </li>
<li>复制以下几种语句时的行锁更少：<ul>
<li>INSERT … SELECT</li>
<li>包含 AUTO_INCREMENT 字段的 INSERT</li>
<li>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句 </li>
</ul>
</li>
<li>执行 INSERT，UPDATE，DELETE 语句时锁更少 - </li>
<li>从服务器上采用多线程来执行复制成为可能</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RBR 的缺点：</p>
<ul>
<li>binlog 大了很多 </li>
<li>复杂的回滚时 binlog 中会包含大量的数据 </li>
<li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 </li>
<li>UDF 产生的大 BLOB 值会导致复制变慢 </li>
<li>无法从 binlog 中看到都复制了写什么语句 </li>
<li>当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外，针对系统库 mysql 里面的表发生变化时的处理规则如下：</p>
<ul>
<li>如果是采用 INSERT，UPDATE，DELETE 直接操作表的情况，则日志格式根据 binlog_format 的设定而记录 </li>
<li>如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何都采用 SBR 模式记录 </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：采用 RBR 模式后，能解决很多原先出现的主键重复问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/3. 源码编译安装MySQL5.6报错及解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/3. 源码编译安装MySQL5.6报错及解决方法/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.787Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/3. 源码编译安装MySQL5.6报错及解决方法/">
        源码编译安装MySQL5.6报错及解决方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以前都是mysql5.1做的LAMP搭建，比较顺利。试了一下安装mysql5.6.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于系统没有cmake命令，于是 <code>yum install -y cmake</code> 进行安装</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在cmake这里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/mysql -DMYSQL_DATADIR=/data/mysql_data -DMYSQL_UNIX_ADDR=/usr/<span class="built_in">local</span>/mysql/mysql.sock -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- Could NOT find Curses (missing: CURSES_LIBRARY CURSES_INCLUDE_PATH)</div><div class="line">CMake Error at cmake/readline.cmake:82 (MESSAGE):</div><div class="line"> Curses library not found. Please install appropriate package,</div><div class="line">    remove CMakeCache.txt and rerun cmake.On Debian/Ubuntu, package name is libncurses5-dev, on Redhat and derivates it is ncurses-devel.</div><div class="line">Call Stack (most recent call first):</div><div class="line"> cmake/readline.cmake:126 (FIND_CURSES)</div><div class="line"> cmake/readline.cmake:216 (MYSQL_USE_BUNDLED_LIBEDIT)</div><div class="line"> CMakeLists.txt:250 (MYSQL_CHECK_READLINE)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决办法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost mysql-5.6.1]<span class="comment"># rm CMakeCache.txt</span></div><div class="line">[root@localhost mysql-5.6.1]<span class="comment"># yum install -y ncurses-devel</span></div><div class="line">[root@localhost mysql-5.5.11]<span class="comment"># yum install -y bison</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;接着继续执行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cmake......</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;编译完成，安装好之后。新建系统用户mysql，并禁止登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -s /sbin/nologin mysql</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;建立数据库存放目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p /data/mysql_data</div><div class="line">chown -R mysql:mysql /data/mysql_data</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进行数据库初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</div><div class="line">./scripts/mysql_install_db --user=mysql --datadir=/data/mysql_data</div><div class="line">cp support-files/my-large.cnf /etc/my.cnf </div><div class="line">cp support-files/mysql.server /etc/init.d/mysqld</div><div class="line">chmod 755 /etc/init.d/mysqld </div><div class="line">vim /etc/init.d/mysqld //添加datadir=路径</div><div class="line">service mysqld start -------------------------------服务启动报错</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;报错信息如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@centos6 mysql_data]<span class="comment"># service mysqld start</span></div><div class="line">Starting MySQL...The server quit without updating PID file [失败]/mysql_data/centos6.6.pid).</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：根据报错信息，怀疑可能文件丢失造成的原因，对比另一个测试机已经搭建好的环境，检查同样的数据库目录下，发现本机少了一个centos6.6.pid文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /data/mysql_data //数据库文件存放目录</div><div class="line">vi centos6.6.pid //编辑此文件，添加一个pid号码</div><div class="line">1583 </div><div class="line">保存退出。 //1583是我在系统中随意添加的号，只要保证系统进程里没有的ID都可以</div><div class="line">service mysqld start 正常启动 ----------------------------成功解决</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/30. mysql架构由小变大的演变过程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/30. mysql架构由小变大的演变过程/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.787Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/30. mysql架构由小变大的演变过程/">
        mysql架构由小变大的演变过程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;假设一个网站（discuz）从最开始访问量很小做到日pv千万，我们来推测一下它的mysql服务器架构演变过程。</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站访问量日pv量级在1w以下。<strong>单台机器跑web和db</strong>，不需要做架构层调优（比如，不需要增加memcached缓存）。此时，数据往往都是每日冷备份的，但有时候如果考虑数据安全性，会搭建一个mysql主从。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站访问量日pv达到几万。此时单台机器已经有点负载，<strong>需要我们把web和db分开</strong>，需要搭建memcached服务作为缓存。也就是说，在这个阶段，我们还可以使用单台机器跑mysql去承担整个网站的数据存储和查询。如果做mysql主从，目的也是为了数据安全性。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站访问量日pv达到几十万。单台机器虽然也可以支撑，但是需要的机器配置要比之前的机器好很多。如果经费允许，可以购买配置很高的机器来跑mysql服务，但是并不是说，配置翻倍，性能也翻倍，到了一定阶段配置增加已经不能带来性能的增加。所以，此阶段，我们会想到做mysql服务的集群，也就是说我们可以拿多台机器跑mysql。但，mysql的集群和web集群是不一样的，我们需要考虑数据的一致性，所以不能简单套用做web集群的方式（lvs，nginx代理）。可以做的架构是，<strong>mysql主从，一主多从</strong>。为了保证架构的健壮和数据完整，主只能是一个，从可以是多个。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;还有一个问题，我们需要想到，就是在前端web层，我们的程序里面指定了mysql机器的ip，那么当mysql机器有多台时，程序里面如何去配置？discuz，其实有一个功能，支持mysql读写分离。即，我们可以拿多台机器跑mysql，其中一台写，其他多台是读，我们只需要把读和写的ip分别配置到程序中，程序自动会去区分机器。当然，如果不使用discuz自带的配置，我们还可以引用一个软件叫做 <strong>mysql-proxy</strong>, 使用他来实现读写分离。它支持一主多从的模式。</p>
<h2 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站访问量日pv到几百万。之前的一主多从模式已经遇到瓶颈，因为当网站访问量变大，读数据库的量也会越来越大，我们需要多加一些从进来，但是从的数量增加到数十台时，由于主需要把bin-log全部分发到所有从上，那么这个过程本身就是一件很繁琐的事情，再加上频繁读取，势必会造成从上同步过来的数据有很大延迟。所以，我们可以做一个优化， <strong>把mysql原来的一主多从变为一主一从，然后从作为其他从的主，而前面的主只负责网站业务的写入，而后面的从不负责网站任何业务，只负责给其他从同步bin-log</strong>。这样还可以继续多叠加几个从库。</p>
<h2 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站访问量日pv到1千万的时候，我们发现，网站的写入量非常大，我们之前架构中只有一个主，这里的主已经成为瓶颈了。所以，需要再近一步做出调整。比如，我们可以把业务分模块，把用户相关的单独分离出来，把权限、积分等也可以分离出来单独跑一个库，然后再做主从，也就是所谓的分库。当然也可以换一个纬度，把访问量或者写入量大的表单独分离出来，跑在一台服务器上，也可以把一个表分成多个小表。这一步操作，涉及到一些程序上的改动，所以需要事先和开发同事做好沟通和设计。总之，这一步要做的就是<strong>分库分表</strong>。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;再往后发展，继续把大表分小表即可。 而国内阿里淘宝网站的数据量是巨量的，他们的数据库全部都是mysql，他们的mysql架构就是遵循分库分表这个原则的，只不过他们划分规则会有很多纬度，比如可以根据地域划分，可以根据买家、卖家划分，可以根据时间划分等等。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/29. mysql AB 常见错误" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/29. mysql AB 常见错误/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.786Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/29. mysql AB 常见错误/">
        mysql AB 常见错误
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这篇文章旨在记录MySQL Replication的常见错误，包括自己工作中遇到的与网友在工作中遇到的，方面自己及别人以后进行查找。每个案例都是通过Last_IO_Errno/Last_IO_Error或者Last_SQL_Errno/Last_SQL_Error给出错误关键信息，所以以后查找时只需直接ctrl+F查找关键字就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_SQL_Errno: 1677</div><div class="line">Last_SQL_Error: Column 1 of table <span class="string">'test.t'</span> cannot be converted from <span class="built_in">type</span> <span class="string">'int'</span> to <span class="built_in">type</span> <span class="string">'bigint(20)'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：这个案例是从网上找到的，自己动手实验了一把。从错误信息来看表面上是由于在slave上无法执行一条转换字段类型的SQL语句。实际上并不是有这种语句直接引起的，而是间接引起的（之前某些操作导致主从表字段类型不一致，接下来对这个表进行DML时就会报错）。它的意思是在对这个表t进行DML操作时，发现主从上表结果不一致，比如这里是说在主上t的字段1是int类型，但是从上t的字段1是bigint类型，所以报错。那么为什么要报错呢？这是从安全角度考虑，因为如果字段类型不一致可能会导致数据截断之类的问题。那么解决方法呢？通过参数slave_type_conversions进行控制，它有三种取值：</p>
<ul>
<li>ALL_LOSSY：仅支持有损转换，什么叫有损？比如一个值本来是bigint存储为9999999999999，现在转换为int类型势必会要截断从而导致数据不一致。</li>
<li>ALL_NON_LOSSY：仅支持无损转换，只能在无损的情况下才能进行转换</li>
<li>ALL_LOSSY,ALL_NON_LOSSY：有损/无算转换都支持</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;空，即不设置这个参数：必须主从的字段类型一模一样。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注意： 前面说的这几中情况都只在binlog_format=ROW的情况下才有效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_SQL_Errno: 1194</div><div class="line">Last_SQL_Error: Error <span class="string">'Table '</span>traincenter<span class="string">' is marked as crashed and should be repaired'</span> on query. Default database: <span class="string">'basketballman'</span>. Query: <span class="string">'update traincenter set points='</span>4<span class="string">',pointstime='</span>1361912066<span class="string">'  where uid = '</span>1847482697<span class="string">' limit 1'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：myisam表traincenter损坏，直接repair table即可。至于为什么myisam类型表比innodb更容易损坏，我觉得有两个原因：1，innodb有double write机制，损坏或者half write的页可以用它恢复，第二innodb是事务引擎，都有操作都是事务的，而myisam是非事务的，存在写一半但是操作终止情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_IO_Errno: 1236</div><div class="line">Last_IO_Error: Got fatal error 1236 from master when reading data from binary <span class="built_in">log</span>: <span class="string">'Could not find first log file name in binary log index file'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：主库上的binlog文件已经不存在但是在index file中确有相应记录存在。我这里发生这个错误的原因在于由于复制中断时间很长，报警出来一直没人处理，这个中断时间超过master上binlog超期时间，等恢复复制时需要的binlog已经由于其超期而被删掉，没办法只好重建这个实例了。以大家都要引以为戒。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_IO_Errno: 1593</div><div class="line">Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different <span class="keyword">for</span> replication to work (or the --replicate-same-server-id option must be used on slave but this does not always make sense; please check the manual before using it).</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：主从配置的server-id一样，而在主从复制环境中server-id一样的binlog events都会被过滤掉。具体server-id的含义可以了解一下复制原理。这个一般是因为拷贝配置文件时忘记修改server-id导致，遇到这类问题也比较容易，平时操作谨慎一点即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_Errno: 1053</div><div class="line">Last_Error: Query partially completed on the master (error on master: 1053) and was aborted. There is a chance that your master is inconsistent at this point. If you are sure that your master is ok, run this query manually on the slave and <span class="keyword">then</span> restart the slave with SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; START SLAVE; . Query: <span class="string">'insert into ...</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：查询在master上部分完成，然后终止了。这马上又能想到是myisam表，结果也正是这样。由于myisam不支持事务所以可能存在一个查询完成一部分然后失败的情况。解决方法一般也就是提示信息给出的跳过一个binlog event。不过确认跳过之前最好还是查询一下master上是否真的存在相应的记录，因为错误信息同时还会给出它认为在master上执行一部分然后终止的查询语句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_SQL_Errno: 1666</div><div class="line">Last_SQL_Error: Error executing row event: <span class="string">'Cannot execute statement: impossible to write to binary log since statement is in row format and BINLOG_FORMAT = STATEMENT.'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：这个案例的背景是做一个ABC结构的复制，B、C中设定的binlog_format=statement，A中的是MIXED，所以当B尝试重做A过来的relay log，然后记录binlog（传给C）时发现relay log的binlog_format与自己设定的binlog_format不一致。我当时就是直接先更改BC的binlog_format=MIXED解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_Errno: 1032</div><div class="line">Last_Error: Could not execute Update_rows event on table db.table; Can<span class="string">'t find record in '</span>table<span class="string">', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event'</span>s master <span class="built_in">log</span> mysql-bin.000064, end_log_pos 158847</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：这个是在binlog_format=row复制下发生的。原因是因为row格式复制是最严格的，所以在mysql看来如果在从库上找不到要更新的这条记录，那么就代表主从数据不一致，因此报错。另外顺便说一句，对于row格式binlog，如果某个更新操作实际上并没有更新行，这个操作是不会记binlog的，因为row格式的binlog宗旨就是只记录发生了改变的行。所以这个解决办法根据你自己实际应用来定，最好的方法还是重做slave吧，这样更放心。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last_Errno: 28</div><div class="line">Last_Error: Error <span class="keyword">in</span> Append_block event: write to <span class="string">'/tmp/SQL_LOAD-32343798-72213798-1.data'</span> failed</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法： 首先说错误原因：主库执行load data infile，同步到从库后load data infile存放的文件默认是放在/tmp(由参数slave_load_tmpdir控制)，而/tmp空间不够因此报错。因此只要将从库上slave_load_tmpdir设置到一个磁盘空间足够大的分区就行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/28. cobar实现mysql分库分表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/28. cobar实现mysql分库分表/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.785Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/28. cobar实现mysql分库分表/">
        cobar实现mysql分库分表
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cobar 编译安装配置笔记:<a href="https://github.com/alibaba/cobar" target="_blank" rel="external">https://github.com/alibaba/cobar</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;windows下使用eclipse导入cobar项目,eclipse File -&gt; Import -&gt; Git :<a href="https://github.com/alibaba/cobar" target="_blank" rel="external">https://github.com/alibaba/cobar</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;linux下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://codeload.github.com/alibaba/cobar/zip/master</div></pre></td></tr></table></figure>
<p>F:\mycat&gt;mvn compile<br>F:\mycat&gt;mvn package</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;生成压缩包cobar-server-1.2.7.tar.gz，放到linux环境中解压出来，没有logs目录，新建并运行查看目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@XAYQ-Test3 ~]<span class="comment"># tree /opt/cobar-server  </span></div><div class="line">/opt/software/cobar-server  </div><div class="line">├── bin  </div><div class="line">│   ├── restart.sh  </div><div class="line">│   ├── shutdown.sh  </div><div class="line">│   ├── startup.bat  </div><div class="line">│   └── startup.sh  </div><div class="line">├── conf  </div><div class="line">│   ├── log4j.xml                       <span class="comment">#日志配置文件，不需要修改  </span></div><div class="line">│   ├── rule.xml                        <span class="comment">#mysql路由规则  </span></div><div class="line">│   ├── schema.xml                      <span class="comment">#  </span></div><div class="line">│   └── server.xml                      <span class="comment">#  </span></div><div class="line">├── lib  </div><div class="line">│   ├── cobar-server-1.2.7.jar  </div><div class="line">│   └── log4j-1.2.17.jar  </div><div class="line">└── logs  </div><div class="line">    ├── alarm.log  </div><div class="line">    ├── console.log  </div><div class="line">    ├── heartbeat.log  </div><div class="line">    ├── stdout.log  </div><div class="line">    └── stdout.log.2014-07-10</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.主要修改以下几个文件：rule.xml </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<!-- 路由规则定义，定义什么表，什么字段，采用什么路由算法 -->  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&lt;tableRule name=<span class="string">"rule1"</span>&gt;  </div><div class="line">  &lt;rule&gt;  </div><div class="line">    &lt;columns&gt;id&lt;/columns&gt;  </div><div class="line">    &lt;algorithm&gt;&lt;![CDATA[ func1(<span class="variable">$&#123;id&#125;</span>) ]]&gt;&lt;/algorithm&gt;  </div><div class="line">  &lt;/rule&gt;  </div><div class="line">&lt;/tableRule&gt;  </div><div class="line">  </div><div class="line">&lt;!-- 路由函数定义 --&gt;  </div><div class="line">&lt;<span class="keyword">function</span> name=<span class="string">"func1"</span> class=<span class="string">"com.alibaba.cobar.route.function.PartitionByLong"</span>&gt;  </div><div class="line">  &lt;property name=<span class="string">"partitionCount"</span>&gt;2&lt;/property&gt;  </div><div class="line">  &lt;property name=<span class="string">"partitionLength"</span>&gt;512&lt;/property&gt;  </div><div class="line">&lt;/<span class="keyword">function</span>&gt;  </div><div class="line">```  </div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;2.schema.xml ，定义数据节点</span></div><div class="line"></div><div class="line">```bash</div><div class="line">&lt;cobar:schema xmlns:cobar=<span class="string">"http://cobar.alibaba.com/"</span>&gt;  </div><div class="line">  </div><div class="line">  &lt;!-- schema定义 --&gt;  </div><div class="line">  &lt;schema name=<span class="string">"cppdb"</span> dataNode=<span class="string">"cppDb1"</span>&gt;  </div><div class="line">    &lt;table name=<span class="string">"tb2"</span> dataNode=<span class="string">"cppDb2,cppDb3"</span> rule=<span class="string">"rule1"</span> /&gt;  </div><div class="line">  &lt;/schema&gt;  </div><div class="line">  </div><div class="line">  &lt;!-- 数据节点定义，数据节点由数据源和其他一些参数组织而成。--&gt;  </div><div class="line">  &lt;dataNode name=<span class="string">"cppDb1"</span>&gt;  </div><div class="line">    &lt;property name=<span class="string">"dataSource"</span>&gt;  </div><div class="line">      &lt;dataSourceRef&gt;cppDataSource[0]&lt;/dataSourceRef&gt;  </div><div class="line">    &lt;/property&gt;  </div><div class="line">  &lt;/dataNode&gt;  </div><div class="line">  &lt;dataNode name=<span class="string">"cppDb2"</span>&gt;  </div><div class="line">    &lt;property name=<span class="string">"dataSource"</span>&gt;  </div><div class="line">      &lt;dataSourceRef&gt;cppDataSource[1]&lt;/dataSourceRef&gt;  </div><div class="line">    &lt;/property&gt;  </div><div class="line">  &lt;/dataNode&gt;  </div><div class="line">  &lt;dataNode name=<span class="string">"cppDb3"</span>&gt;  </div><div class="line">    &lt;property name=<span class="string">"dataSource"</span>&gt;  </div><div class="line">      &lt;dataSourceRef&gt;cppDataSource[2]&lt;/dataSourceRef&gt;  </div><div class="line">    &lt;/property&gt;  </div><div class="line">  &lt;/dataNode&gt;  </div><div class="line">  </div><div class="line">  &lt;!-- 数据源定义，数据源是一个具体的后端数据连接的表示。--&gt;  </div><div class="line">  &lt;dataSource name=<span class="string">"cppDataSource"</span> <span class="built_in">type</span>=<span class="string">"mysql"</span>&gt;  </div><div class="line">    &lt;property name=<span class="string">"location"</span>&gt;  </div><div class="line">      &lt;location&gt;172.22.14.7:3306/cpp1&lt;/location&gt;  </div><div class="line">      &lt;location&gt;172.22.14.7:3306/cpp2&lt;/location&gt;  </div><div class="line">      &lt;location&gt;172.22.14.7:3306/cpp3&lt;/location&gt;  </div><div class="line">    &lt;/property&gt;  </div><div class="line">    &lt;property name=<span class="string">"user"</span>&gt;root&lt;/property&gt;  </div><div class="line">    &lt;property name=<span class="string">"password"</span>&gt;root&lt;/property&gt;  </div><div class="line">    &lt;property name=<span class="string">"sqlMode"</span>&gt;STRICT_TRANS_TABLES&lt;/property&gt;  </div><div class="line">  &lt;/dataSource&gt;  </div><div class="line">  </div><div class="line">&lt;/cobar:schema&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.server.xml，定义cobar对外统一的数据接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  &lt;!-- 用户访问定义，用户名、密码、schema等信息。 --&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;user name=<span class="string">"root"</span>&gt;  </div><div class="line">&lt;property name=<span class="string">"password"</span>&gt;root&lt;/property&gt;  </div><div class="line">&lt;property name=<span class="string">"schemas"</span>&gt;cppdb&lt;/property&gt;  </div><div class="line">t;/user&gt;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/27. Mysql主主复制架构配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/27. Mysql主主复制架构配置/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.784Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/27. Mysql主主复制架构配置/">
        Mysql主主复制架构配置
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MySQL主主复制结构区别于主从复制结构。在主主复制结构中，两台服务器的任</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;何一台上面的数据库存发生了改变都会同步到另一台服务器上，这样两台服务器</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;互为主从，并且都能向外提供服务。 这就比使用主从复制具有更好的性能。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;接下来我将使用两个同样的服务器来实现这个效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server1_mysql：192.168.1.108</div><div class="line">server2_mysql: 192.168.1.110</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;拓扑结构：<br>server1_mysql——-server2_mysql</p>
<h2 id="1-创建用户并授权"><a href="#1-创建用户并授权" class="headerlink" title="1.创建用户并授权"></a>1.创建用户并授权</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server1:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'server2'</span>@<span class="string">'192.168.1.110'</span> </div><div class="line">IDENTIFIED BY <span class="string">'server2'</span>;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'server1'</span>@<span class="string">'192.168.1.108'</span> </div><div class="line">IDENTIFIED BY <span class="string">'server1'</span>;</div></pre></td></tr></table></figure>
<h2 id="2-修改Mysql的主配置文件"><a href="#2-修改Mysql的主配置文件" class="headerlink" title="2.修改Mysql的主配置文件"></a>2.修改Mysql的主配置文件</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server1:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">server-id = 10</div><div class="line"><span class="built_in">log</span>-bin = mysql-bin</div><div class="line">replicate-do-db = mydb</div><div class="line">auto-increment-increment = 2   //每次增长2</div><div class="line">auto-increment-offset = 1  //设置自动增长的字段的偏移量，即初始值为2</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;启动Mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># service mysqld restart</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line"> server-id = 20</div><div class="line"> <span class="built_in">log</span>-bin = mysql-bin</div><div class="line"> replicate-do-db = mydb</div><div class="line"> auto-increment-increment = 2  //每次增长2</div><div class="line"> auto-increment-offset = 2 //设置自动增长的字段的偏移量，即初始值为2</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;启动Mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># service mysqld restart</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：二都只有server-id不同和 auto-increment- offset不同.auto-increment-increment的值应设为整个结构中服务器的总数，本案例用到两台服务器，所以值设为2。</p>
<h2 id="3-重新启动两个服务器"><a href="#3-重新启动两个服务器" class="headerlink" title="3.重新启动两个服务器"></a>3.重新启动两个服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># service mysqld restart</span></div></pre></td></tr></table></figure>
<h2 id="4-为了让两个数据库一样，我们备份其中一个数据库，然后在另一个数据库上恢复，这样是两个数据库一开始都是一样的。"><a href="#4-为了让两个数据库一样，我们备份其中一个数据库，然后在另一个数据库上恢复，这样是两个数据库一开始都是一样的。" class="headerlink" title="4.为了让两个数据库一样，我们备份其中一个数据库，然后在另一个数据库上恢复，这样是两个数据库一开始都是一样的。"></a>4.为了让两个数据库一样，我们备份其中一个数据库，然后在另一个数据库上恢复，这样是两个数据库一开始都是一样的。</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在server1上操作:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysqldump --databases luowei &gt; /tmp/luowei.sql</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在server2上操作：创建一个与mydb同名的空数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysql</span></div><div class="line">    &gt; CREATE DATABASE mydb;</div><div class="line">    &gt;\q</div><div class="line"><span class="comment"># scp 192.168.1.108:/tmp/mydb.sql  ./</span></div><div class="line"><span class="comment"># mysql -uroot -p mydb &lt; /tmp/luowei.sql</span></div></pre></td></tr></table></figure>
<h2 id="5-然后两个服务器相互通告二进制日志的位置并启动复制功能："><a href="#5-然后两个服务器相互通告二进制日志的位置并启动复制功能：" class="headerlink" title="5.然后两个服务器相互通告二进制日志的位置并启动复制功能："></a>5.然后两个服务器相互通告二进制日志的位置并启动复制功能：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在server1上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysql</span></div><div class="line">   &gt; CHANGE MASTER TO</div><div class="line">   &gt; MASTER_HOST=<span class="string">'192.168.1.110'</span>,</div><div class="line">   &gt; MASTER_USER=<span class="string">'server2'</span>,</div><div class="line">   &gt; MASTER_PASSWORD=<span class="string">'server2'</span>;</div><div class="line">mysql &gt; START SLAVE;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在server2上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysql</span></div><div class="line">   &gt; CHANGE MASTER TO</div><div class="line">   &gt; MASTER_HOST=<span class="string">'192.168.1.108'</span>,</div><div class="line">   &gt; MASTER_USER=<span class="string">'server1'</span>,</div><div class="line">   &gt; MASTER_PASSWORD=<span class="string">'server1'</span>;</div><div class="line">mysql &gt; START SLAVE;</div></pre></td></tr></table></figure>
<h2 id="6-查看，并验证"><a href="#6-查看，并验证" class="headerlink" title="6.查看，并验证"></a>6.查看，并验证</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;分别在两个数据库服务器上查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql &gt; SHOW SLAVE STATUS\G;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后查看数据库和表，你会发现内容是一样的，这样就是整个主主Mysql的架构的配置过程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/26. Mysql数据库主从心得整理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/26. Mysql数据库主从心得整理/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.783Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/26. Mysql数据库主从心得整理/">
        Mysql数据库主从心得整理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、mysql主从的原理"><a href="#一、mysql主从的原理" class="headerlink" title="一、mysql主从的原理"></a>一、mysql主从的原理</h2><h3 id="1、Replication-线程"><a href="#1、Replication-线程" class="headerlink" title="1、Replication 线程"></a>1、Replication 线程</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql的 Replication 是一个异步的复制过程（mysql5.1.7以上版本分为异步复制和半同步两种模式），从一个 Mysql instace(我们称之为 Master)复制到另一个 Mysql instance(我们称之 Slave)。在 Master 与 Slave 之间的实现整个复制过程主要由三个线程来完成，其中两个线程(Sql线程和IO线程)在 Slave 端，另外一个线程(IO线程)在 Master 端。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;要实现 MySQL 的 Replication ，首先必须打开 Master 端的Binary Log(mysql-bin.xxxxxx)功能，否则无法实现。因为整个复制过程实际上就是Slave从Master端获取该日志然后再在自己身上完全 顺序的执行日志中所记录的各种操作。打开 MySQL 的 Binary Log 可以通过在启动 MySQL Server 的过程中使用 “—log-bin” 参数选项，或者在 my.cnf 配置文件中的 mysqld 参数组([mysqld]标识后的参数部分)增加 “log-bin” 参数项。</p>
<h3 id="2、MySQL-复制的基本过程如下："><a href="#2、MySQL-复制的基本过程如下：" class="headerlink" title="2、MySQL 复制的基本过程如下："></a>2、MySQL 复制的基本过程如下：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1．Slave 上面的IO线程连接上 Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2. Master 接收到来自 Slave 的 IO 线程的请求后，通过负责复制的 IO 线程根据请求信息读取指定日志指定位置之后的日志信息，返回给 Slave 端的 IO 线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在 Master 端的 Binary Log 文件的名称以及在 Binary Log 中的位置；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3. Slave 的 IO 线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的Relay Log文件(mysql-relay-bin.xxxxxx)的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master- info文件中，以便在下一次读取的时候能够清楚的高速Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4. Slave 的 SQL 线程检测到 Relay Log 中新增加了内容后，会马上解析该 Log 文件中的内容成为在 Master 端真实执行时候的那些可执行的 Query 语句，并在自身执行这些 Query。这样，实际上就是在 Master 端和 Slave 端执行了同样的 Query，所以两端的数据是完全一样的。</p>
<h3 id="3、Mysql复制的几种模式"><a href="#3、Mysql复制的几种模式" class="headerlink" title="3、Mysql复制的几种模式"></a>3、Mysql复制的几种模式</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.从 MySQL 5.1.12 开始，可以用以下三种模式来实现：</p>
<ul>
<li>基于SQL语句的复制(statement-based replication, SBR)，</li>
<li>基于行的复制(row-based replication, RBR)，</li>
<li>混合模式复制(mixed-based replication, MBR)。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。 MBR 模式中，SBR 模式是默认的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在运行时可以动态改动 binlog的格式，除了以下几种情况：</p>
<ol>
<li>存储流程或者触发器中间</li>
<li>启用了NDB</li>
<li>当前会话试用 RBR 模式，并且已打开了临时表</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果binlog采用了 MIXED 模式，那么在以下几种情况下会自动将binlog的模式由 SBR 模式改成 RBR 模式：</p>
<ol>
<li>当DML语句更新一个NDB表时</li>
<li>当函数中包含 UUID() 时</li>
<li>2个及以上包含 AUTO_INCREMENT 字段的表被更新时</li>
<li>行任何 INSERT DELAYED 语句时</li>
<li>用 UDF 时</li>
<li>视图中必须要求运用 RBR 时，例如建立视图是运用了 UUID() 函数</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.设定主从复制模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">log</span>-bin=mysql-bin</div><div class="line"><span class="comment">#binlog_format="STATEMENT"</span></div><div class="line"><span class="comment">#binlog_format="ROW"</span></div><div class="line">binlog_format=<span class="string">"MIXED"</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;也可以在运行时动态修改binlog的格式。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'STATEMENT'</span>;</div><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'ROW'</span>;</div><div class="line">mysql&gt; SET SESSION binlog_format = <span class="string">'MIXED'</span>;</div><div class="line">mysql&gt; SET GLOBAL binlog_format = <span class="string">'STATEMENT'</span>;</div><div class="line">mysql&gt; SET GLOBAL binlog_format = <span class="string">'ROW'</span>;</div><div class="line">mysql&gt; SET GLOBAL binlog_format = <span class="string">'MIXED'</span>;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.两种模式各自的优缺点：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SBR 的优点：</p>
<ul>
<li>历史悠久，技能成熟</li>
<li>binlog文件较小</li>
<li>binlog中包含了所有数据库修改信息，可以据此来审核数据库的安全等情况</li>
<li>binlog可以用于实时的还原，而不仅仅用于复制</li>
<li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SBR 的缺点：</p>
<ul>
<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。</li>
<li>调用具有不确定因素的 UDF 时复制也可能出疑问</li>
<li>运用以下函数的语句也不能被复制：<ul>
<li>LOAD_FILE()</li>
<li>UUID()</li>
<li>USER()</li>
<li>FOUND_ROWS()</li>
<li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</li>
</ul>
</li>
<li>INSERT … SELECT 会产生比 RBR 更多的行级锁</li>
<li>复制须要执行 全表扫描(WHERE 语句中没有运用到索引)的 UPDATE 时，须要比 RBR 请求更多的行级锁</li>
<li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li>
<li>存储函数(不是存储流程 )在被调用的同时也会执行一次 NOW() 函数，这个可以说是坏事也可能是好事</li>
<li>确定了的 UDF 也须要在从服务器上执行</li>
<li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li>
<li>执行复杂语句如果出错的话，会消耗更多资源</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RBR 的优点：</p>
<ul>
<li>任何情况都可以被复制，这对复制来说是最安全可靠的</li>
<li>和其他大多数数据库系统的复制技能一样</li>
<li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li>
<li>复制以下几种语句时的行锁更少：<ul>
<li>INSERT … SELECT</li>
<li>包含 AUTO_INCREMENT 字段的 INSERT</li>
<li>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li>
</ul>
</li>
<li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li>
<li>从服务器上采用多线程来执行复制成为可能</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RBR 的缺点：</p>
<ul>
<li>binlog 大了很多</li>
<li>复杂的回滚时 binlog 中会包含大量的数据</li>
<li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写疑问</li>
<li>UDF 产生的大 BLOB 值会导致复制变慢</li>
<li>不能从 binlog 中看到都复制了写什么语句(加密过的)</li>
<li>当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外，针对系统库 mysql 里面的表发生变化时的处理准则如下：</p>
<ul>
<li>如果是采用 INSERT，UPDATE，DELETE 直接操作表的情况，则日志格式根据 binlog_format 的设定而记录</li>
<li>如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何 都采用 SBR 模式记录。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：采用 RBR 模式后，能处理很多原先出现的主键重复问题。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;实例:对于insert into db_allot_ids select * from db_allot_ids 这个语句:</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在BINLOG_FORMAT=STATEMENT 模式下:</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BINLOG日志信息为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN</div><div class="line">/*!*/;</div><div class="line"><span class="comment"># at 173</span></div><div class="line"><span class="comment">#090612 16:05:42 server id 1 end_log_pos 288 Query thread_id=4 exec_time=0 error_code=0</span></div><div class="line">SET TIMESTAMP=1244793942/*!*/;</div><div class="line">insert into db_allot_ids select * from db_allot_ids</div><div class="line">/*!*/;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在BINLOG_FORMAT=ROW 模式下:</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BINLOG日志信息为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BINLOG <span class="string">'</span></div><div class="line"><span class="string">hA0yShMBAAAAMwAAAOAAAAAAAA8AAAAAAAAAA1NOUwAMZGJfYWxsb3RfaWRzAAIBAwAA</span></div><div class="line"><span class="string">hA0yShcBAAAANQAAABUBAAAQAA8AAAAAAAEAAv/8AQEAAAD8AQEAAAD8AQEAAAD8AQEAAAA=</span></div><div class="line"><span class="string">'</span>/*!*/;</div></pre></td></tr></table></figure>
<h3 id="4、Mysql主从的优缺点"><a href="#4、Mysql主从的优缺点" class="headerlink" title="4、Mysql主从的优缺点"></a>4、Mysql主从的优缺点</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MySQL的主从同步是一个很成熟的架构，优点为：①在从服务器可以执行查询工作(即我们常说的读功能)，降低主服 务器压力;②在从主服务器进行备份，避免备份期间影响主服务器服务;③当主服务器出现问题时，可以切换到从服务器。所以我在项目部署和实施中经常会采用这种方案;鉴于生产环境下的mysql的严谨性。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;实际上，在老版本中，MySQL 的复制实现在 Slave 端并不是由 SQL 线程和 IO 线程这两个线程共同协作而完成的，而是由单独的一个线程来完成所有的工作。但是 MySQL 的工程师们很快发现，这样做存在很大的风险和性能问题，主要如下：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先，如果通过一个单一的线程来独立实现这个工作的话，就使复制 Master 端的，Binary Log日志，以及解析这些日志，然后再在自身执行的这个过程成为一个串行的过程，性能自然会受到较大的限制，这种架构下的 Replication 的延迟自然就比较长了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其次，Slave 端的这个复制线程从 Master 端获取 Binary Log 过来之后，需要接着解析这些内容，还原成 Master 端所执行的原始 Query，然后在自身执行。在这个过程中，Master端很可能又已经产生了大量的变化并生成了大量的 Binary Log 信息。如果在这个阶段 Master 端的存储系统出现了无法修复的故障，那么在这个阶段所产生的所有变更都将永远的丢失，无法再找回来。这种潜在风险在Slave 端压力比较大的时候尤其突出，因为如果 Slave 压力比较大，解析日志以及应用这些日志所花费的时间自然就会更长一些，可能丢失的数据也就会更多。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;所以，在后期的改造中，新版本的 MySQL 为了尽量减小这个风险，并提高复制的性能，将 Slave 端的复制改为两个线程来完成，也就是前面所提到的 SQL 线程和 IO 线程。最早提出这个改进方案的是Yahoo!的一位工程师“Jeremy Zawodny”。通过这样的改造，这样既在很大程度上解决了性能问题，缩短了异步的延时时间，同时也减少了潜在的数据丢失量。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当然，即使是换成了现在这样两个线程来协作处理之后，同样也还是存在 Slave 数据延时以及数据丢失的可能性的，毕竟这个复制是异步的。只要数据的更改不是在一个事务中，这些问题都是存在的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果要完全避免这些问题，就只能用 MySQL 的 Cluster 来解决了。不过 MySQL的 Cluster 知道笔者写这部分内容的时候，仍然还是一个内存数据库的解决方案，也就是需要将所有数据包括索引全部都 Load 到内存中，这样就对内存的要求就非常大的大，对于一般的大众化应用来说可实施性并不是太大。MySQL 现在正在不断改进其 Cluster 的实现，其中非常大的一个改动就是允许数据不用全部 Load 到内存中，而仅仅只是索引全部 Load 到内存中，我想信在完成该项改造之后的 MySQL Cluster 将会更加受人欢迎，可实施性也会更大。</p>
<h3 id="5、Mysql的半同步模式（Semisynchronous-Replication）"><a href="#5、Mysql的半同步模式（Semisynchronous-Replication）" class="headerlink" title="5、Mysql的半同步模式（Semisynchronous Replication）"></a>5、Mysql的半同步模式（Semisynchronous Replication）</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们知道在5.5之前，MySQL的复制其实是异步操作，而不是同步，也就意味着允许主从之间的数据存在一定的延迟，mysql当初这样设计的目的可能也是基于可用性的考虑，为了保证master不受slave的影响，并且异步复制使得master处于一种性能最优的状态：写完binlog后即可提交而不需要等待slave的操作完成。这样存在一个隐患，当你使用slave作为备份时，如果master挂掉，那么会存在部分已提交的事务未能成功传输到slave的可能，这就意味着数据丢失！</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在MySQL5.5版本中，引入了半同步复制模式（Semi-synchronous Replication）能够成功（只是相对的）避免上述数据丢失的隐患。在这种模式下：master会等到binlog成功传送并写入至少一个slave的relay log之后才会提交，否则一直等待，直到timeout（默认10s）。当出现timeout的时候，master会自动切换半同步为异步，直到至少有一个slave成功收到并发送Acknowledge，master会再切换回半同步模式。结合这个新功能，我们可以做到，在允许损失一定的事务吞吐量的前提下来保证同步数据的绝对安全，因为当你设置timeout为一个足够大的值的情况下，任何提交的数据都会安全抵达slave。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mysql5.5 版本支持半同步复制功能（Semisynchronous Replication），但还不是原生的支持，是通过plugin来支持的，并且默认是没有安装这个插件的。不论是二进制发布的，还是自己源代码编译的，都会默认生成这个插件，一个是针对master 的一个是针对slave的，在使用之前需要先安装这俩plugins。</p>
<h2 id="二、Mysql主从复制的过滤"><a href="#二、Mysql主从复制的过滤" class="headerlink" title="二、Mysql主从复制的过滤"></a>二、Mysql主从复制的过滤</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;复制的过滤主要有２种方式：</p>
<ol>
<li>在主服务器在把事件从进二制日志中过滤掉，相关的参数是:binlog_do_db和binlog_ignore_db。</li>
<li>在从服务器上把事件从中继日志中过滤掉，相关的参数是replicate_*。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;复制只能扩展读取，不能扩展写入，对数据进行分区可以进行扩展写入。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;复制的优化：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在mysql复制环境中,有8个参数可以让我们控制,需要复制或需要忽略不进行复制的DB或table分别为:</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面二项需要在Master上设置：</p>
<ul>
<li>Binlog_Do_DB:设定哪些数据库需要记录Binlog</li>
<li>Binlog_Ignore_DB:设定哪里数据库不需要记录Binlog</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;优点是Master端的Binlog记录所带来的Io量减少，网络IO减少，还会让slave端的IO线程,SQL线程减少，从而大幅提高复制性能,</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;缺点是mysql判断是否需要复制某个事件不是根据产生该事件的查询所在的DB,而是根据执行查询时刻所在的默认数据库（也就是登录时指定的库名或运行”use database”中指定的DB）,只有当前默认DB和配置中所设定的DB完全吻合时IO线程才会将该事件读取给slave的IO线程.所以,如果在默认DB和设定须要复制的DB不一样的情况下改变了须要复制的DB中某个Table中的数据,该事件是不会被复制到Slave中去的,这样就会造成Slave端的数据和Master的数据不一致.同样,在默认的数据库下更改了不须要复制的数据库中的数据,则会被复制到slave端,当slave端并没有该数据库时,则会造成复制出错而停止。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面六项需要在slave上设置：</p>
<ul>
<li>Replicate_Do_DB:设定需要复制的数据库,多个DB用逗号分隔</li>
<li>Replicate_Ignore_DB:设定可以忽略的数据库.</li>
<li>Replicate_Do_Table:设定需要复制的Table</li>
<li>Replicate_Ignore_Table:设定可以忽略的Table</li>
<li>Replicate_Wild_Do_Table:功能同Replicate_Do_Table,但可以带通配符来进行设置。</li>
<li>Replicate_Wild_Ignore_Table:功能同Replicate_Do_Table,功能同Replicate_Ignore_Table,可以带通配符。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;优点是在slave端设置复制过滤机制,可以保证不会出现因为默认的数据库问题而造成Slave和Master数据不一致或复制出错的问题.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;缺点是性能方面比在Master端差一些.原因在于:不管是否须要复制,事件都会被IO线程读取到Slave端,这样不仅增加了网络IO量,也给Slave端的IO线程增加了Relay Log的写入量。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <strong>注：在实际的生产应用中发现，在mysql5.0以前的版本，mysql的这个过滤设置几乎是形同虚设，不起作用：不管你在主库或是从库上设置了忽略某个数据库或是表，他依然会进行同步，所以在做5.0以前版本的主从同步时，一定保持主从数据库的一致性，主上有的库或是表从上一定要有，否则在同步的过程会出错。</strong></p>
<h2 id="三、Mysql主从同步的配置"><a href="#三、Mysql主从同步的配置" class="headerlink" title="三、Mysql主从同步的配置"></a>三、Mysql主从同步的配置</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主库IP：192.168.1.2</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从库IP：192.168.1.3</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;添加一个用于主从同步的用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'%'</span> IDENTIFIED BY ‘1q2w3e4r’;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果监控mysql主从的话，请加上一个super权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRANT SUPER, REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;%&apos; IDENTIFIED BY &apos;1q2w3e4r&apos;;</div></pre></td></tr></table></figure>
<h3 id="1、主库的配置"><a href="#1、主库的配置" class="headerlink" title="1、主库的配置"></a>1、主库的配置</h3><h4 id="1-1．mysql5-0以下版本的配置"><a href="#1-1．mysql5-0以下版本的配置" class="headerlink" title="1.1．mysql5.0以下版本的配置"></a>1.1．mysql5.0以下版本的配置</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;修改主库mysql配置配置文件，在[mysqld]段添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server-id = 1</div><div class="line"><span class="built_in">log</span>-bin=/home/mysql/logs/binlog/bin-log</div><div class="line">max_binlog_size = 500M</div><div class="line">binlog_cache_size = 128K</div><div class="line">binlog-do-db = adb</div><div class="line">binlog-ignore-db = mysql</div><div class="line"><span class="built_in">log</span>-slave-updates</div></pre></td></tr></table></figure>
<h4 id="1-2-mysql5-0以上版本的配置"><a href="#1-2-mysql5-0以上版本的配置" class="headerlink" title="1.2. mysql5.0以上版本的配置"></a>1.2. mysql5.0以上版本的配置</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;修改主库mysql配置配置文件，在[mysqld]段添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server-id = 1</div><div class="line"><span class="built_in">log</span>-bin=/home/mysql/logs/binlog/bin-log</div><div class="line">max_binlog_size = 500M</div><div class="line">binlog_cache_size = 128K</div><div class="line">binlog-do-db = adb</div><div class="line">binlog-ignore-db = mysql</div><div class="line"><span class="built_in">log</span>-slave-updates</div><div class="line">expire_logs_day=2</div><div class="line">binlog_format=<span class="string">"MIXED"</span></div></pre></td></tr></table></figure>
<h4 id="1-3-各个参数的含义和相关注意项："><a href="#1-3-各个参数的含义和相关注意项：" class="headerlink" title="1.3.各个参数的含义和相关注意项："></a>1.3.各个参数的含义和相关注意项：</h4><ul>
<li>server-id = 1 #服务器标志号，注意在配置文件中不能出现多个这样的标识，如果出现多个的话mysql以第一个为准，一组主从中此标识号不能重复。</li>
<li>log-bin=/home/mysql/logs/binlog/bin-log #开启bin-log，并指定文件目录和文件名前缀。</li>
<li>max_binlog_size = 500M #每个bin-log最大大小，当此大小等于500M时会自动生成一个新的日志文件。一条记录不会写在2个日志文件中，所以有时日志文件会超过此大小。</li>
<li>binlog_cache_size = 128K #日志缓存大小</li>
<li>binlog-do-db = adb #需要同步的数据库名字，如果是多个，就以此格式在写一行即可。</li>
<li>binlog-ignore-db = mysql  #不需要同步的数据库名字，如果是多个，就以此格式在写一行即可。</li>
<li>log-slave-updates  #当Slave从Master数据库读取日志时更新新写入日志中，如果只启动log-bin 而没有启动log-slave-updates则Slave只记录针对自己数据库操作的更新。</li>
<li>expire_logs_day=2 #设置bin-log日志文件保存的天数，此参数mysql5.0以下版本不支持。</li>
<li>binlog_format=”MIXED”   #设置bin-log日志文件格式为：MIXED，可以防止主键重复。</li>
</ul>
<h3 id="2、从库的配置"><a href="#2、从库的配置" class="headerlink" title="2、从库的配置"></a>2、从库的配置</h3><h4 id="2-1-mysql5-1-7以前版本"><a href="#2-1-mysql5-1-7以前版本" class="headerlink" title="2.1.mysql5.1.7以前版本"></a>2.1.mysql5.1.7以前版本</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;修改从库mysql配置配置文件，在[mysqld]段添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">server-id=2</div><div class="line">master-host=192.168.1.2</div><div class="line">master-user=repl</div><div class="line">master-password=1q2w3e4r</div><div class="line">master-port=3306</div><div class="line">master-connect-retry=30</div><div class="line">slave-skip-errors=1062</div><div class="line">replicate-do-db = adb</div><div class="line">replicate-ignore-db = mysql</div><div class="line">slave-skip-errors=1007,1008,1053,1062,1213,1158,1159</div><div class="line">master-info-file = /home/mysql/logs/master.info</div><div class="line">relay-log = /home/mysql/logs/relay-bin</div><div class="line">relay-log-index = /home/mysql/logs/relay-bin.index</div><div class="line">relay-log-info-file = /home/mysql/logs/relay-log.info</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果修改了连接主库相关信息，重启之前一定要删除master.info文件，否则重启之后由于连接信息改变从库而不会自动连接主库，造成同步失败。此文件是保存连接主库信息的。</p>
<h4 id="2-2-mysql5-1-7以后版本"><a href="#2-2-mysql5-1-7以后版本" class="headerlink" title="2.2.mysql5.1.7以后版本"></a>2.2.mysql5.1.7以后版本</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql5.1.7版本在丛库上面的配置很少，主要是采用了新的同步信息记录方式，他不在支持在配置文件中配置连接主库的相关信息，而是把连接等相关信息记录在master-info-file = /home/mysql/logs/master.info文件中，如果入库变了，直接在mysql命令行执行连接信息的改变即可生效，比较灵活了，而不用去重启mysql。修改从库mysql配置配置文件，在[mysqld]段添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slave-skip-errors=1007,1008,1053,1062,1213,1158,1159</div></pre></td></tr></table></figure>
<h4 id="2-3-各个参数的含义和相关注意项"><a href="#2-3-各个参数的含义和相关注意项" class="headerlink" title="2.3.各个参数的含义和相关注意项"></a>2.3.各个参数的含义和相关注意项</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里只讲一下2个参数，其他全部是从库连接主库的信息和中间日志relay-log的设置。</p>
<ul>
<li>master-connect-retry=30 #这个选项控制重试间隔，默认为60秒。</li>
<li>slave-skip-errors=1007,1008,1053,1062,1213,1158,1159 #这个是在同步过程中忽略掉的错误，这些错误不会影响数据的完整性，有事经常出现的错误，一般设置忽略。其中1062为主键重复错误。</li>
</ul>
<h3 id="3、实现主从同步"><a href="#3、实现主从同步" class="headerlink" title="3、实现主从同步"></a>3、实现主从同步</h3><h4 id="3-1-实现数据库的统一"><a href="#3-1-实现数据库的统一" class="headerlink" title="3.1.实现数据库的统一"></a>3.1.实现数据库的统一</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;检查主从数据库的配置文件，查看是否已正确配置。首次实现 同步要备份主库上需要同步的数据库，然后完整的导入到从库中。注：mysql5.0之前的版本涉及到mysql本身复制过滤存在问题，需要把所有的数据库都备份导入到丛库，保持。</p>
<h4 id="3-2-查看并记录主库bin-log信息"><a href="#3-2-查看并记录主库bin-log信息" class="headerlink" title="3.2.查看并记录主库bin-log信息"></a>3.2.查看并记录主库bin-log信息</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进入主库mysql中，执行：show master status;显示信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show master status;</div><div class="line">+-------------+----------+--------------+------------------+</div><div class="line">| File        | Position | Binlog_do_db | Binlog_ignore_db |</div><div class="line">+-------------+----------+--------------+------------------+</div><div class="line">| bin-log.003 | 4        | adb          | mysql            |</div><div class="line">+-------------+----------+--------------+------------------+</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;记录File 和Position信息；</p>
<h4 id="3-3-在从库上执行同步语句"><a href="#3-3-在从库上执行同步语句" class="headerlink" title="3.3.在从库上执行同步语句"></a>3.3.在从库上执行同步语句</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进入mysql，执行以下语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slave stop;</div><div class="line">change master to</div><div class="line">master_host=<span class="string">'192.168.1.2'</span>,</div><div class="line">master_user=<span class="string">'repl'</span>,</div><div class="line">master_password=<span class="string">'1q2w3e4r'</span>,</div><div class="line">master_port=3306,</div><div class="line">master_log_file=<span class="string">'bin-log.003'</span>,</div><div class="line">master_log_pos=4;</div><div class="line">slave start;</div></pre></td></tr></table></figure>
<h4 id="3-4-查看主从同步状态"><a href="#3-4-查看主从同步状态" class="headerlink" title="3.4.查看主从同步状态"></a>3.4.查看主从同步状态</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进入mysql，执行show slave status\G;显示如下（mysql版本不同查询的结果不同，但是重要的指标还是一样的）：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql5.0之前的版本如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%BF%83%E5%BE%97%E6%95%B4%E7%90%86/01.jpeg?raw=true" alt=""> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql5.5之前的版本如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%BF%83%E5%BE%97%E6%95%B4%E7%90%86/02.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql5.5的版本如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%BF%83%E5%BE%97%E6%95%B4%E7%90%86/03.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;重要的指标为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: Yes</div><div class="line">Master_Log_File: bin-log.003</div><div class="line">Relay_Master_Log_File: bin-log.003</div><div class="line">Read_Master_Log_Pos: 4</div><div class="line">Exec_master_log_pos: 4</div><div class="line">Seconds_Behind_Master: 0（5.0之前版本没有这个选项）</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以上选项是两两对应的，只要结果是一致的，就说明主从同步成功。</p>
<h4 id="3-5-同步中的常见的错误和处理"><a href="#3-5-同步中的常见的错误和处理" class="headerlink" title="3.5.同步中的常见的错误和处理"></a>3.5.同步中的常见的错误和处理</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1、现象：在从库上面show slave status\G;出现下列情况，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: No</div><div class="line">Seconds_Behind_Master: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;原因：</p>
<ul>
<li>程序可能在slave上进行了写操作；</li>
<li>也可能是slave机器重起后，事务回滚造成的；</li>
<li>有可能是在同步过程中遇到某种错误，这个会在查看从库中状态时看到错误提示，最少见的就是主键重复1062的错误。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进入master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show master status;</div><div class="line">+----------------------+----------+--------------+------------------+</div><div class="line">| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB |</div><div class="line">+----------------------+----------+--------------+------------------+</div><div class="line">| mysql-bin.000040     | 324      |adb           | mysql            |</div><div class="line">+----------------------+----------+--------------+------------------+</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后到slave服务器上执行手动同步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">slave stop;</div><div class="line">change master to</div><div class="line">master_host=<span class="string">'10.14.0.140'</span>,</div><div class="line">master_user=<span class="string">'repl'</span>,</div><div class="line">master_password=<span class="string">'1q2w3e4r'</span>,</div><div class="line">master_port=3306,</div><div class="line">master_log_file=<span class="string">'mysql-bin.000040'</span>,</div><div class="line">master_log_pos=324;</div><div class="line">slave start;</div><div class="line">show slave status\G;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2、现象：从数据库无法同步，show slave status显示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: No</div><div class="line">Slave_SQL_Running: Yes</div><div class="line">Seconds_Behind_Master: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决：首先查看数据库的err日志，查看是什么错误提示，看从库连接主库的IP、用户、密码等相关信息是否有误，如果有误，重新执行同步；如果确认无误，重启主数据库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show master status;</div><div class="line">+------------------+----------+--------------+------------------+</div><div class="line">| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |</div><div class="line">+------------------+----------+--------------+------------------+</div><div class="line">| mysql-bin.000001 | 98 | adb| mysql|</div><div class="line">+------------------+----------+--------------+------------------+</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进入从库mysql，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">slave stop;</div><div class="line">change master to Master_Log_File=<span class="string">'mysql-bin.000001'</span>,Master_Log_Pos=98;</div><div class="line">slave start;</div><div class="line">或是这样：</div><div class="line">stop slave;</div><div class="line"><span class="built_in">set</span> global sql_slave_skip_counter =1;</div><div class="line">start slave;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个现象主要是master数据库存在问题，由于连接主库信息错误、主库数据库挂掉如果说常见错等原因引起的，我在实际的操作中先重启master后重启slave即可解决这问题，出现此问题，必须要要重启master数据库。</p>
<h2 id="四、mysql主主和主主集群"><a href="#四、mysql主主和主主集群" class="headerlink" title="四、mysql主主和主主集群"></a>四、mysql主主和主主集群</h2><h3 id="1、mysql主主的实现"><a href="#1、mysql主主的实现" class="headerlink" title="1、mysql主主的实现"></a>1、mysql主主的实现</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在实际的生产应用中，为了在主库出现崩溃或是主服务器出现严重故障时快速的恢复业务，会直接切换到从库上，当主库故障处理完成后让他直接作为丛库来运行，此时主主就是一个不错的选择。</p>
<h2 id="五、mysql主从的监控"><a href="#五、mysql主从的监控" class="headerlink" title="五、mysql主从的监控"></a>五、mysql主从的监控</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在mysql主从的应用中，只要进行了合理设置，基本上不会出现问题，但是对他的监控是必不可少的，以免由于真的出现问题又不知道而造成不必要的数据损失。</p>
<h3 id="1、mysql主从监控的主要思路"><a href="#1、mysql主从监控的主要思路" class="headerlink" title="1、mysql主从监控的主要思路"></a>1、mysql主从监控的主要思路</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql主从的监控，其主要是监控从库上的一些重要参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: Yes</div><div class="line">Master_Log_File: bin-log.003</div><div class="line">Relay_Master_Log_File: bin-log.003</div><div class="line">Read_Master_Log_Pos: 4</div><div class="line">Exec_master_log_pos: 4</div><div class="line">Seconds_Behind_Master: 0（5.0之前版本没有这个选项）</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过以上的参数可以反映出主库和从库状态是否正常，从库是否落后于主库等。值得一提的是在mysql5.0以前的版本，Slave_IO_Running这个状态指标不可靠，会在主库直接挂掉的情况下不会变成NO，Seconds_Behind_Master参数也不存在。监控以上参数即可监控mysql主从。</p>
<h3 id="2、mysql主从监控的实现"><a href="#2、mysql主从监控的实现" class="headerlink" title="2、mysql主从监控的实现"></a>2、mysql主从监控的实现</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不管mysql是那个版本，其中的从库上的Exec_master_log_pos、Exec_master_log_pos；主库上的 Master上的Log_File， Position，这四个参数可以判断出当前主从的状态。以下是适用于mysql所有版本的主从监控shell脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#/bin/sh</span></div><div class="line">user=repl</div><div class="line">passwd=123415</div><div class="line">master_ip=<span class="string">"192.168.1.2"</span></div><div class="line"><span class="built_in">log</span>=<span class="string">"/data3/check_repl.log"</span></div><div class="line">value()</div><div class="line">&#123;</div><div class="line"> master=`/usr/<span class="built_in">local</span>/mysql/bin/mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -h<span class="variable">$master_ip</span> -e <span class="string">"show master status\G;"</span>|egrep <span class="string">"File|Position"</span>`</div><div class="line"> <span class="comment">#mysql 4.0</span></div><div class="line"> slave=`/usr/<span class="built_in">local</span>/mysql/bin/mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -h127.0.0.1 -e <span class="string">"show slave status\G;"</span>|egrep <span class="string">"Relay_Master_Log_File|Exec_master_log_pos"</span>`</div><div class="line"> <span class="comment">#mysql 5.0</span></div><div class="line"> <span class="comment">#slave=`mysql -u$user -p$passwd -e "show slave status\G;"|egrep "Relay_Master_Log_File|Exec_Master_Log_Pos"`</span></div><div class="line"> <span class="comment">#取主库上的bin-log号及写入的当前日志位置   </span></div><div class="line"> Master_Log=`<span class="built_in">echo</span> <span class="variable">$master</span> |awk <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"."</span> <span class="string">'&#123;print $2&#125;'</span>`</div><div class="line"> Master_Log_Pos=`<span class="built_in">echo</span> <span class="variable">$master</span> |awk <span class="string">'&#123;print $4&#125;'</span>`</div><div class="line"> <span class="comment">#取从库上当前同步主库的位置</span></div><div class="line"> Relay_Master_Log_File=`<span class="built_in">echo</span> <span class="variable">$slave</span> |awk <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"."</span> <span class="string">'&#123;print $2&#125;'</span>`</div><div class="line"> Exec_Master_Log_Pos=`<span class="built_in">echo</span> <span class="variable">$slave</span> |awk <span class="string">'&#123;print $4&#125;'</span>`</div><div class="line"> <span class="built_in">echo</span> <span class="string">"Master_Log:"</span><span class="variable">$Master_Log</span>&gt;&gt;<span class="variable">$log</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"Master_Log_Pos:"</span><span class="variable">$Master_Log_Pos</span>&gt;&gt;<span class="variable">$log</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"Relay_Master_Log_File:"</span><span class="variable">$Relay_Master_Log_File</span>&gt;&gt;<span class="variable">$log</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"Exec_Master_Log_Pos:"</span><span class="variable">$Exec_Master_Log_Pos</span>&gt;&gt;<span class="variable">$log</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>((i=1;i&lt;=10;i++));</div><div class="line"><span class="keyword">do</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"#################################"</span>&gt;&gt;<span class="variable">$log</span></div><div class="line"> value</div><div class="line"> time=`date +<span class="string">"%Y-%m-%d %H:%M:%S"</span>`</div><div class="line"> <span class="keyword">if</span> [ <span class="variable">$Master_Log</span> -eq <span class="variable">$Relay_Master_Log_File</span> ];<span class="keyword">then</span></div><div class="line">       A=`expr <span class="variable">$Master_Log_Pos</span> - <span class="variable">$Exec_Master_Log_Pos</span>`</div><div class="line">       <span class="keyword">if</span> [ <span class="variable">$A</span> -lt 0 ];<span class="keyword">then</span></div><div class="line">             A=`expr 0 - <span class="variable">$A</span>`</div><div class="line">       <span class="keyword">fi</span></div><div class="line">       <span class="built_in">echo</span> <span class="variable">$A</span>&gt;&gt;<span class="variable">$log</span></div><div class="line">       <span class="keyword">if</span> [ <span class="variable">$A</span> -lt 10000 ];<span class="keyword">then</span></div><div class="line">             <span class="built_in">echo</span> <span class="string">"<span class="variable">$time</span> Master-Slave is OK."</span>&gt;&gt;<span class="variable">$log</span></div><div class="line">             <span class="comment">#echo "$i"</span></div><div class="line">             <span class="built_in">break</span></div><div class="line">       <span class="keyword">else</span></div><div class="line">             <span class="keyword">if</span> [ <span class="variable">$i</span> ge 3 ];<span class="keyword">then</span>              </div><div class="line">                  <span class="built_in">echo</span> <span class="string">"<span class="variable">$time</span> Warning:Slave-Master lag <span class="variable">$A</span> "</span> &gt;&gt;<span class="variable">$log</span></div><div class="line">                  <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></div><div class="line">             <span class="keyword">fi</span></div><div class="line">             sleep 30</div><div class="line">             <span class="built_in">continue</span></div><div class="line">       <span class="keyword">fi</span></div><div class="line"> <span class="keyword">else</span></div><div class="line">       sleep 60</div><div class="line">       <span class="keyword">fi</span></div><div class="line">       <span class="keyword">if</span> [ <span class="variable">$i</span> -eq 10 ];<span class="keyword">then</span></div><div class="line">             <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></div><div class="line">             <span class="built_in">echo</span> <span class="string">"<span class="variable">$time</span> Error:Slave-Master must be check !"</span> &gt;&gt;<span class="variable">$log</span></div><div class="line">       <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在mysql5.0以后的版本，mysql主从已经相当的成熟了，可以只监控Slave_IO_Running，Slave_SQL_Running，Seconds_Behind_Master状态就可以了，这里不再做说明。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/25. Mysql分库分表方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/25. Mysql分库分表方案/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.782Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/25. Mysql分库分表方案/">
        Mysql分库分表方案
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要分表："><a href="#为什么要分表：" class="headerlink" title="为什么要分表："></a>为什么要分表：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当一张表的数据达到几千万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。        </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。</p>
<h2 id="mysql-proxy：amoeba"><a href="#mysql-proxy：amoeba" class="headerlink" title="mysql proxy：amoeba"></a>mysql proxy：amoeba</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;做mysql集群,利用amoeba。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从上层的java程序来讲，不需要知道主服务器和从服务器的来源，即主从数据库服务器对于上层来讲是透明的。可以通过amoeba来配置。</p>
<h2 id="大数据量并且访问频繁的表，将其分为若干个表"><a href="#大数据量并且访问频繁的表，将其分为若干个表" class="headerlink" title="大数据量并且访问频繁的表，将其分为若干个表"></a>大数据量并且访问频繁的表，将其分为若干个表</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;比如对于某网站平台的数据库表-公司表，数据量很大，这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;某网站现在的数据量至多是5000万条，可以设计每张表容纳的数据量是500万条，也就是拆分成10张表，</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当&lt;500万条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作。</p>
<h2 id="利用merge存储引擎来实现分表"><a href="#利用merge存储引擎来实现分表" class="headerlink" title="利用merge存储引擎来实现分表"></a>利用merge存储引擎来实现分表</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了。用merge存储引擎来实现分表, 这种方法比较适合.<br>举例子：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/01.jpeg?raw=true" alt=""></p>
<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><h3 id="1、简单的MySQL主从复制"><a href="#1、简单的MySQL主从复制" class="headerlink" title="1、简单的MySQL主从复制:"></a>1、简单的MySQL主从复制:</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MySQL的主从复制解决了数据库的读写分离，并很好的提升了读的性能，其图如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/02.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其主从复制的过程如下图所示：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/03.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;但是，主从复制也带来其他一系列性能瓶颈问题：</p>
<ol>
<li>写入无法扩展</li>
<li>写入无法缓存</li>
<li>复制延时</li>
<li>锁表率上升</li>
<li>表变大，缓存率下降</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那问题产生总得解决的，这就产生下面的优化方案，一起来看看。</p>
<h3 id="2、MySQL垂直分区"><a href="#2、MySQL垂直分区" class="headerlink" title="2、MySQL垂直分区"></a>2、MySQL垂直分区</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果把业务切割得足够独立，那把不同业务的数据放到不同的数据库服务器将是一个不错的方案，而且万一其中一个业务崩溃了也不会影响其他业务的正常进行，并且也起到了负载分流的作用，大大提升了数据库的吞吐能力。经过垂直分区后的数据库架构图如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/04.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然而，尽管业务之间已经足够独立了，但是有些业务之间或多或少总会有点联系，如用户，基本上都会和每个业务相关联，况且这种分区方式，也不能解决单张表数据量暴涨的问题，因此为何不试试水平分割呢？</p>
<h3 id="3、MySQL水平分片（Sharding）"><a href="#3、MySQL水平分片（Sharding）" class="headerlink" title="3、MySQL水平分片（Sharding）"></a>3、MySQL水平分片（Sharding）</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是一个非常好的思路，将用户按一定规则（按id哈希）分组，并把该组用户的数据存储到一个数据库分片中，即一个sharding，这样随着用户数量的增加，只要简单地配置一台服务器即可，原理图如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/05.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如何来确定某个用户所在的shard呢，可以建一张用户和shard对应的数据表，每次请求先从这张表找用户的shard id，再从对应shard中查询相关数据，如下图所示：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/06.jpeg?raw=true" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MySQL/24. mysql主从同步问题集" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MySQL/24. mysql主从同步问题集/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.781Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MySQL/24. mysql主从同步问题集/">
        mysql 主从同步问题集
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在InnoDB引擎下发现，Mysql的主从热备存在数据不一致的问题，一些数据没有成功同步到备机。在use databases后，更新的表必须是当前选择的database才同步。譬如连上Mysql服务后操作： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USE test2; </div><div class="line">UPDATE client SET name=<span class="string">'test'</span> WHERE uid=1;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;数据未能同步到备机，而使用use  test后，才可以成功同步，如下方式： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USE <span class="built_in">test</span>; </div><div class="line">UPDATE client SET name=<span class="string">'test'</span> WHERE uid=1;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;仔细看Mysql手册，发现同步启动选项中还有玄机，只设置replicate-do-db指定同步数据库还不够，是没有设置replicate-wild-do-table导致的跨库同步问题。Mysql默认是同步指定数据库下的更新操作，若要跨库操作更新同步，就必须指定replicate-wild-do-table参数。下面是Mysql手册中对replicate-do-db和replicate-wild-do-table启动选项的说明： </p>
<blockquote>
<p>–replicate-do-db=db_name<br>告诉slave只同步那些缺省数据库是 db_name (也就是用 USE 选中的)的语句。想要指定更多的数据库，只需多次使用该选项，每次指定一个数据库。注意，类似 UPDATE some_db.some_table SET foo=’bar’ 这样的跨库操作语句以及没有选中数据库的操作都不会被同步。如果必须使用跨库操作，要确保使用MySQL 3.23.28或更高，并且使用 –replicate-wild-do-table=db_name.% 选项。请仔细阅读最后面的注意事项。 </p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面是一个不能按照预期工作的例子：如果启动slave时使用 –replicate-do-db=sales 选项，并且在master上执行下列语句，那么这个 UPDATE 语句不会被同步： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USE prices; </div><div class="line">UPDATE sales.january SET amount=amount+1000;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果需要同步跨库操作，只需使用 –replicate-wild-do-table=db_name.% 选项。这个”只检查缺省数据库”特性的主要原因是因为想要单从一个语句中判断是否要被同步比较困难(例如，使用多表 DELETE 或者 UPDATE，这就跨库了)。不过想要检查是否是缺省数据库却很快。 </p>
<blockquote>
<p>–replicate-wild-do-table=db_name.tbl<em>name<br>限制slave只同步那些匹配指定模式的数据表。模式中可以包含通配符 <code>%</code> 和 `</em>`，它们的含义和 LIKE 模式一样。想要指定更多的数据表，只需多次使用该选项，每次指定一个数据表。请仔细阅读最后面的注意事项。 </p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;例如： –replicate-wild-do-table=foo%.bar% 会同步所有以 foo 开头的数据库下的以 bar 开头的数据表上的更新操作。 如果匹配模式是 %，则匹配所有的表名，且应用到数据库级语句(CREATE DATABASE, DROP DATABASE,和 ALTER DATABASE)。例如，使用 –replicate-wild-do-table=foo%.% 选项的话，所有匹配 foo% 模式的数据库级操作都会被同步。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果想要在数据库/表模式中包含原义通配符，需要用反斜杠来转义它们。例如，想要同步 my<em>own%db 数据库下的所有表，但是不想同步 my1ownAABCdb 数据库下的表，就需要转义字符 `</em>`： –replicate-wild-do-table=my\_own\%db。如果是在命令行中使用这个选项，就可能需要两个反斜杠来转义，这依赖于命令行解释器。例如，在 bash shell下，就需要输入： –replicate-wild-do-table=my\\_own\\%db。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;还存在一些问题 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不管有没有replicate-wild-do-table选项，更新操作必须是mysql连接已经有选择的数据库了才进行，譬如新建的mysql(新连接是没有默认选择的database的)连接中执行： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UPDATE test.client SET name=<span class="string">'test'</span> WHERE uid=1;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这条更新无法同步到备机，必须在update前use database操作，该database必须是replicate-wild-do-table中指定的database。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保险的解决方式：连接上mysql后，调用mysql_select_db()选择数据库，之后进行的更新操作就可以自动同步了。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SQL模式匹配 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SQL的模式匹配允许你使用“_”匹配任何单个字符，而“%”匹配任意数目字符(包括零个字符)。在MySQL中，SQL的模式缺省是忽略大小写的。下面显示一些例子。注意在你使用SQL模式时，你不能使用=或!=；而使用LIKE或NOT LIKE比较操作符。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在my.cnf中設定master是錯誤的，你会发现在设置好重启后并没有按照之前的方式来运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">master-host            = 192.168.10.2 </div><div class="line">master-user            =  repl </div><div class="line">master-password = slavepass </div><div class="line">master-port            = 3306</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;请在mysql下执行底下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt;CHANGE MASTER TO </div><div class="line">MASTER_HOST=’192.168.10.2′, </div><div class="line">MASTER_USER=’repl’, </div><div class="line">MASTER_PASSWORD=’slavepass’;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查看主从服务状态的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show slave status\G </div><div class="line">mysql&gt; show master status\G </div><div class="line">mysql&gt; show master logs;</div></pre></td></tr></table></figure>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql主从复制碰到(server_errno=1236)解决过程 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;今天上论坛发现新发表的帖子无法正常显示(论坛数据库采用Mysql主从复制进行读写分离方案)，马上想到可能主从复制同步上出现问题，同一时间收到同事消息说数据库的主复制出现故障重启了，这时找到事故原因主数据库重启了会导致从数据库数据复制同步上延后，过一段时间SSH到从数据库上show slave status\G;查看状态显示 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Slave_IO_Running: NO </div><div class="line"> Slave_SQL_Running: Yes </div><div class="line">... </div><div class="line"> Last_Errno: 0 </div><div class="line"> Last_Error: </div><div class="line">... </div><div class="line">Seconds_Behind_Master: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从状态信息来看数据同步没有延后也没有报任何的错误，但Slave_IO_Running: NO显示同步IO进程失败。根据以往经验会先重启一下Slave后在show slave status\G;看一下是否会恢复正常，Slave_IO_Running: NO问题还是没有解决于是查看一下Mysql的错误日志发现： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">090605  9:13:20 [Note] Slave SQL thread initialized, starting replication <span class="keyword">in</span> <span class="built_in">log</span> ‘mysql-bin.000102′ at position 1029244974, relay <span class="built_in">log</span> ‘./xxx-relay-bin.000634′ position: 98 </div><div class="line">090605  9:13:20 [Note] Slave I/O thread: connected to master ’slave163@192.168.0.131:3306′,  replication started <span class="keyword">in</span> <span class="built_in">log</span> ‘mysql-bin.000102′ at position 1029244974 </div><div class="line">090605  9:13:20 [ERROR] Error reading packet from server: Client requested master to start replication from impossible position ( server_errno=1236) </div><div class="line">090605  9:13:20 [ERROR] Got fatal error 1236: ‘Client requested master to start replication from impossible position’ from master when reading data from binary <span class="built_in">log</span> </div><div class="line">090605  9:13:20 [Note] Slave I/O thread exiting, <span class="built_in">read</span> up to <span class="built_in">log</span> ‘mysql-bin.000102′, position 1029244974 </div><div class="line">090605  9:13:52 [Note] Error reading relay <span class="built_in">log</span> event: slave SQL thread was killed</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在网上查了很多资料可能因为mysql-bin.000102日志文件中并没有1029244974这个位置，vi打开mysql-bin.000102日志文件搜索1029244974确实没有搜到内容，但为什么主数据库意外的重启会导致Slave上读取位置的错误，记得以前主数据库也手动重启过，Slave上也没有出现过这种问题。解决方法是使用CHANGE MASTER TO命令就是让Slave跳过mysql-bin.000102日志文件1029244974这个位置直接到下一个日志文件： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SLAVE STOP; </div><div class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'mysql-bin.000103'</span>, MASTER_LOG_POS=0; </div><div class="line">SLAVE START;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;但是这样如果mysql-bin.000102日志文件的内容没有同步完会导致主数据库与从数据库的内容不一致，那何不把位置向前移呢。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SLAVE STOP; </div><div class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'mysql-bin.000102'</span>, MASTER_LOG_POS=1019244974; </div><div class="line">SLAVE START;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;于是试了一下，果然Slave_IO_Running: YES同步成功跳过了mysql-bin.000102日志文件1029244974这个位置并继续读取下一个位置，这样从数据库也不会丢失数据和主数据库保持数据的一致，如果my.cnf中没有加slave-skip-errors参数跳过一些错误的话，同步位置向前移会导致一些数据重新插入到表中报主键重复错误加上参数就可以成功跳过这些错误了。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;今天一台数据库的slave报 Slave_IO_Running: No的错误, 登陆上机器执行. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;slave stop; </div><div class="line">&gt;SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; </div><div class="line">&gt;slave start;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看看slave的状态, 依然是Slave_IO_Running: No </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看看mater错误日志, 发现有一段奇怪的日志如下: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Got timeout reading communication packets</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看看master的错误日志, 那就更奇怪了: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">090430 15:49:38 [Note] Slave I/O thread: connected to master <span class="string">'user@192.16.0.123:3306'</span>,replication started <span class="keyword">in</span> <span class="built_in">log</span> <span class="string">'xxx-bin.000815'</span> at position 3776386 </div><div class="line">090430 15:49:38 [ERROR] Error reading packet from server: Client requested master to start replication from impossible position ( server_errno=1236) </div><div class="line">090430 15:49:38 [ERROR] Got fatal error 1236: <span class="string">'Client requested master to start replication from impossible position'</span> from master when reading data from binary <span class="built_in">log</span> </div><div class="line">090430 15:49:38 [Note] Slave I/O thread exiting, <span class="built_in">read</span> up to <span class="built_in">log</span> <span class="string">'xxx-bin.000815'</span>, position 3776386</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可能是xxx-bin.000815这个文件有问题, 看了一下它的大小，果然没有3776386这个位置，slave读的时候肯定是错误了， 到底为什么会这样就不清楚了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决办法就是读取下一个bin-log了 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;slave stop; </div><div class="line">&gt;CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'xxx-bin.000816'</span>,MASTER_LOG_POS=0; </div><div class="line">&gt;slave start; </div><div class="line">&gt;show slave status\G;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可以看到Slave_IO_Running: Yes, 问题解决.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从库配置文件my2.ini </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">port=3307 </div><div class="line">datadir=”” </div><div class="line">server-id=2</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;启用从库日志，这样可以进行链式复制 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">log</span>-slave-updates</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从库是否只读，0表示可读写，1表示只读 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">read</span>-only=1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;只复制某个表 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-do-table=tablename</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;只复制某些表(可用匹配符) </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-wild-do-table=tablename%</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;只复制某个库 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-do-db=dbname</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;只复制某些库 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicte-wild-do-db=dbname%</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不复制某个表 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-ignore-table=tablename</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不复制某些表 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-wild-ignore-table=tablename%</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不复制某个库 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replicate-ignore-db=dbname</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;复制完的sql语句是否立即从中继日志中清除，1表示立即清除 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">relay-log-purge=1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从服务器主机，用于show slave hosts生成从库清单 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">report-host=hostname</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在从库的数据目录下，有几个和复制相关的文件需要说明一下： </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*-reloay-bin.* 从主库同步过来的Bin log文件，也叫中继日志 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;master.info 主库帐号信息和同步信息，这里记录了复制用户名和密码，需要保护好权限。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;relay-log.info 跟踪执行同步过来的Bin log的执行情况 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过show processlist可以查看主从库用于复制的相关进程(在windows上实际实现为线程)的信息 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show processlist\G </div><div class="line">mysql&gt; CHANGE MASTER TO </div><div class="line"> -&gt; MASTER_HOST=<span class="string">'master_host_name'</span>, </div><div class="line"> -&gt; MASTER_USER=<span class="string">'replication_user_name'</span>, </div><div class="line"> -&gt; MASTER_PASSWORD=<span class="string">'replication_password'</span>, </div><div class="line"> -&gt; MASTER_LOG_FILE=<span class="string">'recorded_log_file_name'</span>, </div><div class="line"> -&gt; MASTER_LOG_POS=recorded_log_position; </div><div class="line">```          </div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;注意：从服务器复制时，会在其数据目录中发现文件master.info和HOSTNAME-relay-log.info。状态文件保存在硬盘上，从服务器关闭时不会丢失。下次从服务器启动时，读取这些文件以确定它已经从主服务器读取了多少二进制日志，以及处理自己的中继日志的程度。不要移除或编辑这些文件，除非你确切知你正在做什么并完全理解其意义。即使这样，最好是使用CHANGE MASTER TO语句。 </span></div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;为了保证以后binglog及时写入，将主库sync_binlog变量设置1。 </span></div><div class="line"></div><div class="line">----</div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;MYSQL主从同步时出现”Client requested master to start replication from impossible position”错误的解决方法: </span></div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;这个错误是因为从服务器请求一个错误的位置而引起的.比如主服务器上的BLIN LOG里没有这个POSITION. </span></div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;解决原理: </span></div><div class="line"></div><div class="line">&amp;<span class="comment">#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;从相关的BIN LOG 里最后一个日志位置,与从服务器上的日志对比,如果LOG里最后位置比错误的位置大,那么,说明中间可能有断点,需要把从服务器的位置向前调,多试几次.如果在LOG里最后的位置比从服务器指出的位置还小,那么只要把从服务器的位置设置成LOG的最后位置就可以了. </span></div><div class="line"></div><div class="line">```bash</div><div class="line">mysqlbinlog mysql-log-bin.000112 &gt;log.sql </div><div class="line">tail -f log.sql </div><div class="line"><span class="comment"># at 568380594 </span></div><div class="line"><span class="comment">#110616  3:10:16 server id 1  end_log_pos 568380757     Query   thread_id=123899        exec_time=0     error_code=0 </span></div><div class="line">use thecheap_topshoppinguscom/*!*/; </div><div class="line">SET TIMESTAMP=1308226216/*!*/; </div><div class="line">DELETE FROM `thecheap_topshoppinguscom`.`zm_sessions` WHERE expiry &lt; 1308224416 </div><div class="line">/*!*/; </div><div class="line">DELIMITER ; </div><div class="line"><span class="comment"># End of log file </span></div><div class="line">ROLLBACK /* added by mysqlbinlog */; </div><div class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;发现这个位置比从服务器上的位置(568397810)还小,只要设置成最后位置,然后启动SLAVE就可以了. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CHANGE MASTER TO </div><div class="line">MASTER_LOG_FILE=’mysql-log-bin.000112′, </div><div class="line">MASTER_LOG_POS=568380594;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>–read-only选项<br>该选项让从服务器只允许来自从服务器线程或具有SUPER权限的用户的更新，可以确保从服务器不接受来自客户的更新。在测试过程中遇到了read-only的问题，发现写操作因为read-only这个选项的开启，而不能够成功执行。而通过带super权限的用户执行带修改性质的语句时，是能成功执行的。查找了下资料，才了解read-only的真正含义和用法：<br>–read_only  Make all non-temporary tables read-only, with the exception for replication (slave) threads and users with the SUPER privilege.</p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SUPER privilege : </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;The SUPER privilege enables an account to use CHANGE MASTER TO , KILL or mysqladmin kill to kill threads belonging to other accounts (you can always kill your own threads), PURGE BINARY LOGS , configuration changes using SET GLOBAL to modify global system variables, the mysqladmin debug command, enabling or disabling logging, performing updates even if the read_only system variable is enabled, starting and stopping replication on slave servers, specification of any account in the DEFINER attribute of stored programs and views, and enables you to connect (once) even if the connection limit controlled by the max_connections system variable is reached. </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;To create or alter stored routines if binary logging is enabled, you may also need the SUPER privilege, as described in Section 18.6, “Binary Logging of Stored Programs” . </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;read-only选项：对所有的非临时表进行只读控制。但是有两种情况例外： </p>
<ol>
<li>对replication threads例外，以保证slave能够正常的进行replication。 </li>
<li>对于拥有super权限的用户，可以ignore这个选项。 </li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SUPER 权限 ： </p>
<ol>
<li>可以有change master to, kill其他用户的线程的权限。 </li>
<li>Purge binary logs 来删除binary log, set global来动态设置变量的权限。 </li>
<li>执行mysqladmin debug命令，开启或者关闭log，在read-only打开时执行update/insert操作。 </li>
<li>执行start slave, stop slave. </li>
<li>当连接数已经达到max_connections的最大值时，也可以连接到server。 </li>
</ol>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mysql 主从同步状态不一致问题</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;方法一：是强制性从某一个点开始同步，会有部分没有同步的数据丢失，后续主服务器上删除记录同步也会有一些错误信息，不会影响使用。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;方法二：是设置’set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;’，但这样做不一定会有效果。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主从不能同步:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show slave status;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;报错:Error xxx dosn’t exist</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">show slave status\G:</div><div class="line">Slave_SQL_Running: NO</div><div class="line">Seconds_Behind_Master: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stop slave;</div><div class="line"><span class="built_in">set</span> global sql_slave_skip_counter =1 ;</div><div class="line">start slave;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;之后Slave会和Master去同步 主要看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: Yes</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Seconds_Behind_Master是否为0，0就是已经同步了</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;还需要做的一些优化与监视:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show full processlist; //查看mysql当前同步线程号</div><div class="line">skip-name-resolve       //跳过dns名称查询，有助于加快连接及同步的速度</div><div class="line">max_connections=1000    //增大Mysql的连接数目，(默认100)</div><div class="line">max_connect_errors=100 //增大Mysql的错误连接数目,(默认10)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查看日志一些命令</p>
<ol>
<li>show master status\G;<br>在这里主要是看log-bin的文件是否相同。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show slave status\G;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在这里主要是看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running=Yes</div><div class="line">Slave_SQL_Running=Yes</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果都是Yes,则说明配置成功.</p>
<ol>
<li>在master上输入show processlist\G;</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW PROCESSLIST\G</div><div class="line">*************************** 1. row ***************************</div><div class="line">Id: 2</div><div class="line">User: root</div><div class="line">Host: localhost:32923</div><div class="line">db: NULL</div><div class="line">Command: Binlog Dump</div><div class="line">Time: 94</div><div class="line">State: Has sent all binlog to slave; waiting <span class="keyword">for</span> binlog to be updated</div><div class="line">Info: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果出现Command: Binlog Dump,则说明配置成功.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">stop slave    <span class="comment">#停止同步</span></div><div class="line">start slave    <span class="comment">#开始同步，从日志终止的位置开始更新。</span></div><div class="line">SET SQL_LOG_BIN=0|1  <span class="comment">#主机端运行，需要super权限，用来开停日志，随意开停，会造成主机从机数据不一致，造成错误</span></div><div class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER=n  <span class="comment"># 客户端运行，用来跳过几个事件，只有当同步进程出现错误而停止的时候才可以执行。</span></div><div class="line">RESET MASTER  <span class="comment">#主机端运行,清除所有的日志，这条命令就是原来的FLUSH MASTER</span></div><div class="line">RESET SLAVE   <span class="comment">#从机运行，清除日志同步位置标志，并重新生成master.info</span></div><div class="line">虽然重新生成了master.info,但是并不起用，最好，将从机的mysql进程重启一下，</div><div class="line">LOAD TABLE tblname FROM MASTER <span class="comment">#从机运行，从主机端重读指定的表的数据，每次只能读取一个，受timeout时间限制，需要调整timeout时间。执行这个命令需要同步账号有 reload和super权限。以及对相应的库有select权限。如果表比较大，要增加net_read_timeout 和 net_write_timeout的值</span></div><div class="line">LOAD DATA FROM MASTER  <span class="comment">#从机执行，从主机端重新读入所有的数据。执行这个命令需要同步账号有reload和super权限。以及对相应的库有select权限。如果表比较大，要增加net_read_timeout 和 net_write_timeout的值</span></div><div class="line">CHANGE MASTER TO master_def_list  <span class="comment">#在线改变一些主机设置，多个用逗号间隔,比如</span></div><div class="line">CHANGE MASTER TO</div><div class="line">  MASTER_HOST=<span class="string">'master2.mysql.com'</span>,</div><div class="line">  MASTER_USER=<span class="string">'replication'</span>,</div><div class="line">  MASTER_PASSWORD=<span class="string">'password'</span></div><div class="line">MASTER_POS_WAIT() <span class="comment">#从机运行</span></div><div class="line">SHOW MASTER STATUS <span class="comment">#主机运行，看日志导出信息</span></div><div class="line">SHOW SLAVE HOSTS <span class="comment">#主机运行，看连入的从机的情况。</span></div><div class="line">SHOW SLAVE STATUS (slave)</div><div class="line">SHOW MASTER LOGS (master)</div><div class="line">SHOW BINLOG EVENTS [ IN <span class="string">'logname'</span> ] [ FROM pos ] [ LIMIT [offset,] rows ]</div><div class="line">PURGE [MASTER] LOGS TO <span class="string">'logname'</span> ; PURGE [MASTER] LOGS BEFORE <span class="string">'date'</span></div></pre></td></tr></table></figure>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;清理binlog日志文件</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;发现放数据库的分区磁盘激增了40多G，一路查看下来，发现配置好主从复制以来到现在的binlog就有40多G，原来根源出在这里，查看了一下 my.cnf，看到binlog的size是1G就做分割，但没有看到删除的配置，在mysql里show了一下variables，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like <span class="string">'%log%'</span>;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查到了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| expire_logs_days                | 0                                     |</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个默认是0，也就是logs不过期，这个是一个global的参数，所以需要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> global expire_logs_days=8;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样8天前的log就会被删除了，如果有回复的需要，请做好备份工作，但这样设置还不行，下次重启mysql了，配置又恢复默认了，所以需在my.cnf中设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expire_logs_days = 8</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;想要恢愎数据库以前的资料，执行：show binlog events;</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于数据量很多，查看起来很麻烦，所以应该适当删除部分可不用的日志。并且如果使用的时间足够长的话，会把我的硬盘空间都给吃掉。</p>
<ol>
<li>登录系统，/usr/bin/mysql</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用mysql查看日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show binary logs;</div><div class="line">+—————-+———–+</div><div class="line">| Log_name         | File_size |</div><div class="line">+—————-+———–+</div><div class="line">| mysql-bin.000001 | 150462942 |</div><div class="line">| mysql-bin.000002 | 120332942 |</div><div class="line">| mysql-bin.000003 | 141462942 |</div><div class="line">+—————-+———–+</div></pre></td></tr></table></figure>
<ol>
<li>删除bin-log(删除mysql-bin.000003之前的而没有包含mysql-bin.000003)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; purge binary logs to ‘mysql-bin.000003′;</div><div class="line"></div><div class="line">Query OK, 0 rows affected (0.16 sec)</div></pre></td></tr></table></figure>
<ol>
<li>查询结果(现在只有一条记录了.)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show binlog events\G</div><div class="line"></div><div class="line">mysql&gt; show binary logs;</div><div class="line">+—————-+———–+</div><div class="line">| Log_name       | File_size |</div><div class="line">+—————-+———–+</div><div class="line">| mysql-bin.000003 |       106 |</div><div class="line">+—————-+———–+</div><div class="line"></div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(删除的其它格式运用!)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘log_name’</div><div class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘date’</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用于删除列于在指定的日志或日期之前的日志索引中的所有二进制日志，这些日志也会从记录在日志索引文件中的清单中被删除，这样被给定的日志成为第一个。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PURGE MASTER LOGS TO ‘mysql-bin.010′;</div><div class="line">PURGE MASTER LOGS BEFORE ‘2008-06-22 13:00:00′;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;清除3天前的 binlog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PURGE MASTER LOGS BEFORE DATE_SUB( NOW( ), INTERVAL 3 DAY);</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BEFORE变量的date自变量可以为’YYYY-MM-DD hh:mm:ss’格式。MASTER和BINARY是同义词。如果您有一个活性的从属服务器，该服务器当前正在读取您正在试图删除的日志之一，则本语句不会起作用，而是会失败，并伴随一个错误。不过，如果从属服务器是休止的，并且您碰巧清理了其想要读取的日志之一，则从属服务器启动后不能复制。当从属服务器正在复制时，本语句可以安全运行。您不需要停止它们。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;要清理日志，需按照以下步骤：</p>
<ol>
<li>在每个从属服务器上，使用SHOW SLAVE STATUS来检查它正在读取哪个日志。</li>
<li>使用SHOW MASTER LOGS获得主服务器上的一系列日志。</li>
<li>在所有的从属服务器中判定最早的日志。这个是目标日志。如果所有的从属服务器是更新的，这是清单上的最后一个日志。</li>
<li>制作您将要删除的所有日志的备份。</li>
<li>清理所有的日志，但是不包括目标日志。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面讲一下怎么从二进制文件恢复数据, 假如不小心执行了drop table xxx_db, 假如你保留了完整的二进制日志的话, 先不要冒汗, 这是可以恢复的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先看看日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mysqlbinlog /diskb/bin-logs/xxx_db-bin.000001</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;找到执行create table xxx_db之后和drop table xxx_db之前的position, 假如是20, 1000.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mysqlbinlog --start-position=<span class="string">"4"</span> --stop-position=<span class="string">"1000"</span> /diskb/bin-logs/xxx_db-bin.000001 | mysql -u root</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;还有一种办法是根据日期来恢复</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mysqlbinlog --start-datetime=<span class="string">"2010-09-14 0:20:00"</span> --stop-datetim=<span class="string">"2010-09-15 01:25:00"</span> /diskb/bin-logs/xxx_db-bin.000001 | mysql -u root</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果相关的语句不在同一个binlog文件里，则需要从不同的文件来恢复。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果MySQL服务器上有多个要执行的二进制日志，安全的方法是在一个连接中处理它们。下面是一个说明什么是不安全的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell&gt; mysqlbinlog hostname-bin.000001 | mysql <span class="comment"># DANGER!!</span></div><div class="line">shell&gt; mysqlbinlog hostname-bin.000002 | mysql <span class="comment"># DANGER!!</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用与服务器的不同连接来处理二进制日志时，如果第1个日志文件包含一个CREATE TEMPORARY TABLE语句，第2个日志包含一个使用该临时表的语句，则会造成问题。当第1个mysql进程结束时，服务器撤销临时表。当第2个mysql进程想使用该表时，服务器报告 “不知道该表”。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;要想避免此类问题，使用一个连接来执行想要处理的所有二进制日志中的内容。下面提供了一种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shell&gt; mysqlbinlog hostname-bin.000001 hostname-bin.000002 | mysql</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shell&gt; mysqlbinlog hostname-bin.000001 &gt;  /tmp/statements.sql</div><div class="line">shell&gt; mysqlbinlog hostname-bin.000002 &gt;&gt; /tmp/statements.sql</div><div class="line">shell&gt; mysql -e <span class="string">"source /tmp/statements.sql"</span></div></pre></td></tr></table></figure>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mysql主从重新同步’binlog’日志</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;binlog中有一个位置(position)变量，可用于控制其工作进程。</p>
<ol>
<li>从’slave’在某个’position’之后停止同步</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">START SLAVE UNTIL MASTER_LOG_FILE=<span class="string">'xxxxx'</span>, MASTER_LOG_POS=yyyyyy;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：在执行前要确定从库的同步已停。</p>
<ol>
<li>重新从某一’position’后同步数据</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;笔者所碰到的一个现象：在一台繁忙的主库上，其传输过来的语句在从库没有完全得到执行，从而导致一分多钟的数据丢失(这么多年第一次碰到，事后通过分析binlog日志文件才发现，从库的状态居然是正常的)。<br>STOP SLAVE;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">change master to master_host=<span class="string">'master'</span>,master_user=<span class="string">'user'</span>,master_password=<span class="string">'passwd'</span>,master_log_file=<span class="string">'mysql-bin.file'</span>,master_log_pos=prev_position;</div><div class="line">START SLAVE;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样可以从出问题的时间点靠前一点的’position’开始重新同步’sql‘操作。但这样会报错，因为之前有数据存在了。诸如此类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last-Errno: 1062</div><div class="line">Last-Error: Error <span class="string">'Duplicate entry '</span>15386<span class="string">' for key 1'</span> on query. Default database: <span class="string">'db'</span>. Query: <span class="string">'INSERT INTO db.table ( FIELDS ) VALUES ( VALUES )'</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;键重复了，必须跳过才能继续。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop slave; <span class="built_in">set</span> global sql_slave_skip_counter=1; start slave;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或者在’my.cnf’文件中指定该错误跳过，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--slave-skip-errors=xxx,yyy</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;须重启服务器使其生效。常见问题及操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error: 1062 SQLSTATE: 23000 (ER_DUP_ENTRY) Message: Duplicate entry ‘%s’ <span class="keyword">for</span> key %d</div><div class="line"></div><div class="line">You can skip also other <span class="built_in">type</span> of errors, but again don’t <span class="keyword">do</span> this unless you understand very well what those queries are and what impact they have on your data:</div><div class="line"></div><div class="line">slave-skip-errors=[err_code1,err_code2,...|all]</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;报错相关的更多信息，请参考：<a href="http://dev.mysql.com/doc/refman/5.0/en/error-messages-server.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.0/en/error-messages-server.html</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：如果’xxx’为’all’的话，则表示跳过所有错误并继续，但这并不是个好的建议。这就很必要将从库设定为只读(read_only)且用非特权用户来访问它。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;官方文档有关于它的(replication-slave)更多参考：<a href="http://dev.mysql.com/doc/refman/5.0/en/replication-options-slave.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.0/en/replication-options-slave.html</a></p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q. No argument was provided to –log-bin, and –log-bin-index was not used; so replication may break when this MySQL server acts as a master and has his hostname changed!! Please use ‘–log-bin=mysql-bin’ to avoid this problem.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A: 在my.cnf 的[mysqld]中加入 log-bin=mysql-bin</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q. Neither –relay-log nor –relay-log-index were used; so replication may break when this MySQL server acts as a slave and has his hostname changed!! Please use ‘–relay-log=mysql-relay-bin’ to avoid this problem.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A: 在my.cnf 的[mysqld]中加入 relay-log=mysql-relay-bin</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q. [ERROR] The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different for replication to work (or the –replicate-same-server-id option must be used on slave but this does not always make sense; please check the manual before using it).</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A: 在my.cnf 的[mysqld]中加入 replicate-same-server-id</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q.[Note] Slave I/O thread: connected to master ‘test@:3306′,replication started in log ‘FIRST’ at position 4</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ERROR] Error reading packet from server: Access denied; you need the REPLICATION SLAVE privilege for this operation ( server_errno=1227)</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A: 可能原来使用过slave链接.需要将mysql库中的master.info删除重新</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q：如果主服务器正在运行并且不想停止主服务器，怎样配置一个从服务器？</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A：有多种方法。如果你在某时间点做过主服务器备份并且记录了相应快照的二进制日志名和偏移量(通过SHOW MASTER STATUS命令的输出)，采用下面的步骤： </p>
<ol>
<li>确保从服务器分配了一个唯一的服务器ID号。 </li>
<li>在从服务器上执行下面的语句，为每个选项填入适当的值： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CHANGE MASTER TO </div><div class="line"> -&gt;MASTER_HOST=<span class="string">'master_host_name'</span>, </div><div class="line"> -&gt;MASTER_USER=<span class="string">'master_user_name'</span>, </div><div class="line"> -&gt;MASTER_PASSWORD=<span class="string">'master_pass'</span>, </div><div class="line"> -&gt;MASTER_LOG_FILE=<span class="string">'recorded_log_file_name'</span>, </div><div class="line"> -&gt;MASTER_LOG_POS=recorded_log_position;</div></pre></td></tr></table></figure>
<ol>
<li>在从服务器上执行START SLAVE语句。 </li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果你没有备份主服务器，这里是一个创建备份的快速程序。所有步骤都应该在主服务器主机上执行。 </p>
<ol>
<li>发出该语句： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; FLUSH TABLES WITH READ LOCK；</div></pre></td></tr></table></figure>
<ol>
<li>仍然加锁时，执行该命令(或它的变体)： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shell&gt; tar zcf /tmp/backup.tar.gz /var/lib/mysql</div></pre></td></tr></table></figure>
<ol>
<li>发出该语句并且确保记录了以后用到的输出： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;SHOW MASTER STATUS；</div></pre></td></tr></table></figure>
<ol>
<li>释放锁： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; UNLOCK TABLES；</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一个可选择的方法是，转储主服务器的SQL来代替前面步骤中的二进制复制。要这样做，你可以在主服务器上使用mysqldump –master-data，以后装载SQL转储到到你的从服务器。然而，这比进行二进制复制速度慢。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不管你使用这两种方法中的那一个，当你有一个快照和记录了日志名与偏移量时，后来根据说明操作。你可以使用相同的快照建立多个从服务器。一旦你拥有主服务器的一个快照，可以等待创建一个从服务器，只要主服务器的二进制日志完整。两个能够等待的时间实际的限制是指在主服务器上保存二进制日志的可用硬盘空间和从服务器同步所用的时间。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;你也可以使用LOAD DATA FROM MASTER。这是一个方便的语句，它传输一个快照到从服务器并且立即调整日志名和偏移量。将来，LOAD DATA FROM MASTER将成为创建从服务器的推荐方法。然而需要注意，它只工作在MyISAM 表上并且可能长时间持有读锁定。它并不象我们希望的那样高效率地执行。如果你有大表，执行FLUSH TABLES WITH READ LOCK语句后，这时首选方法仍然是在主服务器上制作二进制快照。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q：从服务器需要始终连接到主服务器吗？</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A：不，不需要。从服务器可以宕机或断开连接几个小时甚至几天，重新连接后获得更新信息。例如，你可以在通过拨号的链接上设置主服务器/从服务器关系，其中只是偶尔短时间内进行连接。这意味着，在任何给定时间，从服务器不能保证与主服务器同步除非你执行某些特殊的方法。将来，我们将使用选项来阻塞主服务器直到有一个从服务器同步。</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;log-slave-updates #这个参数一定要加上，否则不会给更新的记录些到二进制文件里</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slave-skip-errors #是跳过错误，继续执行复制操作</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主服务器上的相关命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">show master status</div><div class="line">show slave hosts</div><div class="line">show logs</div><div class="line">show binlog events</div><div class="line">purge logs to <span class="string">'log_name'</span></div><div class="line">purge logs before <span class="string">'date'</span></div><div class="line">reset master(老版本flush master)</div><div class="line"><span class="built_in">set</span> sql_log_bin=</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从服务器上的相关命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">slave start</div><div class="line">slave stop</div><div class="line">SLAVE STOP IO_THREAD //此线程把master段的日志写到本地</div><div class="line">SLAVE start IO_THREAD</div><div class="line">SLAVE STOP SQL_THREAD //此线程把写到本地的日志应用于数据库</div><div class="line">SLAVE start SQL_THREAD</div><div class="line">reset slave</div><div class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER</div><div class="line">load data from master</div><div class="line">show slave status(SUPER,REPLICATION CLIENT)</div><div class="line">CHANGE MASTER TO MASTER_HOST=, MASTER_PORT=,MASTER_USER=, MASTER_PASSWORD= //动态改变master信息</div><div class="line">PURGE MASTER [before <span class="string">'date'</span>] 删除master端已同步过的日志</div><div class="line">6.3.1 Master 同步线程状态</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以下列出了master的 Binlog Dump 线程 State 字段中最常见的几种状态。如果在master上没有 Binlog Dump 线程，那么同步就没有在运行。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;也就是说，没有slave连接上来。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sending binlog event to slave</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;事件是由二进制日志构成，一个事件通常由更新语句加上其他信息。线程读取到一个事件并正发送到slave上。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Finished reading one binlog; switching to next binlog</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;读取完了一个二进制日志，正切换到下一个。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Has sent all binlog to slave; waiting for binlog to be updated</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;已经读取完全部未完成更新日志，并且全部都发送到slave了。它处于空闲状态，正等待在master上执行新的更新操作以在二进制日志中产生新<br>的事件，然后读取它们。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Waiting to finalize termination</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当前线程停止了，这个时间很短。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.3.2 Slave的I/O线程状态</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以下列出了slave的I/O线程 State 字段中最常见的几种状态。从MySQL 4.1.1开始，这个状态在执行 SHOW SLAVE STATUS 语句结果的</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Slave_IO_State 字段也会出现。这意味着可以只执行 SHOW SLAVE STATUS 语句就能了解到更多的信息。</p>
<p>Connecting to master</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;该线程证尝试连接到master上。</p>
<p>Checking master version</p>
<p>确定连接到master后出现的一个短暂的状态。</p>
<p>Registering slave on master</p>
<p>确定连接到master后出现的一个短暂的状态。</p>
<p>Requesting binlog dump</p>
<p>确定连接到master后出现的一个短暂的状态。该线程向master发送一个请求，告诉它要请求的二进制文件以及开始位置。</p>
<p>Waiting to reconnect after a failed binlog dump request</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果二进制日志转储(binary log dump)请求失败了(由于连接断开)，该线程在休眠时进入这个状态，并定期重连。重连的时间间隔由 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;–master-connect-retry 选项来指定。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Reconnecting after a failed binlog dump request</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;该线程正尝试重连到master。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting for master to send event</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;已经连接到master，正等待它发送二进制日志。如果master闲置时，这个状态可能会持续较长时间，如果它等待超过 slave_read_timeout 秒<br>，就会发生超时。这时，它就会考虑断开连接，然后尝试重连。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Queueing master event to the relay log</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;已经读取到一个事件，正把它拷贝到中继日志中以备SQL线程处理。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting to reconnect after a failed master event read</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;读日志时发生错误(由于连接断开)。该线程在重连之前休眠 master-connect-retry 秒。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Reconnecting after a failed master event read</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;正尝试重连到master。当连接确定后，状态就变成 Waiting for master to send event。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting for the slave SQL thread to free enough relay log space</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;relay_log_space_limit 的值非零，中继日志的大小总和超过这个值了。I/O线程等待SQL线程先处理中继日志然后删除它们以释放足够的空间<br>。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting for slave mutex on exit</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当前线程停止了，这个时间很短。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.3.3 Slave的SQL线程状态</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以下列出了slave的SQL线程 State 字段中最常见的几种状态：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Reading event from the relay log</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从中继日志里读到一个事件以备执行。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Has read all relay log; waiting for the slave I/O thread to update it</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;已经处理完中继日志中的全部事件了，正等待I/O线程写入更新的日志。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting for slave mutex on exit</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当前线程停止了，这个时间很短。</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常见的一些问题：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一.从库SLAVE启动问题</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于一些错误操作导致 CHANGE MASTER 和 SLAVE 服务无法启动，系统报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*****************************************************************</div><div class="line">Could not initialize master info structure; more error messages can be found <span class="keyword">in</span> the MySQL error <span class="built_in">log</span>.</div><div class="line">*****************************************************************</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;无法初始化master info结构，MySQL错误日志记录了更详细的错误信息。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法：</p>
<ol>
<li>查看MySQL错误日志，如：同步的上一个Position是多少，很多情况下无法启动服务是由于mysql识别的同步始终停留在上一个Position上。</li>
<li>查看master.info和relay-log.info，master.info 记录MASTER相关信息，relay-log.info 记录当前同步日志信息。</li>
<li>停止myslq服务，删除master.info和relay-log.info。</li>
<li>启动mysql服务。</li>
<li>重新CHANGE MASTER，重新启动SLAVE服务。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;二.主从不能同步</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;show slave status;报错:Error xxx dosn’t exist,且</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">show slave status\G:</div><div class="line">Slave_SQL_Running: NO</div><div class="line">Seconds_Behind_Master: NULL</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stop slave;</div><div class="line"><span class="built_in">set</span> global sql_slave_skip_counter =1 ;</div><div class="line">start slave;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;之后Slave会和Master去同步 主要看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running: Yes</div><div class="line">Slave_SQL_Running: Yes</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Seconds_Behind_Master是否为0，0就是已经同步了</p>
<ol>
<li>还需要做的一些优化与监视:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show full processlist; //查看mysql当前同步线程号</div><div class="line">skip-name-resolve       //跳过dns名称查询，有助于加快连接及同步的速度</div><div class="line">max_connections=1000    //增大Mysql的连接数目，(默认100)</div><div class="line">max_connect_errors=100 //增大Mysql的错误连接数目,(默认10)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查看日志一些命令</p>
<ol>
<li>show master status\G;</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在这里主要是看log-bin的文件是否相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show slave status\G;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在这里主要是看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Slave_IO_Running=Yes</div><div class="line">Slave_SQL_Running=Yes</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果都是Yes,则说明配置成功.</p>
<ol>
<li>在master上输入show processlist\G;</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW PROCESSLIST\G</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果出现Command: Binlog Dump,则说明配置成功.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">stop slave    <span class="comment">#停止同步</span></div><div class="line">start slave    <span class="comment">#开始同步，从日志终止的位置开始更新。</span></div><div class="line">SET SQL_LOG_BIN=0|1  <span class="comment">#主机端运行，需要super权限，用来开停日志，随意开停，会造成主机从机数据不一致，造成错误</span></div><div class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER=n  <span class="comment"># 客户端运行，用来跳过几个事件，只有当同步进程出现错误而停止的时候才可以执行。</span></div><div class="line">RESET MASTER  <span class="comment">#主机端运行,清除所有的日志，这条命令就是原来的FLUSH MASTER</span></div><div class="line">RESET SLAVE   <span class="comment">#从机运行，清除日志同步位置标志，并重新生成master.info</span></div><div class="line">虽然重新生成了master.info,但是并不起用，最好，将从机的mysql进程重启一下，</div><div class="line">LOAD TABLE tblname FROM MASTER <span class="comment">#从机运行，从主机端重读指定的表的数据，每次只能读取一个，受timeout时间限制，需要调整timeout时间。执行这个命令需要同步账号有 reload和super权限。以及对相应的库有select权限。如果表比较大，要增加net_read_timeout 和 net_write_timeout的值</span></div><div class="line">LOAD DATA FROM MASTER  <span class="comment">#从机执行，从主机端重新读入所有的数据。执行这个命令需要同步账号有reload和super权限。以及对相应的库有select权限。如果表比较大，要增加net_read_timeout 和 net_write_timeout的值</span></div><div class="line">CHANGE MASTER TO master_def_list  <span class="comment">#在线改变一些主机设置，多个用逗号间隔，比如：</span></div><div class="line">CHANGE MASTER TO</div><div class="line">MASTER_HOST=<span class="string">'master2.mycompany.com'</span>,</div><div class="line">MASTER_USER=<span class="string">'replication'</span>,</div><div class="line">MASTER_PASSWORD=<span class="string">'bigs3cret'</span></div><div class="line">MASTER_POS_WAIT() <span class="comment">#从机运行</span></div><div class="line">SHOW MASTER STATUS <span class="comment">#主机运行，看日志导出信息</span></div><div class="line">SHOW SLAVE HOSTS <span class="comment">#主机运行，看连入的从机的情况。</span></div><div class="line">SHOW SLAVE STATUS (slave)</div><div class="line">SHOW MASTER LOGS (master)</div><div class="line">SHOW BINLOG EVENTS [ IN <span class="string">'logname'</span> ] [ FROM pos ] [ LIMIT [offset,] rows ]</div><div class="line">PURGE [MASTER] LOGS TO <span class="string">'logname'</span> ; PURGE [MASTER] LOGS BEFORE <span class="string">'date'</span></div><div class="line">show binlog events; <span class="comment">#查看主库二进制日志文件内容：</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注意：</p>
<ol>
<li><p>主辅库同步主要是通过二进制日志来实现同步的。</p>
</li>
<li><p>在启动辅库的时候必须先把数据同步，并删除日志目录下的：master.info文件。因为master.info记录了上次要连接主库的信息，如果不删除，即使my.cnf里进行了修改，也不起作用，因为读取的还是master.info文件里的信息。</p>
</li>
</ol>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;补充：从服务器上my.cnf中的master-*的设置仅在第一次生效，后保存在master.info文件里。</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在从服务器上使用show slave status</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Slave_IO_Running,为No,则说明IO_THREAD没有启动，请执行slave start [IO_THREAD]</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Slave_SQL_Running为No则复制出错,查看Last_error字段排除错误后执行slave start [SQL_THREAD]</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查看Slave_IO_State字段</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;空 //复制没有启动</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Connecting to master//没有连接上master</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Waiting for master to send event//已经连上</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可以使用LOAD DATA FROM MASTER语句来建立slave，但有约束条件：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;数据表要全部是MyISAM表，必须有SUPER权限，master的复制用户必须具备RELOAD和SUPER权限。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在master端执行RESET MASTER清除已有的日志变更，此时slave端会因为找不到master日志无法启动IO_THREAD，请清空data目录下</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;relay-log.info,hosname-relay-bin*等文件重新启动mysql</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;中继日志文件默认的文件为hostname-relay-bin.nnn和hostname-relay-bin.index。可用从服务器的–</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;relay-log和–relay-log-index选项修改。在从服务器中还有一个relay-log.info中继信息文件，可用</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;–relay-log-info-file启动选项修改文件名。双机互备则是两个mysql同时配置为master及slave</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主服务器上的相关命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">show master status</div><div class="line">show slave hosts</div><div class="line">show &#123;master|binary&#125; logs</div><div class="line">show binlog events</div><div class="line">purge &#123;master|binary&#125; logs to <span class="string">'log_name'</span></div><div class="line">purge &#123;master|binary&#125; logs before <span class="string">'date'</span></div><div class="line">reset master(老版本flush master)</div><div class="line"><span class="built_in">set</span> sql_log_bin=&#123;0|1&#125;</div></pre></td></tr></table></figure>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从服务器上的相关命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">slave start</div><div class="line">slave stop</div><div class="line">SLAVE STOP IO_THREAD //此线程把master段的日志写到本地</div><div class="line">SLAVE start IO_THREAD</div><div class="line">SLAVE STOP SQL_THREAD //此线程把写到本地的日志应用于数据库</div><div class="line">SLAVE start SQL_THREAD</div><div class="line">reset slave</div><div class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER</div><div class="line">load data from master</div><div class="line">show slave status(SUPER,REPLICATION CLIENT)</div><div class="line">CHANGE MASTER TO MASTER_HOST=, MASTER_PORT=,MASTER_USER=, MASTER_PASSWORD= //动态改变master信息</div><div class="line">PURGE MASTER [before <span class="string">'date'</span>] 删除master端已同步过的日志</div></pre></td></tr></table></figure>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mysql的Relay Log无法自动删除</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;发现其数据目录下的relay-log 长期没有删除，已经堆积了几十个relay-log。然而其他作为Slave服务器实例却没有这种情况，综合分析后发现和以下原因有关。</p>
<ul>
<li>该实例原先是一个Slave   ——-导致relay-log 和 relay-log.index的存在</li>
<li>该实例目前已经不是Slave  ——-由于没有了IO-Thread，导致relay-log-purge 没有起作用( 这也是其他Slave实例没有这种情况的原因，因为IO-thread会做自动rotate操作)。</li>
<li>该实例每天会进行日常备份  ——-Flush logs的存在，导致每天会生成一个relay-log</li>
<li>该实例没有配置expire-logs-days ——导致flush logs时，也不会做relay-log清除</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;简而言之就是： 一个实例如果之前是Slave，而之后停用了(stop slave)，且没有配置expire-logs-days的情况下，会出现relay-log堆积的情况。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;顺带也和大家分享下MySQL内部Logrotate的机制</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Binary Log rotate机制：</p>
<ul>
<li>Rotate：每一条binary log写入完成后，都会判断当前文件是否超过 max_binlog_size，如果超过则自动生成一个binlog file。</li>
<li>Delete：expire-logs-days 只在 实例启动时 和 flush logs 时判断，如果文件访问时间早于设定值，则purge file。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Relay Log rotate 机制：</p>
<ul>
<li>Rotate：每从Master fetch一个events后，判断当前文件是否超过 max_relay_log_size 如果超过则自动生成一个新的relay-log-file。</li>
<li>Delete：purge-relay-log 在SQL Thread每执行完一个events时判断，如果该relay-log 已经不再需要则自动删除。</li>
<li>Delete：expire-logs-days 只在 实例启动时 和 flush logs 时判断，如果文件访问时间早于设定值，则purge file  (同Binlog file)  (注意: expire-logs-days和relaylog的purge没有关系)。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因此建议当slave不再使用时，通过reset slave来取消relaylog，以免出现relay-log堆积的情况。</p>
<hr>
<p>s&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lave的主从信息变更引起的错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">130311 14:15:46  mysqld started</div><div class="line">130311 14:15:46 [Warning] option <span class="string">'read_rnd_buffer_size'</span>: unsigned value 0 adjusted to 8200</div><div class="line">130311 14:15:47  InnoDB: Started; <span class="built_in">log</span> sequence number 15 2381115047</div><div class="line">130311 14:15:47 [ERROR] Failed to open the relay <span class="built_in">log</span> <span class="string">'./localhost-relay-bin.000037'</span> (relay_log_pos 52474065)</div><div class="line">130311 14:15:47 [ERROR] Could not find target <span class="built_in">log</span> during relay <span class="built_in">log</span> initialization</div><div class="line">130311 14:15:47 [ERROR] Failed to initialize the master info structure</div><div class="line">130311 14:15:47 [Note] /usr/<span class="built_in">local</span>/mysql/libexec/mysqld: ready <span class="keyword">for</span> connections.</div><div class="line">Version: <span class="string">'5.0.87-log'</span>  socket: <span class="string">'/var/tmp/mysql2.sock'</span>  port: 3308  Source distribution</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于新的slave改变了服务端口和文件路径，分析应该是由于mysql-relay-bin.index中仍然保存着旧relay日志文件的路径，而这些路径下又找不到合适的文件，因此报错。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于这类问题解决起来是比较简单的，重置slave的参照即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; reset slave;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div><div class="line"></div><div class="line">mysql&gt; change master to ....</div><div class="line">ERROR 29 (HY000): File <span class="string">'/data/mysqldata/3306/binlog/mysql-relay-bin.000001'</span> not found (Errcode: 2)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看来应该还是mysql-relay-bin.index的问题，删除该文件及关联的relay-bin文件。再次配置master：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; change master to ....</div><div class="line">ERROR 1201 (HY000): Could not initialize master info structure; more error messages can be found <span class="keyword">in</span> the MySQL error <span class="built_in">log</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;出现了新的错误，按照提示查看error_log也没发现更多错误信息，error_log中只是显示一条：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">120326 11:14:27 [ERROR] Error reading master configuration</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在操作系统端查看master/slave的配置文件，发现是两个0字节文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-rw-rw---- 1 mysql mysql     0 Mar 26 11:13 master.info</div><div class="line">-rw-rw---- 1 mysql mysql     0 Mar 26 11:13 relay-log.info</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;会不会是这个原因呢，直接删除这两个文件，然后尝试重新执行change master：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; change master to ....</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;成功，启动slave并查看状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; start slave;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; show slave status\G</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;故障解决。</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;磁盘故障</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Warning: a page <span class="keyword">in</span> the doublewrite buffer is not within space</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;出现此种报错，多为磁盘故障。</p>
<hr>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;master不能初始化</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ERROR 1201 (HY000): Could not initialize master解决方法 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; change master to master_host=<span class="string">'192.168.1.10'</span>,master_user=<span class="string">'replication'</span>,master_password=<span class="string">'123456'</span>,master_log_file=<span class="string">'freeoa_log.000003'</span>,master_log_pos=106;</div><div class="line"></div><div class="line">ERROR 1201 (HY000): Could not initialize master info structure; more error messages can be found <span class="keyword">in</span> the MySQL error <span class="built_in">log</span></div><div class="line"></div><div class="line">mysql&gt; slave stop;</div><div class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</div><div class="line">mysql&gt; reset slave;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;出现这个问题的原因，应该是以前mysql做过主从。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 失落的乐章
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: ,
		mathjax: ,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



  </div>
</body>
</html>