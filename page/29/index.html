<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>失落的乐章</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="失落的乐章的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="失落的乐章">
<meta property="og:url" content="https://hcldirgit.github.io/page/29/index.html">
<meta property="og:site_name" content="失落的乐章">
<meta property="og:description" content="失落的乐章的Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失落的乐章">
<meta name="twitter:description" content="失落的乐章的Blog">
  
    <link rel="alternative" href="/atom.xml" title="失落的乐章" type="application/atom+xml">
  
  
    <link rel="icon" href="https://github.com/hcldirgit/image/blob/master/0.png?raw=true">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">失落的乐章</a></h1>
		</hgroup>

		
		<p class="header-subtitle">技术面前，永远都是学生。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ansible/" style="font-size: 10.42px;">Ansible</a> <a href="/tags/Apache/" style="font-size: 18.33px;">Apache</a> <a href="/tags/Cacti/" style="font-size: 11.67px;">Cacti</a> <a href="/tags/DNS/" style="font-size: 13.33px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/FTP/" style="font-size: 11.25px;">FTP</a> <a href="/tags/Git/" style="font-size: 10.83px;">Git</a> <a href="/tags/HA集群/" style="font-size: 11.67px;">HA集群</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/Jenkins/" style="font-size: 10.42px;">Jenkins</a> <a href="/tags/LAMP/" style="font-size: 19.58px;">LAMP</a> <a href="/tags/LNMP/" style="font-size: 17.08px;">LNMP</a> <a href="/tags/LVS/" style="font-size: 16.67px;">LVS</a> <a href="/tags/Linux/" style="font-size: 19.17px;">Linux</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux安全/" style="font-size: 14.17px;">Linux安全</a> <a href="/tags/Memcached/" style="font-size: 11.25px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 15.42px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nagios/" style="font-size: 11.67px;">Nagios</a> <a href="/tags/Nginx/" style="font-size: 17.92px;">Nginx</a> <a href="/tags/OpenStack/" style="font-size: 11.25px;">OpenStack</a> <a href="/tags/Php/" style="font-size: 14.58px;">Php</a> <a href="/tags/Puppet/" style="font-size: 11.25px;">Puppet</a> <a href="/tags/Python/" style="font-size: 14.58px;">Python</a> <a href="/tags/Redis/" style="font-size: 16.25px;">Redis</a> <a href="/tags/Resin/" style="font-size: 10px;">Resin</a> <a href="/tags/Saltstack/" style="font-size: 10px;">Saltstack</a> <a href="/tags/Samba/" style="font-size: 12.08px;">Samba</a> <a href="/tags/Squid/" style="font-size: 14.58px;">Squid</a> <a href="/tags/Tomcat/" style="font-size: 13.75px;">Tomcat</a> <a href="/tags/Zabbix/" style="font-size: 15.83px;">Zabbix</a> <a href="/tags/haproxy/" style="font-size: 12.5px;">haproxy</a> <a href="/tags/keepalived/" style="font-size: 12.92px;">keepalived</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/shell练习/" style="font-size: 18.75px;">shell练习</a> <a href="/tags/正则表达式/" style="font-size: 12.92px;">正则表达式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">失落的乐章</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">失落的乐章</h1>
			</hgroup>
			
			<p class="header-subtitle">技术面前，永远都是学生。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-LVS/10. LVS原理详解及部署之三：手动部署LVS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/10. LVS原理详解及部署之三：手动部署LVS/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.033Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/10. LVS原理详解及部署之三：手动部署LVS/">
        LVS原理详解及部署之三：手动部署LVS
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、环境需求-amp-安装LVS软件"><a href="#一、环境需求-amp-安装LVS软件" class="headerlink" title="一、环境需求&amp;安装LVS软件"></a>一、环境需求&amp;安装LVS软件</h2><h3 id="环境准备：三台虚拟机"><a href="#环境准备：三台虚拟机" class="headerlink" title="环境准备：三台虚拟机"></a>环境准备：三台虚拟机</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;此环境是针对内部服务的LVS架构，如数据库，缓存，共享存储等业务。</p>
<table>
<thead>
<tr>
<th>虚拟机角色</th>
<th>IP地址</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LVS负载均衡器</td>
<td>192.168.41.181</td>
<td>VIP地址：192.168.40.17</td>
</tr>
<tr>
<td>http服务器</td>
<td>RS1192.168.41.31</td>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</td>
</tr>
<tr>
<td>http服务器</td>
<td>RS2192.168.41.33</td>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</td>
</tr>
</tbody>
</table>
<h3 id="安装LVS软件"><a href="#安装LVS软件" class="headerlink" title="安装LVS软件"></a>安装LVS软件</h3><ol>
<li><p>在安装LVS软件之前，先确定两条HTTPserver是能够正常访问的。</p>
</li>
<li><p>下载软件</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.24.tar.gz</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里使用的2.4版本，并且注意内核是2.6版本的，如果版本是6.X版本的话，那么可以使用2.6版本</p>
<ol>
<li>编译安装</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要创建一个软连接：ln -s /usr/src/kernels/<strong>2.6.18-238.el5-i686</strong> /usr/src/linux</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;此处粗体根据自己的系统来进行定义，可以使用tab键来补齐。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tar -zxf ipvsadm-1.24.tar.gz</div><div class="line"><span class="built_in">cd</span> ipvsadm-1.24</div><div class="line">make</div><div class="line">make install</div><div class="line">lsmod |grep ip_vs</div><div class="line">ipvsadm</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因为此时系统还没有把ipvs模块加载进系统，需要我们执行ipvsadm命令才会加载进去,或者modprobe ip_vs。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost ipvsadm-1.24]<span class="comment"># lsmod |grep ip_vs</span></div><div class="line">ip_vs_rr 6081 1</div><div class="line">ip_vs 78081 3 ip_vs_rr</div></pre></td></tr></table></figure>
<h2 id="二、手动配置LVS负载均衡器"><a href="#二、手动配置LVS负载均衡器" class="headerlink" title="二、手动配置LVS负载均衡器"></a>二、手动配置LVS负载均衡器</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;正常工作中是不会手动配置的，也不会使用脚本配置的。最终我们是通过配置文件生效的，结合keepalived来进行部署的。</p>
<ol>
<li>负载均衡器上配置VIP地址</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0:1 192.168.40.17 netmask 255.255.254.0</div><div class="line">route add -host 192.168.40.17  dev eth0</div></pre></td></tr></table></figure>
<ol>
<li>ipvsadm添加LVS服务</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>-A –add-service 添加一个带选项的虚拟服务。Add a virtual service. A serviceaddress is uniquely defined by a triplet: IP address, portnumber, and protocol. Alternatively a virtualservice may be defined by a firewall-mark.</td>
</tr>
<tr>
<td>-t</td>
<td>指定虚拟服务器的IP地址和端口</td>
</tr>
<tr>
<td>-s</td>
<td>-s,–scheduler scheduling-method 调度算法</td>
</tr>
<tr>
<td>-p</td>
<td>会话保持按秒计算</td>
</tr>
<tr>
<td>-a</td>
<td>-a在对应的VIP下添加RS节点</td>
</tr>
<tr>
<td>-g</td>
<td>指定此LVS的工作模式为-g -g为DR模式</td>
</tr>
<tr>
<td>-l</td>
<td>指定LVS的工作模式为-l -l为tunnel模式</td>
</tr>
<tr>
<td>-m</td>
<td>指定LVS的工作模式为NAT模式</td>
</tr>
<tr>
<td>-w</td>
<td>指定RS节点的权重</td>
</tr>
<tr>
<td>-D</td>
<td>删除虚拟服务.格式：ipvsadm-D -t</td>
<td>u</td>
<td>f service-address. Delete a virtual service, alongwith any associated real servers.</td>
</tr>
<tr>
<td>-C</td>
<td>-C, –clear Clear the virtual server table清空lvs原有的配置。</td>
</tr>
<tr>
<td>-set</td>
<td>设置tcp tcpfn udp 的连接超时时间（一般来说高并发的时候小一点点。</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ipvsadm  -C                                                <span class="comment">#请用LVS原有的配置</span></div><div class="line">ipvsadm -A -t 192.168.40.17:80 -s rr -p 20                 <span class="comment">#添加虚拟服务指定VIP</span></div><div class="line">ipvsadm -a -t 192.168.40.17:80 -r 192.168.41.31:80 -g -w 10<span class="comment">#针对虚拟服务添加RS节点</span></div><div class="line">ipvsadm -a -t 192.168.40.17:80 -r 192.168.41.33:80 -g -w 10</div><div class="line">ipvsadm -L -n                                              <span class="comment">#查看VIP和RS是否已经配置成功。</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># ipvsadm -L -n</span></div><div class="line">IP Virtual Server version 1.2.1 (size=4096)</div><div class="line">Prot LocalAddress:Port Scheduler Flags</div><div class="line"> -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn</div><div class="line">TCP 192.168.40.17:80 rr persistent 20</div><div class="line"> -&gt; 192.168.41.33:80 Route 10 0 0 </div><div class="line"> -&gt; 192.168.41.31:80 Route 10 0 0</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LB上删除虚拟服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipvsadm -D -t 192.168.40.17:80</div></pre></td></tr></table></figure>
<h2 id="三、RS节点服务器手动配置"><a href="#三、RS节点服务器手动配置" class="headerlink" title="三、RS节点服务器手动配置"></a>三、RS节点服务器手动配置</h2><ol>
<li>添加lo端口的VIP&amp;路由</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig lo 192.168.40.17 netmask 255.255.255.255</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(由于RS的VIP不是用来通讯，并且这里一定要设置24位掩码）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add -host 192.168.40.17  dev lo</div></pre></td></tr></table></figure>
<ol>
<li>ARP抑制</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_announce </div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_announce</div></pre></td></tr></table></figure>
<h2 id="四、测试LVS是否生效"><a href="#四、测试LVS是否生效" class="headerlink" title="四、测试LVS是否生效"></a>四、测试LVS是否生效</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在LB上面输入命令ipvsadm -L -n就能够查看LB上面的会话分配。在前面加上watch可以动态的查看ipvsadm的会话分配。watch ipvsadm -L -n.</p>
<ol>
<li>测试RS节点是否正常访问</li>
<li>测试从LB能否正常访问RS</li>
<li>测试客户端能否正常访问VIP</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在测试的时候可以先把防火墙关闭掉，一般按照这样配置就能够实现LVS的负载均衡了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;至此我们的LVS DR模式负载均衡已经配置完成了。至于不同的调度算法啊-s  不同的工作模式-g(DR) -l(TUNNEL) -m(NAT)服务器端基本上没有什么差别。只是在客户端上有一定的差别。</p>
<h3 id="NAT模式："><a href="#NAT模式：" class="headerlink" title="NAT模式："></a>NAT模式：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;客户端同样需要配置VIP，进行ARP抑制，并且要服务器端开启内核转发功能，配置LB的DIP(内网IP地址）作为默认网关。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开启内核转发功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl</div><div class="line"></div><div class="line">net.ipv4.ip_forword = 1</div><div class="line">route add default gw  192.168.41.181</div></pre></td></tr></table></figure>
<h3 id="Tunnel模式："><a href="#Tunnel模式：" class="headerlink" title="Tunnel模式："></a>Tunnel模式：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;客户端需要先开启Tunnel协议支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/sbin/modprobe ipip</div><div class="line">/sbin/route add –host 192.168.40.17 devtun1</div><div class="line"><span class="built_in">echo</span>”1”&gt;/proc/sys/net/ipv4/conf/tun1/arp-ignore</div><div class="line"><span class="built_in">echo</span>”2”&gt;/proc/sys/net/ipv4/conf/tun1/arp_announce</div><div class="line"><span class="built_in">echo</span>”0” &gt;/proc/sys/net/ipv4/conf/tun1/rp_filter</div><div class="line"><span class="built_in">echo</span>”1” &gt;/proc/sys/net/ipv4/conf/tun1/forwarding</div><div class="line"><span class="built_in">echo</span>”1” &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line"><span class="built_in">echo</span>”2” &gt;/proc/sys/net/ipv4/conf/all/ arp_announce</div></pre></td></tr></table></figure>
<h2 id="五、部署成功后的另一些问题"><a href="#五、部署成功后的另一些问题" class="headerlink" title="五、部署成功后的另一些问题"></a>五、部署成功后的另一些问题</h2><ol>
<li>当我们的RS节点出现问题，LB如何知道。如果不知道是会把会话连接接续转发到RS上面。</li>
<li>如果LB出现故障，那么整个网络就出现故障。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;针对上面的1问题，我们就需要一种RS节点健康检查机制。定时的去检测RS是否正常，如果出现不正常那么就把这个RS从VIP服务里面删除掉。如果恢复正常了，就再把RS添加进来。针对2问题，我们可以另外再架设一台LB服务器，作为备LB服务器。那么当主LB出现故障，备LB服务器就会启动接管主LB服务器的工作，接管它的资源（IP地址，在网络中的角色身份等）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;而上面提到的这些我们就需要结合keepalived来完成。所以后续我们开始讲keepalived+lvs结合适用。完成RS节点健康检查和LVS的高可用性功能。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/1. LVS 的 dr 模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/1. LVS 的 dr 模式/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.032Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/1. LVS 的 dr 模式/">
        LVS 的 dr 模式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84dr%E6%A8%A1%E5%BC%8F/01.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dr模式最稳定，用的最多的时候，当realserver处理完请求以后，直接返回给用户，避免lvs的瓶颈</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dr模式：调度器将请求来的数据包的目标mac地址改为real server的mac地址，返回的时候也不经过调度器，直接返回给客户端</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arp广播：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先了解arp广播：<strong>根据ip地址找mac地址</strong></p>
<blockquote>
<p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当主机A要与主机B通信时：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p>
<p><strong>整个请求过程如下：</strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;client在发起请求之前，会发一个arp广播的包，在网络中找“谁是vip”，由于所有的服务器，lvs和res都有vip，为了让client的请求送到lvs上，所以必须让res不能响应client发出的arp请求，（这也是为什么要禁止res上arp的请求和响应）下面就是lvs转发的事情了：</p>
<ol>
<li>client向目标vip发送请求，lvs接收；此时ip包和数据信息如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">src mac    	dst mac     	src_ip        		dst_ip</div><div class="line">     				192.168.147.1		192.168.147.150</div></pre></td></tr></table></figure>
<ol>
<li>lvs根据负载均衡的算法，选择一台realserver，然后把realserver1的mac地址作为目的mac地址，发送到局域网中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">src mac    	dst mac     	src_ip        			dst_ip 	</div><div class="line">                                192.168.147.1			192.168.147.150</div></pre></td></tr></table></figure>
<ol>
<li>realserver1在局域网中收到这个请求以后，发现目的ip和本地匹配，于是进行处理，处理完成以后，直接把源ip和目的ip直接对调，然后经过网关直接返回给用户；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">src mac    		dst mac    			 src_ip        			dst_ip 	</div><div class="line">                                                 	192.168.147.150		192.168.147.1</div><div class="line">```    </div><div class="line"></div><div class="line"><span class="comment">## 问题</span></div><div class="line"></div><div class="line">realserver如何抑制arp请求</div><div class="line"></div><div class="line">```bash</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/9. root账户不能使用密码只能使用密钥远程登陆" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/9. root账户不能使用密码只能使用密钥远程登陆/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.027Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/9. root账户不能使用密码只能使用密钥远程登陆/">
        root账户不能使用密码只能使用密钥远程登陆
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;打开sshd配置文件  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在最后面增加一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin without-password</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存配置文件后重启sshd服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/8. nginx限制只让某个ip访问" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/8. nginx限制只让某个ip访问/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.024Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/8. nginx限制只让某个ip访问/">
        nginx限制只让某个ip访问
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server </div><div class="line">&#123;</div><div class="line">    listen 80;</div><div class="line">    server_name www.aldjflas.cn;</div><div class="line">    access_log /home/logs/bbs/access.log combined buffer=32k;</div><div class="line">    error_log /home/logs/bbs/error.log warn;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /data/www/wwwroot/bbs;</div><div class="line">    allow 219.232.244.234;</div><div class="line">    deny all;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/7. nginx禁止某个IP或者IP段访问站点的设置方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/7. nginx禁止某个IP或者IP段访问站点的设置方法/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.023Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/7. nginx禁止某个IP或者IP段访问站点的设置方法/">
        nginx禁止某个IP或者IP段访问站点的设置方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先建立下面的配置文件放在nginx的conf目录下面,命名为deny.ip   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat deny.ip</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deny 192.168.1.11;</div><div class="line">deny 192.168.1.123;</div><div class="line">deny 10.0.1.0/24;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在nginx的配置文件nginx.conf中加入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include deny.ip;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;重启一下nginx的服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx reload</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;就可以生效了。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;deny.ip 的格式中也可以用deny all; </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果你想实现这样的应用，除了几个IP外，其他全部拒绝，</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那需要你在deny.ip 中这样写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">allow 1.1.1.1; </div><div class="line">allow 1.1.1.2;</div><div class="line">deny all;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/6. nginx 使用 user_agent 控制客户端访问" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/6. nginx 使用 user_agent 控制客户端访问/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.023Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/6. nginx 使用 user_agent 控制客户端访问/">
        nginx 使用 user_agent 控制客户端访问
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx的日志格式中，有一个字段叫做 $http_user_agent  这个其实是客户端浏览器的一个信息，比如咱们平时使用IE浏览器的话，nginx的日志中会记录类似于这样的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这一段信息就是 $http_user_agent 了。咱们可以根据这个特点来控制客户端的请求访问。比如，现在有这样一个需求</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;把使用IE 6.0 的客户端禁止访问，我们可以这样做：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在nignx的配置文件中，加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~ <span class="string">'MSIE 6.0'</span>)&#123;</div><div class="line">    <span class="built_in">return</span> 403;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样就能禁止使用IE 6.0的客户端访问服务器。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/5. nginx 禁止通过ip访问站点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/5. nginx 禁止通过ip访问站点/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.022Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/5. nginx 禁止通过ip访问站点/">
        nginx 禁止通过ip访问站点
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在server部分加如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80 default;</div><div class="line">    server_name suibian.com; <span class="comment">#这里的域名可以乱填一个</span></div><div class="line">    deny all;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/4. XSS攻击的防范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/4. XSS攻击的防范/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.021Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/4. XSS攻击的防范/">
        XSS攻击的防范
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;过滤”&lt;”和”&gt;”标记XSS跨站攻击的最终目标是引入script代码在用户的浏览器中执行，所以最基本最简单的过滤方法，就是转换”&lt;”和’&gt;”标记。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">replace(str, <span class="string">"&lt;"</span>, <span class="string">"&lt;"</span>)</div><div class="line">replace(str, <span class="string">"&gt;"</span>, <span class="string">"&gt;"</span>)</div></pre></td></tr></table></figure>
<h2 id="HTML属性过滤"><a href="#HTML属性过滤" class="headerlink" title="HTML属性过滤"></a>HTML属性过滤</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用上述的代码可以过滤掉”&lt;”和”&gt;”标记，让攻击者无法构造HTML标记。但是，攻击者可能会利用已存在的属性，如插入图片功能，将图片的路径属性修改为一段script代码，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"javascript:alert(/XSS攻击/)"</span> width=100&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上述代码执行后，同样可以实现跨站的目的。而且很多的HTML标记里属性都支持“javascript:跨站代码”的形式，因此就需要对攻击者输入的数据进行如下转换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">replace(str, <span class="string">"javascript:"</span>, <span class="string">""</span>)</div><div class="line">replace(str, <span class="string">"jscript:"</span>, <span class="string">""</span>)</div><div class="line">replace(str, <span class="string">"vbscript:"</span>, <span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一旦用户输入的语句中含有”javascript”，”jscript”，”vbscript”，都用空白代替。</p>
<h2 id="过滤特殊字符：-amp-、回车和空格"><a href="#过滤特殊字符：-amp-、回车和空格" class="headerlink" title="过滤特殊字符：&amp;、回车和空格"></a>过滤特殊字符：&amp;、回车和空格</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因为HTML属性的值，可支持”&amp;#ASCii”的形式进行表示，前面的跨站代码就可以换成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"javascript:alert(/XSS攻击/)"</span> width=100&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;即可突破过滤程序，继续进行跨站攻击，使用代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">replace(str, <span class="string">"&amp;"</span>, <span class="string">"&amp;"</span>)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上述代码将”&amp;”替换为了”&amp;”，于是后面的语句就变形失效了。但是还有其他的方式绕过过滤，因为过滤关键字的方式具有很多的漏洞。攻击者可以构造下面的攻击代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"javas cript:alert(/XSS攻击/)"</span> width=100&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里关键字被空格，准确的说是Tab键进行了拆分，上面的代码就又失效了，这样就有考虑将Tab空格过滤，防止此类的跨站攻击。</p>
<h2 id="HTML属性跨站的彻底防范"><a href="#HTML属性跨站的彻底防范" class="headerlink" title="HTML属性跨站的彻底防范"></a>HTML属性跨站的彻底防范</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;即使程序设计者彻底过滤了各种危险字符，确实给攻击者进行跨站入侵带来了麻烦，攻击者依然可以利用程序的缺陷进行攻击，因为攻击者可以利用前面说的属性和事件机制，构造执行script代码。例如，有下面这样一个图片标记代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"#"</span> onerror=alert(/跨站/)&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是一个利用onerror事件的典型跨站攻击示例，于是许多程序设计者对此事件进行了过滤，一旦发现关键字”onerror”，就进行转换过滤。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然而攻击者可以利用的时间跨站方法，并不只有onerror一种，各种各样的属性都可以进行构造跨站攻击。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"#"</span> style=<span class="string">"Xss:expression(alert(/跨站/));"</span>&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样的事件属性，同样是可以实现跨站攻击的。可以注意到，在“src=”#””和“style”之间有一个空格，也就是说属性之间需要空格分隔，于是程序设计者可能对空格进行过滤，以防范此类的攻击。但是过滤了空格之后，同样可以被攻击者突破。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"#"</span>/**/onerror=alert(/跨站/) width=100&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这段代码利用了脚本语言的规则漏洞，在脚本语言中的注释会被当成一个空白来表示。所以注释代码就简介的达到了空格的效果，使语句得以执行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/2. Linux可插拔认证模块（PAM）的配置文件、工作原理与流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/2. Linux可插拔认证模块（PAM）的配置文件、工作原理与流程/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.020Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/2. Linux可插拔认证模块（PAM）的配置文件、工作原理与流程/">
        Linux可插拔认证模块（PAM）的配置文件、工作原理与流程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PAM的配置文件：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们注意到，配置文件也放在了在应用接口层中，他与PAM API配合使用，从而达到了在应用中灵活插入所需鉴别模块的目的。他的作用主要是为应用选定具体的鉴别模块，模块间的组合以及规定模块的行为。下面是一个示例配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat /etc/pam.d/system-auth：</div><div class="line"><span class="comment">#%PAM-1.0</span></div><div class="line"><span class="comment"># This file is auto-generated.</span></div><div class="line"><span class="comment"># User changes will be destroyed the next time authconfig is run.</span></div><div class="line">auth required /lib/security/<span class="variable">$ISA</span>/pam_env.so</div><div class="line">auth sufficient /lib/security/<span class="variable">$ISA</span>/pam_unix.so likeauth nullok</div><div class="line">auth required /lib/security/<span class="variable">$ISA</span>/pam_deny.so</div><div class="line"> </div><div class="line">account required /lib/security/<span class="variable">$ISA</span>/pam_unix.so</div><div class="line">account sufficient /lib/security/<span class="variable">$ISA</span>/pam_succeed_if.so uid &lt; 100 quiet</div><div class="line">account required /lib/security/<span class="variable">$ISA</span>/pam_permit.so</div><div class="line"> </div><div class="line">password requisite /lib/security/<span class="variable">$ISA</span>/pam_cracklib.so retry=3</div><div class="line">password sufficient /lib/security/<span class="variable">$ISA</span>/pam_unix.so nullok use_authtok md5 shadow nis</div><div class="line">password required /lib/security/<span class="variable">$ISA</span>/pam_deny.so</div><div class="line"> </div><div class="line">session required /lib/security/<span class="variable">$ISA</span>/pam_limits.so</div><div class="line">session required /lib/security/<span class="variable">$ISA</span>/pam_unix.so</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们可以看到,配置文件有许多配置项(每行对应一个配置项)组成，每一行又分为四列(每列对应一栏)：</p>
<h2 id="第一栏-认证鉴别接口类型："><a href="#第一栏-认证鉴别接口类型：" class="headerlink" title="第一栏 认证鉴别接口类型："></a>第一栏 认证鉴别接口类型：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;指明程序所使用的PAM的认证接口类型，其实对应了刚才所说的四类接口：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auth：表示鉴别类接口模块类型用于检查用户和密码，并分配权限；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这种类型的模块为用户验证提供两方面服务。让应用程序提示用户输入密码或者其他标记，确认用户合法性；通过他的凭证许可权限，设定组成员关系或者其他优先权。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;account：表示账户类接口，主要负责账户合法性检查，确认帐号是否过期，是否有权限登录系统等；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这种模块执行的是基于非验证的帐号管理。他主要用于限制/允许用户对某个服务的访问时间，当前有效的系统资源（最多可以多少用户），限制用户位置（例如：root只能通过控制台登录）。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;多数情况下auth和account会一起用来对用户登录和使用服务的情况进行限制。这样的限制会更加完    整。比如下面是一个具体的例子：login是一个应用程序。Login要完成两件工作——首先查询用户，然后为用户提供所需的服务，例如提供一个shell程序。通常Login要求用户输入名称和密码进行验证。当用户名输入的时候，系统自然会去比对该用户是否是一个合法用户，是否在存在于本地或者远程的用户数据库中。如果该账号确实存在，那么是否过期。这些个工作是由account接口来负责。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果用户满足上述登录的前提条件，那么他是否具有可登录系统的口令，口令是否过期等。这个工作    就要由auth接口来负责了，他通常会将用户口令信息加密并提供给本地（/etc/shadow）或者远程的(ldap，kerberos等)口令验证方式进行验证。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果用户能够登录成功，证明auth和account的工作已经完成。但整个验证过程并没有完全结束。因为还有一些其他的问题没有得到确认。例如，用户能够在服务器上同时开启多少个窗口登录，用户可以在登录之后使用多少终端多长时间，用户能够访问哪些资源和不能访问哪些资源等等。也就是说登录之后的后续验证和环境定义等还需要其他的接口。这就是我们下面要提到的两组接口：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;session：会话类接口。实现从用户登录成功到退出的会话控制；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;处理为用户提供服务之前/后需要做的些事情。包括：开启/关闭交换数据的信息，监视目录等，设置用户会话环境等。也就是说这是在系统正式进行服务提供之前的最后一道关口。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;password：口令类接口。控制用户更改密码的全过程。也就是有些资料所说的升级用户验证标记。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注意，上述接口在使用的时候，每行只能指定一种接口类型，如果程序需要多种接口的话，可在多行中分别予以规定。</p>
<h2 id="第二栏-control-flag控制位："><a href="#第二栏-control-flag控制位：" class="headerlink" title="第二栏 control_flag控制位："></a>第二栏 control_flag控制位：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;规定如何处理PAM模块鉴别认证的结果，简而言之就是鉴别认证成功或者失败之后会发生什么事，如何进行控制。单个应用程序可以调用多种底层模块，通常称为“堆叠”。对应于某程序按照配置文件中出现顺序执行的所有模块成为“堆”，堆中的各模块的地位与出错时的处理方式由control_flag栏的取值决定，他的四种可能的取值分别为required、Requisite、sufficient或_optional：</p>
<ul>
<li><p>required：表示该行以及所涉及模块的成功是用户通过鉴别的必要条件。换句话说，只有当对应于应用程序的所有带 required标记的模块全部成功后，该程序才能通过鉴别。同时，如果任何带required标记的模块出现了错误，PAM并不立刻将错误消息返回给应用程序，而是在所有模块都调用完毕后才将错误消息返回调用他的程序。 反正说白了，就是必须将所有的模块都执行一次，其中任何一个模块验证出错，验证都会继续进行，并在执行完成之后才返回错误信息。这样做的目的就是不让用户知道自己被哪个模块拒绝，通过一种隐蔽的方式来保护系统服务。就像设置防火墙规则的时候将拒绝类的规则都设置为drop一样，以致于用户在访问网络不成功的时候无法准确判断到底是被拒绝还是目标网络不可达。</p>
</li>
<li><p>requisite：与required相仿，只有带此标记的模块返回成功后，用户才能通过鉴别。不同之处在于其一旦失败就不再执行堆中后面的其他模块，并且鉴别过程到此结束，同时也会立即返回错误信息。与上面的required相比，似乎要显得更光明正大一些。</p>
</li>
<li><p>sufficient：表示该行以及所涉及模块验证成功是用户通过鉴别的充分条件。也就是说只要标记为    sufficient的模块一旦验证成功，那么PAM便立即向应用程序返回成功结果而不必尝试任何其他模块。即便后面的层叠模块使用了requisite或者required控制标志也是一样。当标记为sufficient的模块失败时，sufficient模块会当做 optional对待。因此拥有sufficient 标志位的配置项在执行验证出错的时候并不会导致整个验证失败，但执行验证成功之时则大门敞开。所以该控制位的使用务必慎重。</p>
</li>
<li><p>optional：他表示即便该行所涉及的模块验证失败用户仍能通过认证。在PAM体系中，带有该标记的模块失败后将继续处理下一模块。也就是说即使本行指定的模块验证失败，也允许用户享受应用程序提供的服务。使用该标志，PAM框架会忽略这个模块产生的验证错误，继续顺序执行下一个层叠模块。</p>
</li>
<li><p>include：表示在验证过程中调用其他的PAM配置文件。在RHEL系统中有相当多的应用通过完整调用/etc/pam.d/system-auth来实现认证而不需要重新逐一去写配置项。这也就意味着在很多时候只要用户能够登录系统，针对绝大多数的应用程序也能同时通过认证。</p>
</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外还有一种比较复杂的格式为value = action的语法来设置控制标志，标志之间会以空格分开。格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value1 = action1 value2 = action2 ……</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中value可以是下列Linux PAM库的返回值：</p>
<blockquote>
<p>success、open_err、symbol_err、service_err、 system_err、buf_err、perm_denied、auth_err、cred_insufficient、authinfo_unavail、user_unknown、maxtries、new_authtok_reqd、acct_expired、 session_err、cred_unavail、cred_expired、cred_err、no_module_data、conv_err、 authtok_err、authtok_recover_err、authtok_lock_busy、authtok_disable_aging、 try_again、ignore、abort、authtok_expired、module_unknown、bad_item和default。</p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后一个(default)能够用来设置上面的返回值无法表达的行为。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;actionN可以是一个非负整数或者是下面的记号之一：ignore、ok、done、bad、die和reset。如果是非负整数J，就表示需要忽略后面J个同样类型的模块。通过这种方式，系统管理者可以更加灵活地设置层叠模块，模块的层叠路径由单个模块的反应决定。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于这几个记号的详细解释：</p>
<ul>
<li><p>ignore：如果使用层叠模块，那么这个模块的返回值将被忽略，不会被应用程序知道。</p>
</li>
<li><p>bad：他表示这个返回码应该被看作是模块验证失败的标志。如果这个模块是层叠模块的第一个验证失败的模块，那么他的状态值就是整个层叠模块验证的状态值和结果。</p>
</li>
<li><p>die：终止层叠模块验证过程，立刻返回到应用程序。</p>
</li>
<li><p>ok：告诉PAM这个模块的返回值将直接作为所有层叠模块的返回值。也就是说，如果这个模块前面的模块返回状态是PAM_SUCCESS，那这个返回值就会覆盖前面的返回状态。注意：如果前面的模块的返回状态表示模块验证失败，那么不能使用这个返回值再加以覆盖。</p>
</li>
<li><p>done：终止后续层叠模块的验证，把控制权立刻交回应用程序。</p>
</li>
<li><p>reset：清除所有层叠模块的返回状态，从下一个层叠模块重新开始验证。</p>
</li>
</ul>
<h2 id="第三栏-module-path即所使用模块的全路径名称。"><a href="#第三栏-module-path即所使用模块的全路径名称。" class="headerlink" title="第三栏 module_path即所使用模块的全路径名称。"></a>第三栏 module_path即所使用模块的全路径名称。</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以Red Hat Enterprise Linux（RHEL）为例，值得注意的是在i368/i686和x86_64系统中模块的全路径名称是不一样的。所以当有的时候用户将一些PAM的配置文件从原来系统复制到新的系统时，如果两种系统架构不同，那么不修改模块路径名称则可能导致PAM报错。</p>
<h2 id="第四栏-options用于向特定模块传递相关的选项，然后由模块分析解释这些选项。"><a href="#第四栏-options用于向特定模块传递相关的选项，然后由模块分析解释这些选项。" class="headerlink" title="第四栏 options用于向特定模块传递相关的选项，然后由模块分析解释这些选项。"></a>第四栏 options用于向特定模块传递相关的选项，然后由模块分析解释这些选项。</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;比如使用此栏打开模块调试模式，或向某模块传递诸如超时值之类的参数等。另外他还用于支持下文所述的口令映射技术。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果任一栏出现错误或某模块没有找到，那么所在行被忽略并将其作为严重错误进行记录。</p>
<h2 id="PAM的工作原理与流程："><a href="#PAM的工作原理与流程：" class="headerlink" title="PAM的工作原理与流程："></a>PAM的工作原理与流程：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以RHEL系统为例，当pam安装之后有两大部分：在/lib/security目录下的各种pam模块以    及/etc/pam.d和/etc/pam.d目录下的针对各种服务和应用已经定义好的pam配置文件。当某一个有认证需求的应用程序需要验证的时候，一般在应用程序中就会定义负责对其认证的PAM配置文件。以    vsftpd为例，在它的配置文件/etc/vsftpd/vsftpd.conf中就有这样一行定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pam_service_name=vsftpd</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;表示登录FTP服务器的时候进行认证是根据/etc/pam.d/vsftpd文件定义的内容进行。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那么，当程序需要认证的时候已经找到相关的pam配置文件，认证过程是如何进行的？下面我们将通过解读/etc/pam.d/system-auth文件予以说明。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先要声明一点的是：system-auth是一个非常重要的pam配置文件，主要负责用户登录系统的认证工作。而且该文件不仅仅只是负责用户登录系统认证，其它的程序和服务通过include接口也可以调用到它，从而节省了很多重新自定义配置的工作。所以应该说该文件是系统安全的总开关和核心的pam配置文件。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面是/etc/pam.d/system-auth文件的全部内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">grep -v ^<span class="comment"># /etc/pam.d/system-auth</span></div><div class="line">auth required pam_env.so</div><div class="line">auth sufficient pam_unix.so nullok try_first_pass</div><div class="line">auth requisite pam_succeed_if.so uid &gt;= 500 quiet</div><div class="line">auth required pam_deny.so</div><div class="line">  </div><div class="line">account required pam_unix.so</div><div class="line">account sufficient pam_succeed_if.so uid &lt; 500 quiet</div><div class="line">account required pam_permit.so</div><div class="line">  </div><div class="line">password requisite pam_cracklib.so try_first_pass retry=3</div><div class="line">password sufficient pam_unix.so md5 shadow nullok try_first_pass use_authtok</div><div class="line">password required pam_deny.so</div><div class="line">  </div><div class="line">session optional pam_keyinit.so revoke</div><div class="line">session required pam_limits.so</div><div class="line">session [success=1 default=ignore] pam_succeed_if.so service <span class="keyword">in</span> crond quiet use_uid</div><div class="line">session required pam_unix.so</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第一部分表示，当用户登录的时候，首先会通过auth类接口对用户身份进行识别和密码认证。所以在该过程中验证会经过几个带auth的配置项。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中的第一步是通过pam_env.so模块来定义用户登录之后的环境变量， pam_env.so允许设置和更改用户登录时候的环境变量，默认情况下，若没有特别指定配置文件，将依    据/etc/security/pam_env.conf进行用户登录之后环境变量的设置。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后通过pam_unix.so模块来提示用户输入密码，并将用户密码与/etc/shadow中记录的密码信息进行对比，如果密码比对结果正确则允许用户登录，而且该配置项的使用的是“sufficient”控制位，即表示只要该配置项的验证通过，用户即可完全通过认证而不用再去走下面的认证项。不过在特殊情况下，用户允许使用空密码登录系统，例如当将某个用户在/etc/shadow中的密码字段删除之后，该用户可以只输入用户名直接登录系统。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面的配置项中，通过pam_succeed_if.so对用户的登录条件做一些限制，表示允许uid大于500的用户在通过密码验证的情况下登录，在Linux系统中，一般系统用户的uid都在500之内，所以该项即表示允许使用useradd命令以及默认选项建立的普通用户直接由本地控制台登录系统。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后通过pam_deny.so模块对所有不满足上述任意条件的登录请求直接拒绝，pam_deny.so是一个特殊的模块，该模块返回值永远为否，类似于大多数安全机制的配置准则，在所有认证规则走完之后，对不匹配任何规则的请求直接拒绝。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第二部分的三个配置项主要表示通过account账户类接口来识别账户的合法性以及登录权限。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第一行仍然使用pam_unix.so模块来声明用户需要通过密码认证。第二行承认了系统中uid小于500的系统用户的合法性。之后对所有类型的用户登录请求都开放控制台。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第三部分会通过password口另类接口来确认用户使用的密码或者口令的合法性。第一行配置项表示需要的情况下将调用pam_cracklib来验证用户密码复杂度。如果用户输入密码不满足复杂度要求或者密码错，最多将在三次这种错误之后直接返回密码错误的提示，否则期间任何一次正确的密码验证都允许登录。需要指出的是，pam_cracklib.so是一个常用的控制密码复杂度的pam模块，关于其用法举例我们会在之后详细介绍。之后带pam_unix.so和pam_deny.so的两行配置项的意思与之前类似。都表示需要通过密码认证并对不符合上述任何配置项要求的登录请求直接予以拒绝。不过用户如果执行的操作是单纯的登录，则这部分配置是不起作用的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第四部分主要将通过session会话类接口为用户初始化会话连接。其中几个比较重要的地方包括，使用pam_keyinit.so表示当用户登录的时候为其建立相应的密钥环，并在用户登出的时候予以撤销。不过该行配置的控制位使用的是optional，表示这并非必要条件。之后通过pam_limits.so限制用户登录时的会话连接资源，相关pam_limit.so配置文件是/etc/security/limits.conf，默认情况下对每个登录用户都没有限制。关于该模块的配置方法在后面也会详细介绍。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可见，不同应用程序通过配置文件在认证过程中调用不同的pam模块来定制具体的认证流程。其中我们不难看出，其实可以根据实际的需要对pam的配置文件进行修改以满足不同的认证需求，例如下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#%PAM-1.0</span></div><div class="line"><span class="comment"># This file is auto-generated.</span></div><div class="line"><span class="comment"># User changes will be destroyed the next time authconfig is run.</span></div><div class="line">auth required pam_env.so</div><div class="line">auth required pam_tally.so onerr=fail deny=5</div><div class="line">auth sufficient pam_unix.so nullok try_first_pass</div><div class="line">auth requisite pam_succeed_if.so uid &gt;= 500 quiet</div><div class="line">auth required pam_deny.so</div><div class="line"> </div><div class="line">account required pam_unix.so</div><div class="line">account sufficient pam_succeed_if.so uid &lt; 500 quiet</div><div class="line">account required pam_permit.so</div><div class="line"> </div><div class="line">password requisite pam_cracklib.so try_first_pass retry=3 minlen=10 lcredit=-1 ucredit=-1 dcredit=-1 ocredit=-1 difok=6</div><div class="line">password requisite pam_passwdqc.so use_first_pass enforce=everyone</div><div class="line">password sufficient pam_unix.so md5 remember=6 shadow nullok try_first_pass use_authtok</div><div class="line">password required pam_deny.so</div><div class="line"> </div><div class="line">session optional pam_keyinit.so revoke</div><div class="line">session required pam_limits.so</div><div class="line">session [success=1 default=ignore] pam_succeed_if.so service <span class="keyword">in</span> crond quiet use_uid</div><div class="line">session required pam_unix.so</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在其中就增加了对用户密码修改时复杂度的限制，用户多次错误输入密码之后的锁定限制以及用户使用密码历史等限制选项。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;所以我们通过对上述system-auth配置文件的修改，模块的增加和选项的变化，从很大的程度上增加了用户登录验证的安全性要求。我们会在之后的文章中对该配置进行详细说明。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外也一定需要注意，在整个的PAM配置文件当中，配置项以及模块调用的逻辑顺序非常关键。因为PAM是按照配置项的先后顺序来进行验证。错误的模块调用顺序很可能导致严重的安全问题甚至系统错误。所以对PAM配置进行修改的时候务必要考虑这一点。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Linux安全/3. Web 应用程序常见漏洞 CSRF 的入侵检测与防范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Linux安全/3. Web 应用程序常见漏洞 CSRF 的入侵检测与防范/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.020Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Linux安全/3. Web 应用程序常见漏洞 CSRF 的入侵检测与防范/">
        Web 应用程序常见漏洞 CSRF 的入侵检测与防范
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;互联网的安全问题一直存在，并且在可预见的未来中没有消弭的迹象，而在软件开发周期中，加入对产品安全问题的检测工作，将极大的提升对应安全问题解决的成本，对维护一个好的产品形象至关重，在竞争愈烈的网络应用产品中的生命力也将更长。本文要介绍的跨站请求伪（CSRF）在众多的攻击手段中，更具备隐蔽性，同时有更高的危害性。笔者将对其的基本特性，攻击手段，危害及防范手段，以及如何使用 Rational AppScan 对 CSRF 攻击做检测及分析做一个系统的阐述。</p>
<h2 id="CSRF-的基本概念特性"><a href="#CSRF-的基本概念特性" class="headerlink" title="CSRF 的基本概念特性"></a>CSRF 的基本概念特性</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;跨站请求伪造（CSRF）的是 Web 应用程序一种常见的漏洞，其攻击特性是危害性大但非常隐蔽，尤其是在大量 Web 2.0 技术的应用的背景下，CSRF 攻击完全可以在用户法毫无察觉的情况下发起攻击。国际上并未对 CSRF 攻击做出一个明确的定义，同时，攻击的发起手段方式繁多，下文会做详细介绍。可以解释的是发起的目标都是通过伪造一个用户请求，该请求不是用户想发出去的请求，而对服务器或服务来说这个请求是完全合法的一个请求，但是却完成了一个攻击者所期望的操作，比如添加一个用户到管理者的群组中，或将一个用户的现金转到另外的一个帐户中。通常开发人员对 CSRF 攻击的理解是有误区的，分为以下几方面，第一是如何攻击的，第二是危害到底在那里，第三是如何防范就才是一个完整的解决方案。本文就是要对这些基本的问题做一个详细的阐述，并且给出检测的有效方法。</p>
<h2 id="CSRF-的危害实例"><a href="#CSRF-的危害实例" class="headerlink" title="CSRF 的危害实例"></a>CSRF 的危害实例</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;大部分网站往往对脚本注入有严格的防范，但是对 CSRF 的防范做的就差很多。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>实例 1</strong>：假设某网站高级会员会享有某些特殊权限。而当一个普通用户付款完毕就可以让管理员将自己升级为高级会员。假设管理员将一个普通用户升级为高级会员的请求是：</p>
<p><a href="http://www.mysite.com/promoteUser.jsp?username=aaaaa" target="_blank" rel="external">http://www.mysite.com/promoteUser.jsp?username=aaaaa</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们再假设普通用户有在网站某个论坛发表话题的权限，这样一个普通用户可以将这个 URL 发表在某些话题之中，然后用我们称为社会工程学的方法引诱网站管理员点击这个链接。当管理员点击这个链接时，这个请求就会从浏览器发送到后台服务器，从而完成身份的升级。当然，在实际攻击过程中，有很多手段使得让管理员不点击也能发送这样的请求，比如将这个 URL 设置为某个图片的源。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>实例 2</strong>：以一个二手跳蚤市场为例子，比如某商业交易网站注册用户 Hacker01 和     Customer01。Hacker01 在上交易频道摆上 1 辆 9 成新的宝马，投标价格是 20000$，另外再摆上另外一量废旧车型标价 1000$，然而网站是允许加载图片显示车的状况的。    所以宝马车主可以上载一个自己的图片，废旧车主也可以上载一个自己的图片。</p>
<p>宝马图片 url:<a href="http://myrepository/BMW.jpg" target="_blank" rel="external">http://myrepository/BMW.jpg</a> car id 100000001</p>
<p>废旧车图片 url:<a href="http://myrepository/oldCar.jpg" target="_blank" rel="external">http://myrepository/oldCar.jpg</a> car id 100000002</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;而该拍卖网站是通过投标决定车的最终价格，假设是竞买者参加竞买宝马的时候点击购买按钮浏览器是通过发一个 GET 请求到 <a href="http://e-bussiness-car/bid?value=20000$&amp;carid=100000001" target="_blank" rel="external">http://e-bussiness-car/bid?value=20000$&amp;carid=100000001</a> 来提交自己的竞标价格。那么 Hacker01 则可以把废    旧车图片修改为 <a href="http://e-bussiness-car/bid?value=20000$&amp;carid=100000001（或者其他的" target="_blank" rel="external">http://e-bussiness-car/bid?value=20000$&amp;carid=100000001（或者其他的</a> value 参数的数值）。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这时候的情况是：Customer01 访问宝马能看见正确的图片，并且没有任何问题。而访问废旧车发现图片是一个无法看到的图片，但当 Customer01 浏览旧车图片的时候，浏览器已经向宝马车发送了一个竞标请求。这样在用户的控制之外发出了一个合法的请求，并且被服务器接收。Hack01 可以在 Customer01 不知觉的情况下将自己的宝马车卖出。通过此例可以发现 CSRF 有着非常严重的危害性。</p>
<h2 id="CSRF-攻击的基本路径及方法"><a href="#CSRF-攻击的基本路径及方法" class="headerlink" title="CSRF 攻击的基本路径及方法"></a>CSRF 攻击的基本路径及方法</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HTTP 协议中定义了，GET/POST/PUT/DELETE 四种基本操作方法如图 1 标记-1 所示 GET/POST 是所有网站或服务器必须使用的操作方法，而 PUT/DELETE 功能强大，但是在以往的应用中并没有被广泛的使用，直到 Web 2.0 的出现，Ajax 的引用导致     PUT/DELETE 在 REST 框架下被发扬光大，大量使用，也使 CSRF 的攻击手段中多了一种    攻击方式。本文以常用的 GET/POST 为实例，这两者是被浏览器用作与服务起进行数据交互的主要手段，并包含 Ajax 框架下的攻击介绍。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CSRF 攻击的方法多种多样，而对这些攻击方法的认识将更有助于去检查或在产品设计中加入对 CSRF 攻击的防范使整个产品的开发的代价更小。按照攻击的方式来看，分为显式攻击和隐式攻击。显示攻击对用户来说是可以察觉的，例如通过各种方法向受害者发送链接，而隐式攻击则很难察觉，往往是访问了一个有漏洞的页面，或者一个恶意的页面，使用频率更多的则是隐性攻击，因为其更具备可操作性。下边介绍到的攻击方法都可以采取隐式攻击方法。要注意的是，用户网站是否存在脚本注入的漏洞，并不影    响 CSRF 攻击，通过使用第 3 方存在安全隐患的网站一样可以完成 CSRF 攻击。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对图 1 的基本解释，标记-1 是合法用户对用户网站的访问，执行合法有效的操作；标记-2 是通过邮件系统对用户发动攻击；标记 3 是利用 Web 的网站，包括用户的操作网站，普通网站，以及黑客网站，标记-4、5、6 指的是有害用户（标记-3）利用的 3 种方式来攻击受害用户。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;图 1. CSRF 攻击示意图</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%20CSRF%20%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%98%B2%E8%8C%83/01.jpeg?raw=true" alt=""></p>
<h2 id="对-GET-请求的-CSRF-漏洞的攻击方式"><a href="#对-GET-请求的-CSRF-漏洞的攻击方式" class="headerlink" title="对 GET 请求的 CSRF 漏洞的攻击方式"></a>对 GET 请求的 CSRF 漏洞的攻击方式</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;GET 请求使用的频率最高，隐式的 GET 请求，例如 <img> <script\><frame><iframe>，在页面中引入上述页面元素，并且设置 SRC 属性就能在用户未知的情况下发出一个 GET 请求到想去攻击的网站。</iframe></script\></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以 IMG 标签为例，攻击者可以通过在图 1 中的标记-5、标记-6、标记-2、标记-4 的途径发起攻击。这种攻击的特征是无明显提示，但是已经发出一个具有完整合法的用户请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=http://UserSite/admin/deletepage?id=74NBCDSEFG/&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于一个大量采用 GET 请求的网站，隐式的通过 http 标签发出一个 GET 请求将是致命的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;具体的可执行情形描述将在如何检测部分给出。</p>
<h2 id="对-POST-请求的-CSRF-漏洞的攻击方式"><a href="#对-POST-请求的-CSRF-漏洞的攻击方式" class="headerlink" title="对 POST 请求的 CSRF 漏洞的攻击方式"></a>对 POST 请求的 CSRF 漏洞的攻击方式</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对 CSRF 有一种理解是把 GET 改为 POST 请求就认为是可以防止被攻击实际上是一种错误的理解，通过使用 <iframe> 一样可以完成一个隐式的 CSRF 攻击，具体脚本写法如下。</iframe></p>
<h3 id="清单-1-Frame1-html-脚本"><a href="#清单-1-Frame1-html-脚本" class="headerlink" title="清单 1. Frame1.html 脚本"></a>清单 1. Frame1.html 脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">function</span> post(url, fields) &#123;</div><div class="line">	var p = document.createElement(<span class="string">'form'</span>);</div><div class="line">	p.action = url;</div><div class="line">	p.innerHTML = fields;</div><div class="line">	p.target = <span class="string">'_self'</span>;</div><div class="line">	p.enctype = <span class="string">'multipart/form-data'</span>;</div><div class="line">	p.method = <span class="string">'post'</span>;</div><div class="line">	document.body.appendChild(p);</div><div class="line">	p.submit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">csrf_hack</span></span>() &#123;</div><div class="line">	var fields;</div><div class="line">	var csrf=<span class="string">"&lt;addMember </span></div><div class="line"><span class="string">	  dnName="</span>CN=manager 9/OU=Managers/OU=Users/O=QDSVT/DC=CN/DC=IBM/DC=COM<span class="string">" </span></div><div class="line"><span class="string">	  accessLevel="</span>Author<span class="string">" isPerson="</span>1<span class="string">" isLocal="</span>0<span class="string">"/&gt;"</span>;</div><div class="line">	fields += <span class="string">"&lt;input type='' name='action' value='"</span>+csrf+<span class="string">"'&gt;"</span>;</div><div class="line">	unescape(fields);</div><div class="line">	post(<span class="string">'http://usersite:80/dm/services/DocumentService?do401=true'</span>,fields);</div><div class="line">	alert(<span class="string">"csrf_end"</span>);</div><div class="line">&#125;</div><div class="line">	csrf_hack();</div><div class="line">	alert(<span class="string">'end'</span>)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="清单-2-IFrame-html"><a href="#清单-2-IFrame-html" class="headerlink" title="清单 2. IFrame.html"></a>清单 2. IFrame.html</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;IFRAME src=./frame1.html width=0 height=0&gt;&lt;/IFRAME&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这段代码通过脚本构造一个表单提交，通过 IFRAME 加载页面自动执行本例，IFRAME 宽高属性设置成零的目的是为了达到隐式攻击的效果，JAVASCRIPT 只对窗口的大小有不成文的规范，宽高不能小于 50 像素点，但是对 iframe 并没有要求，这为隐式的跨域 Post 攻击提供了一个量好的途径。写成脚本的形式并不是说明只要被检测的站点没有脚本注入就没有任何问题，POST 隐式攻击方式一样可以通过第 3 方，如图 1，4，5，6 攻击路径都适合本例的使用。</p>
<h2 id="Web-2-0-攻击方式"><a href="#Web-2-0-攻击方式" class="headerlink" title="Web 2.0 攻击方式"></a>Web 2.0 攻击方式</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Web 2.0 技术因其能大幅度提升用户的体验，已经被非常广泛的使用，并且 Web 2.0 技术对跨站请求的提交有严格的检查，所以一般不用担心来自第三方的 xmlhttp 发出的 CSRF 攻击。Web 2.0 技术如果在本站点存在脚本注入漏洞，将会产生严重的 CSRF 攻击问题；另外一条攻击路径则是通过邮件系统，向受害用户发送带有 xmlhttp 请求的脚本文件，是否产生危害取决于用户是否执行该文件，危害性明显低于前两种。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于发邮件，或者网站上传的文件发起攻击的案例是由 IE 的特性造成，由于 IE 允许从本地域 (local domain) 对任意域发送，一个包含 Web 2.0 代码的例子就能使 IE 完成成一次离线状态的攻击，IE 允许通过对策略的修改以达到严格的安全配置，从而禁止对同域内容的访问。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以下是通常使用的对 Web 2.0 类型的跨站漏洞的攻击代码。</p>
<h3 id="清单-3-通常使用的对-Web-2-0-类型的跨站漏洞的攻击代码"><a href="#清单-3-通常使用的对-Web-2-0-类型的跨站漏洞的攻击代码" class="headerlink" title="清单 3. 通常使用的对 Web 2.0 类型的跨站漏洞的攻击代码"></a>清单 3. 通常使用的对 Web 2.0 类型的跨站漏洞的攻击代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">alert(<span class="string">'start delete'</span>);</div><div class="line">var payload=<span class="string">"&lt;soap:Envelope xmlns:soap="</span>http://schemas.xmlsoap.org/soap/envelope/<span class="string">" </span></div><div class="line"><span class="string">  xmlns:xsi="</span>http://www.w3.org/2001/XMLSchema-instance<span class="string">" </span></div><div class="line"><span class="string">  xmlns:xsd="</span>http://www.w3.org/2001/XMLSchema<span class="string">"&gt;&lt;soap:Header&gt;</span></div><div class="line"><span class="string">  &lt;serviceVersion&gt;8.0.0</span></div><div class="line"><span class="string">  &lt;/serviceVersion&gt;&lt;/soap:Header&gt;&lt;soap:Body&gt;&lt;deleteDocument </span></div><div class="line"><span class="string">  xmlns="</span>http://webservices.clb.content.ibm.com<span class="string">"&gt; </span></div><div class="line"><span class="string">    &lt;path&gt;/@Pcsrftestplace/@RMain.nsf/@F/@DE44FD4FF0956D07648257570002C42DA</span></div><div class="line"><span class="string">    &lt;/path&gt;</span></div><div class="line"><span class="string">    &lt;/deleteDocument&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;"</span>;</div><div class="line">alert(message);</div><div class="line">var client = new XMLHttpRequest();</div><div class="line"> client.open(<span class="string">"POST"</span>, </div><div class="line"> <span class="string">"http://usercite.com /files/form/api/collections/</span></div><div class="line"><span class="string"> 2d0f6188-8872-4722-8922-3a3c842aa443/entry?format=xml "</span>);</div><div class="line"> client.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>);</div><div class="line"> client.setRequestHeader(<span class="string">"x-method-override"</span>,<span class="string">"DELETE"</span>); </div><div class="line"> client.setRequestHeader(<span class="string">"x-requested-with"</span>,<span class="string">"XMLHttpRequest"</span>);</div><div class="line"> (you can customized the header <span class="keyword">if</span> you need)</div><div class="line"> client.send(<span class="string">""</span>);</div><div class="line">&lt;/script&gt; </div><div class="line">&lt;html&gt;</div></pre></td></tr></table></figure>
<h2 id="登陆-CSRF-攻击方式"><a href="#登陆-CSRF-攻击方式" class="headerlink" title="登陆 CSRF 攻击方式"></a>登陆 CSRF 攻击方式</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;登陆式的跨站请求伪造是一种较新的攻击方式，让用户错误的以为是用自己的帐户密码登陆，实际上是登录到一个 Hacker 的账户。这种攻击方式的最显著的特征是，Hacker 可以监听到用户的实际操作，通过查询历史记录可以知道用户做了那些操作，如果是在商业网站则会在历史记录中留下信用卡号，如果是在个人信息相关系统则会留下用户的隐私操作。</p>
<h2 id="使用-Rational-AppScan-对-CSRF-的检测"><a href="#使用-Rational-AppScan-对-CSRF-的检测" class="headerlink" title="使用 Rational AppScan 对 CSRF 的检测"></a>使用 Rational AppScan 对 CSRF 的检测</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;APPSCAN 是 IBM 收购 WatchFire 之后获得一款强大的网络安全的检测工具，目前属于 Rational 产品线，功能集中在网络应用产品的检测防范上，分静态与动态两种不同的功能，覆盖代码与产品的两端检测需求。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;APPSCAN 自从 7.7 的版本以后加入对 CSRF 的防范，基本原理是通过对同一个需要检测的 URL 或者 SERVICE 按照顺序发出两次请求，发送两次请求之间会做一次退出登录状态的操作，如果一个对 CSRF 已经进行防范的网站是会发送回两个不同的回应内容。实例的说明如下。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>请求 1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET/POST http://myproduct.com/services?action=remove&amp;id=10002</div><div class="line">Headers ….. …..</div><div class="line"></div><div class="line">	</div><div class="line">Content: ……</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>返回内容 1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Response 200</div><div class="line">Headers …. …..</div><div class="line">Content:…..</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>请求 2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET/POST http://myproduct.com/services?action=remove&amp;id=10002</div><div class="line">Headers ….. …..</div><div class="line"></div><div class="line">	</div><div class="line">Content: ……</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>返回内容 2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Response 200</div><div class="line">Headers …. …..</div><div class="line">Content:…..</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;返回内容 1 和返回内容 2 如果是完全一致的则可以认为是有问题的，反之则可以认为是没有问题。看似简单的原理，在实际操作中有个很繁琐的逻辑问题，比如请求 1 是一个删除动作，那么如何去构造一个请求 2，并且获得一个一致的结果呢？解决的办法是，要先做一个操作 1，然后再创建一个同样的 1，再做操作 2。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从上述的简单例子就可以发现有效监测 CSRF 是一个较为繁琐的过程。AppScan 的检测前提就是对目标资源的操作在不同的一个 Session 中返回的内容肯定是应该不一样的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里要注意的问题是误报，Web 应用程序操作大多都是对一个固定的 URL 的请求，包含一些资源文件，以及一些功能性的请求。对于资源文件的操作，很多情况下都是一个静态的请求，在未使用 PUT/DELETE 的应用程序，是无需对 GET 请求进行 CSRF 测试，在这种情况下是不存在 CSRF 漏洞的。而如果使用了 Ajax 框架的应用程序如果存在 DELETE/PUT 操作则需注意很可能出现严重的 CSRF 问题。未使用 Ajax 的产品则集中在 GET/POST 请求，需要注意的是 GET/POST 请求对 CSRF 来说是同样具有可操作性的，对产品的危害性是一致的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对 CSRF 测试的两个主要方向是路径覆盖测试，和精确测试。之所以是要做如此分类的原因是一个产品有大量的 URL 如果一一测试需要大量的时间精力，覆盖测试是由工具去完成的是为了保证覆盖到产品的各个路径，有些产品实际上已经对 CSRF 有很深的认识，在这种情况下大多数资源已经被很好的保护起来，没有 CSRF 的问题，这时候一个对全路径的测试就是很必要的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;精确测试是由人来完成的通过分析产品功能和开发人员的沟通，阅读设计文档来完成的。为何要做精确测试的原因是，所有 Web 应用程序非常关注的问题之一就是产品的性能，而对所有请求都做 CSRF 防范的话就比如在一个高速公路上设置一个人工收费站一样会大大影响性能，一个好的 Web 应用在对 CSRF 防范是有针对性的，对一个没有 CSRF 保护的产品，一个良好的 CSRF 保护开端可以是由精确测试的结果为发起的。通过对固定功能的检测，以及对设计文档的了解，基本就可以断定产品是否做了 CSRF 保护。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一个正常的使用 Appscan 来检测 CSRF 的流程如图 2 所示。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;图 2. 一个正常的使用 Appscan 来检测 CSRF 的流程</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%20CSRF%20%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%98%B2%E8%8C%83/02.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AppScan 使用流程，AppScan 执行过程的一个分解，如图 3。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;图 3. AppScan 执行过程的一个分解</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%20CSRF%20%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%98%B2%E8%8C%83/03.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;精确测试的方法，目的是为了检测是否存在 CSRF 保护。对 CSRF 保护有个范围约束的问题，并不是所有的请求都需要对 CSRF 攻击做防范。对静态资源除非有 DELETE/PUT 操作允许的情况下，才需要进行测试；而对于关键的业务逻辑，比如银行转帐，确认收货人信息，参加竞标，删除一个用户，赋予用户高级权限，等等，对这类定性问题的约束是根据不同的商业产品各异，要具体问题具体分析。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;本例以常见的页面删除为实例，阐述一个可以的测试方法。大概分为以下几种情况 :<br>使用 GET 来删除页面的，使用 DELETE/PUT 来删除页面的，使用 POST 来删除页面的，都是服务器与客户端的交互过程，具体的实例分析起来要远比分类更为复杂，一个    操作可能带有很多各样的请求，找到有威胁的请求才是最终目的，有时候哪怕是         AppScan 已经定位到具体是那个请求，也还需要通过手工将这个案例找出加以描述成为    有实际操作价值的场景，这里就需要引入手工测试工具加以支持。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;手工工具的介绍，做精确测试需要对 HTTP 请求做频繁的操作，如果需要查看请求的内容，还有对具体请求的操作的观察，推荐使用 Fiddler 或者 WebScarab。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开始手动验证之前，还需要清楚 CSRF 发生的条件。所有的问题的发生有个前提条件是用户常用的浏览器中有一个与目标服务器处于激活状态的会话。这个条件需要的原因是，CSRF 攻击的模式是用户 A 被恶意用户 B 所攻击，攻击是 B 发起的被用户 A 执行实现的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;而 B 往往是在 A 常去的网站注入代码，或者发送链接或者包含附件的文件给 A，而包含着恶意代码或者链接的页面要被执行，条件是用户 A 已经处在和服务器的会话之中，这也是 CSRF 发生的前提条件，也是手工测试的基础。</p>
<h2 id="对-GET-CSRF-漏洞的测试"><a href="#对-GET-CSRF-漏洞的测试" class="headerlink" title="对 GET CSRF 漏洞的测试"></a>对 GET CSRF 漏洞的测试</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;GET 请求的情况下，请求如 <a href="http://mysite/service?action=delete&amp;pageid=100001" target="_blank" rel="external">http://mysite/service?action=delete&amp;pageid=100001</a> 这类问题的验证最为直接，并且无需写脚本和使用 fiddler 工具去观察实际的请求的格式。检测方法就是在维持一个与服务器连接的前提下，在浏览器地址栏输入如下网址，如果实际的页面被删除了就是 CSRF 攻击成功了。对于如此清楚的实例基本看到 URL 已经可以证明没有任何 CSRF 保护。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可关联的攻击场景如下，在任何可以显示图片的地方写入如下 <img src="http://mysite/service?action=delete&pageid=100001" width="0" height="0/">，另外只需    要指引有删除权限的用户访问一下包含这个图片标签的网页，往往是通过发一个邮件或者 MSN 一个简单的链接就可以完成删除页面的操作。</p>
<h2 id="对-POST-CSRF-漏洞的测试"><a href="#对-POST-CSRF-漏洞的测试" class="headerlink" title="对 POST CSRF 漏洞的测试"></a>对 POST CSRF 漏洞的测试</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;POST 请求的操作并不能免除 CSRF 的攻击。在浏览器中要发出 POST 请求，可以使用两种方法，一个是通过脚本调用页面文档元素 form 直接进行提交操作，特点是可以进行跨域的脚本提交，隐式攻击。另一种是通过使用 Ajax 对象直接发出请求，但是由于不能跨域发出请求，可执行的力度并不高，但是还是有可能性。同样是一个删除页面的操作，如下所示结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST http://mysite/service</div><div class="line">Headers….</div><div class="line"></div><div class="line">Action=delete&amp;pageid=100001</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个不同于 GET 之处是不能简单的通过在浏览器直接输入一个链接就能测试。需要借助一下预设好的 HTTP 服务器如 IBM HTTP Server、Domino，或者 IIS。将 IFrame.html 的清单拷贝到服务器的一个目录。通过修改 frame1.html 中的 csrf_hack() 如下。</p>
<h3 id="清单-4-修改-frame1-html-中的-csrf-hack"><a href="#清单-4-修改-frame1-html-中的-csrf-hack" class="headerlink" title="清单 4. 修改 frame1.html 中的 csrf_hack()"></a>清单 4. 修改 frame1.html 中的 csrf_hack()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">csrf_hack</span></span>() &#123;</div><div class="line"> 	var fields;</div><div class="line">	fields += <span class="string">"&lt;input type='' name='action' value='"</span>+<span class="string">"delete"</span>+<span class="string">"'&gt;"</span>;</div><div class="line">	fields += <span class="string">"&lt;input type='' name=pageid value='"</span>+<span class="string">"1000001"</span> +<span class="string">"'&gt;"</span>;</div><div class="line">	unescape(fields);</div><div class="line">	post(<span class="string">'http://mysite/service '</span>,fields);</div><div class="line">	alert(<span class="string">"csrf_end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可关联的攻击场景如下 ，通过邮件或者 MSN 发送一个链接 <a href="http://hackerWebServer/iframe" target="_blank" rel="external">http://hackerWebServer/iframe</a> 给可以删除页面的用户，该操作就会被执行，如果页面删除，攻击成功。通过在其他网站可以做脚本注入的将 iframe.html 脚本写在该网站，    一样可以达到攻击效果。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另一类通过 Ajax 提交的 post 请求，这类结构中多采用 SOAP message 或者类似的 XML 消息体，或者 Jason 消息体提交请求。结构如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST http://mysite/service</div><div class="line">Headers….</div><div class="line"></div><div class="line">&lt;soap:Envelope xmlns:soap=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> </div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </div><div class="line">xmlns:xsd=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;&lt;soap:Header&gt;</div><div class="line">&lt;serviceVersion&gt;8.0.0&lt;/serviceVersion&gt;</div><div class="line">&lt;/soap:Header&gt;&lt;soap:Body&gt;</div><div class="line">&lt;deleteDocument </div><div class="line">xmlns=<span class="string">"http://webservices.clb.content.ibm.com"</span>&gt; </div><div class="line">&lt;path&gt;/@Pcsrftestplace/@RMain.nsf/@F/@DE44FD4FF0956D07648257570002C42DA</div><div class="line">&lt;/path&gt;&lt;/deleteDocument&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在此类情况下，需要修改 form 的表单的 enctype 属性为 multipart/form-data，因为在默认的情况下是 application/x-www-form-urlencoded，所有字符都会做 URL 编码转换，提交的数据是不合法的无法被服务器端识别，所以需要修改 enctype 属性，在 multipart/formdata 的情况下，数据是不会被编码的，而在很多服务器的接收端有的就是    使用 multipart/formdata 去接受数据。由于 javascript 出于对安全的考虑禁止脚本自动修    改 form 中提交的 file 属性的输入的值，所以想通过脚本修改控制 enctype 是不允许的，这样不同于第一类 POST 请求。但是并不影响场景的合理性，通过在有漏洞的网站伪造表单请求，form 指向我们要操作的 URL 即可。这种情况下，需要构造一个完整的表单，并通过用户点击一个任意方式发送的链接达到攻击效果。</p>
<h2 id="对-DELETE-PUT-CSRF-漏洞的测试"><a href="#对-DELETE-PUT-CSRF-漏洞的测试" class="headerlink" title="对 DELETE/PUT CSRF 漏洞的测试"></a>对 DELETE/PUT CSRF 漏洞的测试</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DELETE/PUT 请求依赖于 Web 2.0 技术，由于本身的限制，自由发出跨站的伪造请求是不可能的。更多使用的是离线攻击，或者本站点的脚本注入攻击。在存在本站点脚本注入攻击的情况下，所有这 4 种情况下，都可以完成隐式的攻击方式。代码请参照 Web 2.0 攻击章节的实例。</p>
<h2 id="CSRF-的防范"><a href="#CSRF-的防范" class="headerlink" title="CSRF 的防范"></a>CSRF 的防范</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CSRF 的防范机制有很多种，防范的方法也根据 CSRF 攻击方式的不断升级而不断演化。常用的有检查 Refer 头部信息，使用一次性令牌，使用验证图片等手段。出于性能的考虑，如果每个请求都加入令牌验证将极大的增加服务器的负担，具体采用那种方法更合理，需要谨慎审视每种保护的优缺点。</p>
<ol>
<li>检查 HTTP 头部 Refer 信息，这是防止 CSRF 的最简单容易实现的一种手段。根据 RFC 对于 HTTP 协议里面 Refer 的定义，Refer 信息跟随出现在每个 Http 请求头部。Server 端在收到请求之后，可以去检查这个头信息，只接受来自本域的请求而忽略外部域的请求，这样就可以避免了很多风险。当然这种检查方式由于过于简单也有它自身的弱点：</li>
</ol>
<ul>
<li>首先是检查 Refer 信息并不能防范来自本域的攻击。在企业业务网站上，经常会有同域的论坛，邮件等形式的 Web 应用程序存在，来自这些地方的 CSRF 攻击所携带的就是本域的 Refer 域信息，因此不能被这种防御手段所阻止。</li>
<li>同样，某些直接发送 HTTP 请求的方式（指非浏览器，比如用后台代码等方法）可以伪造一些 Refer 信息，虽然直接进行头信息伪造的方式属于直接发送请求，很难跟随发送 cookie，但由于目前客户端手段层出不穷，flash，javascript 等大规模使用，从客户端进行 refer 的伪造，尤其是在客户端浏览器安装了越来越多的插件的情况下已经成为可能了。</li>
</ul>
<ol>
<li>使用一次性令牌，这是当前 Web 应用程序的设计人员广泛使用的一种方式，方法是对于 Get 请求，在 URL 里面加入一个令牌，对于 Post 请求，在隐藏域中加入一个令牌。这个令牌由 server 端生成，由编程人员控制在客户端发送请求的时候使请求携带本令牌然后在 Server 端进行验证。但在令牌的设计上目前存在着几个错误的方案：</li>
</ol>
<ul>
<li>使用和 Session 独立的令牌生成方式。这种令牌的值和 Session 无关，因此容易被其他用户伪造。这里的其他用户指的是当前 Web 应用程序的其他用户和活跃在网络传输阶段各个设置上的监听者，这种恶意用户可能使用自己的令牌来进行替换以便达到伪造的目的。</li>
<li>完全使用 Session 认证信息作为令牌的生成方式。这种保护方式对于保护 CSRF 是起了作用的，但是可能会造成其他危害，具体来说，如果某些 URL 或者网页被拷贝下来与其他人共享，那么这些 URL 或者拷贝下来的网页中可能会含有用户的会话信息，这种信息一旦被恶意用户获得，就能造成极大的危害。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因此，一个正确的令牌设计应该是使用 Session 信息做 Hash，用得出的哈希值来做 CSRF 的令牌。</p>
<ol>
<li>使用验证图片，这种方法的出现的作用是对于机器人暴力攻击的防止。但在 CSRF 的防范上，也有一些安全性要求比较高的的应用程序结合验证图片和一次性令牌来做双重保护。由于这种图片验证信息很难被恶意程序在客户端识别，因此能够提高更强的保护。当客户端的浏览器可能已经处于一种不安全的环境中的情况下（比如客户端的安全级别设置较低，客户端浏览器安装了不安全的插件等）。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以上给的这些只是防范 CSRF 的比较通用的一些方法，Web 开发人员可以根据自己对自己的应用程序的功能的理解来确定安全级别的要求从而选择使用不同的保护措施，也推荐在同一应用程序内部结合使用多种方法来进行保护。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CSRF 攻击作为一个存在已久的攻击方式，在大量的商业网站上都可以找出，应用本文的知识作出一个合理的分析，有针对性的提出改进方案才是本文作者希望看到的，在即不损害应用程序的性能的前提下，提高安全性；而对即将开发的网络应用程序来说，深刻理解其的危害性，在设计阶段就考虑到对 CSRF 的防范，无疑能收到更好的效果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux安全/">Linux安全</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/28/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/30/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 失落的乐章
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: ,
		mathjax: ,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



  </div>
</body>
</html>