<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>失落的乐章</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="失落的乐章的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="失落的乐章">
<meta property="og:url" content="https://hcldirgit.github.io/page/55/index.html">
<meta property="og:site_name" content="失落的乐章">
<meta property="og:description" content="失落的乐章的Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失落的乐章">
<meta name="twitter:description" content="失落的乐章的Blog">
  
    <link rel="alternative" href="/atom.xml" title="失落的乐章" type="application/atom+xml">
  
  
    <link rel="icon" href="https://github.com/hcldirgit/image/blob/master/0.png?raw=true">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">失落的乐章</a></h1>
		</hgroup>

		
		<p class="header-subtitle">技术面前，永远都是学生。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ansible/" style="font-size: 10.42px;">Ansible</a> <a href="/tags/Apache/" style="font-size: 18.33px;">Apache</a> <a href="/tags/Cacti/" style="font-size: 11.67px;">Cacti</a> <a href="/tags/DNS/" style="font-size: 13.33px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/FTP/" style="font-size: 11.25px;">FTP</a> <a href="/tags/Git/" style="font-size: 10.83px;">Git</a> <a href="/tags/HA集群/" style="font-size: 11.67px;">HA集群</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/Jenkins/" style="font-size: 10.42px;">Jenkins</a> <a href="/tags/LAMP/" style="font-size: 19.58px;">LAMP</a> <a href="/tags/LNMP/" style="font-size: 17.08px;">LNMP</a> <a href="/tags/LVS/" style="font-size: 16.67px;">LVS</a> <a href="/tags/Linux/" style="font-size: 19.17px;">Linux</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux安全/" style="font-size: 14.17px;">Linux安全</a> <a href="/tags/Memcached/" style="font-size: 11.25px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 15.42px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nagios/" style="font-size: 11.67px;">Nagios</a> <a href="/tags/Nginx/" style="font-size: 17.92px;">Nginx</a> <a href="/tags/OpenStack/" style="font-size: 11.25px;">OpenStack</a> <a href="/tags/Php/" style="font-size: 14.58px;">Php</a> <a href="/tags/Puppet/" style="font-size: 11.25px;">Puppet</a> <a href="/tags/Python/" style="font-size: 14.58px;">Python</a> <a href="/tags/Redis/" style="font-size: 16.25px;">Redis</a> <a href="/tags/Resin/" style="font-size: 10px;">Resin</a> <a href="/tags/Saltstack/" style="font-size: 10px;">Saltstack</a> <a href="/tags/Samba/" style="font-size: 12.08px;">Samba</a> <a href="/tags/Squid/" style="font-size: 14.58px;">Squid</a> <a href="/tags/Tomcat/" style="font-size: 13.75px;">Tomcat</a> <a href="/tags/Zabbix/" style="font-size: 15.83px;">Zabbix</a> <a href="/tags/haproxy/" style="font-size: 12.5px;">haproxy</a> <a href="/tags/keepalived/" style="font-size: 12.92px;">keepalived</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/shell练习/" style="font-size: 18.75px;">shell练习</a> <a href="/tags/正则表达式/" style="font-size: 12.92px;">正则表达式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">失落的乐章</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">失落的乐章</h1>
			</hgroup>
			
			<p class="header-subtitle">技术面前，永远都是学生。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-1. Linux 基础/68. rsync错误二则、排错过程及解决办法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/68. rsync错误二则、排错过程及解决办法/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.299Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/68. rsync错误二则、排错过程及解决办法/">
        rsync错误二则、排错过程及解决办法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/hcldirgit/image/blob/master/rsync%E9%94%99%E8%AF%AF%E4%BA%8C%E5%88%99%E3%80%81%E6%8E%92%E9%94%99%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/01.png?raw=true" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#created by zhaopeiwu @ 2015-04-20</span></div><div class="line"><span class="comment">#FOR control the size of error log of apache</span></div><div class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/usr/<span class="built_in">local</span>/apache2/bin:/usr/<span class="built_in">local</span>/mysql/bin</div><div class="line"><span class="built_in">export</span> PATH</div><div class="line"></div><div class="line">log_path=<span class="string">"/usr/local/apache2/logs/"</span></div><div class="line">log_size=`du -s <span class="variable">$log_path</span>/error_log|cut -f 1`</div><div class="line"><span class="keyword">if</span> [ <span class="variable">$log_size</span> -gt 100000 ];</div><div class="line"><span class="keyword">then</span></div><div class="line">    mv <span class="variable">$log_path</span>/error_log <span class="variable">$log_path</span>/error_log_`date +%Y%m%d`;</div><div class="line">    touch <span class="variable">$log_path</span>/error_log;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">num_del=`ls -t <span class="variable">$log_path</span>/error*|wc -l`</div><div class="line"><span class="keyword">if</span> [ <span class="variable">$num_del</span> -gt 4 ];</div><div class="line"><span class="keyword">then</span></div><div class="line">    ls -t <span class="variable">$log_path</span>/error*|tail -$[<span class="variable">$num_del</span>-2]|xargs -i rm -f &#123;&#125; 2 &gt; /dev/null</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/53. PS出的RSS总和大于实际物理内存" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/53. PS出的RSS总和大于实际物理内存/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.298Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/53. PS出的RSS总和大于实际物理内存/">
        PS出的RSS总和大于实际物理内存
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用ps  aux  查看系统进程时，第六列即 RSS列显示的就是进程使用的物理内存。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可是把系统所有进程的该列相加时，得到的总和又远远高于系统实际的物理内存？这到底是怎么回事呢？</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看一看linux是如何管理内存的就会知道。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;理解的意思是这样的，linux会在每个进程生成时分配一定量的内存给这个进程，这个只是分配，而体现在ps出来的是VSZ那列，这叫做虚拟内存。但实际上这些进程并没有占用这些内存。不妨，我也借用网上的一个例子来形容一下，就像银行发工资给员工一样，每个员工都有一个自己的银行卡，每月银行都会把固定的钱数打到员工的银行卡里，但是这个过程并不是把实际的钱发到员工手里，只是一串数字而已。实际上，银行并没有那么多钱的。回头再来看看linux给进程分配内存是不是和上面的举的例子很像呢？</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;讲了上面的观点后，依然不能把笔者所设的问题解答，那么继续往下探讨：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;把系统所有进程的该列相加时，得到的总和又远远高于系统实际的物理内存？这是因为 ps 的结果，RSS 那部分，是包括共享内存的。这里使用 pmap 来看看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">pmap -d 24030</div><div class="line">24030: /usr/<span class="built_in">local</span>/php/bin/php-cgi --fpm --fpm-config /usr/<span class="built_in">local</span>/php/etc/php-fpm.conf</div><div class="line">Address Kbytes Mode Offset Device Mapping</div><div class="line">0000000000400000 6444 r-x-- 0000000000000000 008:00002 php-cgi</div><div class="line">0000000000c4b000 272 rw--- 000000000064b000 008:00002 php-cgi</div><div class="line">0000000000c8f000 52 rw--- 0000000000c8f000 000:00000 [ anon ]</div><div class="line">00000000059dc000 9572 rw--- 00000000059dc000 000:00000 [ anon ]</div><div class="line">0000003519000000 508 r-x-- 0000000000000000 008:00002 libfreetype.so.6.3.10</div><div class="line">000000351907f000 2048 ----- 000000000007f000 008:00002 libfreetype.so.6.3.10</div><div class="line">中间部分省略</div><div class="line">00002b757df75000 4 rw--- 000000000000a000 008:00002 libnss_files-2.5.so</div><div class="line">00002b757df76000 32768 rw<span class="_">-s</span>- 0000000000000000 000:00008 zero (deleted)</div><div class="line">00002b7580685000 4 rw<span class="_">-s</span>- 0000000000000000 000:00008 zero (deleted)</div><div class="line">00007fff2e126000 476 rwx-- 00007fff2e126000 000:00000 [ stack ]</div><div class="line">00007fff2e19d000 8 rw--- 00007fff2e19d000 000:00000 [ anon ]</div><div class="line">ffffffffff600000 8192 ----- 0000000000000000 000:00000 [ anon ]</div><div class="line">mapped: 139548K writeable/private: 12344K shared: 32772K</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pmap是用来显示内存使用的指令，-d 后面跟的是进程id. 关于pmap的使用以及显示的数据请看<a href="http://www.lishiming.net/thread-977-1-1.html" target="_blank" rel="external">http://www.lishiming.net/thread-977-1-1.html</a> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;linux 会把一些shared libraries 载入到内存中，在pmap 的输出中，这些shared      libraries 的名字通常是 lib*.so ,如 libX11.so.6.2.0 。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个 libX11.so.6.2.0 会被很多process load 到自己的运行环境中，同时，ps 输出的RSS 结果中，每个process 都包含了这个libX11.so.6.2.0 ，而事实上它只被load 了一次，如果单纯把ps 的结果相加，这样就重复计算了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看pmap输出的结果，其实php-cgi 单纯进程所占的内存是这个writeable/private: 12344K</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/70. 如何知道你的linux是什么时候安装的" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/70. 如何知道你的linux是什么时候安装的/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.297Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/70. 如何知道你的linux是什么时候安装的/">
        如何知道你的linux是什么时候安装的
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在安装系统时，每个分区下都会有一个 lost+found，而且这个目录的创建时间是和该分区创建的时间一样的。所以如果想知道你的系统是什么时候安装的，只需要看这个目录的创建时间即可。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通常情况下，我们分区都会把 /boot 单独分一个区，所以你只要查看 /boot/lost+found 这个目录的创建时间即可。比较简单的方法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -ld  /boot/lost+found</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果你的/boot/不是单独分区，那么就看一下 / 下的吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -ld  /lost+found</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/64. 使用xinetd管理网络应用服务" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/64. 使用xinetd管理网络应用服务/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.297Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/64. 使用xinetd管理网络应用服务/">
        使用xinetd管理网络应用服务
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认机器没有安装这个服务，需要安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y xinetd</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;随着互联网的不断发展以及Linux系统的不断完善，以Linux为系统核心的网络服务器的比重正在逐年上升。从WWW服务器到目前流行的游戏服务器，绝大多数都在采用Linux作为服务平台。正是由于各种应用的不断出现和用户群的增长，基于Linux的系统应当拥有完善的安全措施，应当足够坚固、能够抵抗来自Internet的侵袭，这也正是Linux之所以流行并且成为Internet骨干力量的主要原因。一方面，Linux为用户提供了多种优质的网络服务，包括Http、Ftp、Smtp、Pop3等；另一方面，服务的增多意味着更多的风险。每种服务本身都必然存在着某些缺陷，而这些缺陷很有可能被高明的黑客利用来对系统进行攻击。所以，提供特定服务的服务器应该尽可能开放提供服务必不可少的端口，而将与服务器服务无关的服务关闭，比如：一台作为www和ftp服务器的机器，应该只开放80和25端口，而将其他无关的服务如关掉，以减少系统漏洞。本专题将着重讲述在Linux系统中如何使用xinetd机制来管理网络应用服务。</p>
<h2 id="Xinetd机制介绍"><a href="#Xinetd机制介绍" class="headerlink" title="Xinetd机制介绍"></a>Xinetd机制介绍</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在Linux系统的早期版本中，有一种称为inetd的网络服务管理程序，也叫作“超级服务器”，就是监视一些网络请求的守护进程，其根据网络请求来调用相应的服务进程来处理连接请求。inetd.conf则是inetd的配置文件。inetd.conf文件告诉inetd监听哪些网络端口，为每个端口启动哪个服务。在任何的网络环境中使用Linux系统，第一件要做的事就是了解一下服务器到底要提供哪些服务。不需要的那些服务应该被禁止掉，这样黑客就少了一些攻击系统的机会，因为服务越多，意味着遭受攻击的风险越打。用户可以查看“/etc/inetd.conf”文件，了解一下inetd提供和开放了哪些服务，以根据实际情况进行相应的处理。而在Linux7.X的版本当中则使用xinetd（扩展的超级服务器）的概念对inetd进行了扩展和替代。因此本专题主要以xinetd为背景，来讲述如何增加和删除网络服务，从而有效地保证Linux系统安全。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xinetd的默认配置文件是/etc/xinetd.conf。其语法和/etc/inetd.conf完全不同且不兼容。它本质上是/etc/inetd.conf和/etc/hosts.allow，/etc/hosts.deny功能的组合。<br>系统默认使用xinetd的服务可以分为如下几类：</p>
<ul>
<li>标准internet服务：http、telnet、ftp等；</li>
<li>信息服务：finger、netstat、systat；</li>
<li>邮件服务：imap、pop3、smtp；</li>
<li>RPC服务：rquotad 、rstatd、rusersd、sprayd、walld；</li>
<li>BSD服务：comsat、exec、login、ntalk、shell talk；</li>
<li>内部服务：chargen、daytime、echo等；</li>
<li>安全服务：irc；</li>
<li>其他服务：name、tftp、uucp、wu-ftp；</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上述xinetd提供的服务的用途以及使用方法，用户可以查找相关的资料获得，这里不再赘述。然而，对他们有详细地了解是必不可少的，这可以帮助用户较好地确定需要或者不需要哪些网络服务功能。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面是一个典型的/etc/xinetd.conf文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># vi xinetd.conf</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Simple configuration file for xinetd</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Some defaults, and include /etc/xinetd.d/</span></div><div class="line">defaults</div><div class="line">&#123;</div><div class="line"> instances = 60</div><div class="line"> log_type = SYSLOG authpriv</div><div class="line"> log_on_success = HOST PID</div><div class="line"> log_on_failure = HOST</div><div class="line"> cps = 25 30</div><div class="line">&#125;</div><div class="line">includedir /etc/xinetd.d</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从文件最后一行可以清楚地看到，/etc/xinetd.d目录是存放各项网络服务（包括http、ftp等）的核心目录，因而系统管理员需要对其中的配置文件进行熟悉和了解。<br>一般说来，在/etc/xinetd.d的各个网络服务配置文件中，每一项具有下列形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service service-name</div><div class="line">&#123;</div><div class="line">Disabled //表明是否禁用该服务</div><div class="line">Flags //可重用标志</div><div class="line">Socket_type //TCP/IP数据流的类型，包括stream，datagram，raw等</div><div class="line">Wait //是否阻塞服务，即单线程或多线程</div><div class="line">User //服务进程的uid</div><div class="line">Server //服务器守护进程的完整路径</div><div class="line">log_on_failure //登陆错误日志记录</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中service是必需的关键字，且属性表必须用大括号括起来。每一项都定义了由service-name定义的服务。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Service-name是任意的，但通常是标准网络服务名，也可增加其他非标准的服务，只要它们能通过网络请求激活，包括localhost自身发出的网络请求。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个service有很多可以使用的attribute，操作符可以是=，+=，或-=。所有属性可以使用=，其作用是分配一个或多个值，某些属性可以使用+=或－=的形式，其作用分别是将其值增加到某个现存的值表中，或将其值从现存值表中删除。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用户应该特别注意的是：每一项用户想新添加的网络服务描述既可以追加到现有的/etc/xinetd.conf中，也可以在/etc/xinetd.conf中指定的目录中分别建立单独的文件，RedHat 7.x以上的版本都建议采用后一种做法，因为这样做的可扩充性很好，管理起来也比较方便，用户只需要添加相应服务的描述信息即可追加新的网络服务。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedHat 7.x默认的服务配置文件目录是/etc/xinetd.d，在该目录中使用如下命令可以看到许多系统提供的服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#cd /etc/xinetd.d</span></div><div class="line"><span class="comment">#ls</span></div><div class="line">chargen cvspserver daytime-udp <span class="built_in">echo</span>-udp ntalk qmail-pop3 rexec rsh sgi_fam telnet time-udp chargen-udp daytime <span class="built_in">echo</span> finger pop3 qmail-smtp rlogin rsync talk time wu-ftpd</div><div class="line">然而，上述的许多服务，默认都是关闭的，看看如下文件内容：</div><div class="line"><span class="comment">#cat telnet</span></div><div class="line"><span class="comment"># default: off //表明默认该服务是关闭的</span></div><div class="line"><span class="comment"># description: The telnet server serves telnet sessions; it uses \</span></div><div class="line"><span class="comment"># unencrypted username/password pairs for authentication.</span></div><div class="line">service telnet</div><div class="line">&#123;</div><div class="line"> <span class="built_in">disable</span> = yes //表明默认该服务是关闭的</div><div class="line"> flags = REUSE</div><div class="line"> socket_type = stream </div><div class="line"> <span class="built_in">wait</span> = no</div><div class="line"> user = root</div><div class="line"> server = /usr/sbin/in.telnetd</div><div class="line"> log_on_failure += USERID</div></pre></td></tr></table></figure>
<h2 id="服务的开启与关闭"><a href="#服务的开启与关闭" class="headerlink" title="服务的开启与关闭"></a>服务的开启与关闭</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一般说来，用户可以使用两种办法来对网络服务进行开启与关闭。一种为通过文件直接编写进行开启与关闭；另外一种则通过用户熟悉的图形用户界面进行。下面分别进行介绍。</p>
<h3 id="1-使用-etc-xinetd-d目录下的文件进行配置"><a href="#1-使用-etc-xinetd-d目录下的文件进行配置" class="headerlink" title="1.使用/etc/xinetd.d目录下的文件进行配置"></a>1.使用/etc/xinetd.d目录下的文件进行配置</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;针对上面列出的关于telnet的例子，用户想要开启服务，只需要通过使用vi 编辑器改写该文件为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service telnet</div><div class="line">&#123;</div><div class="line"> <span class="built_in">disable</span> = no //将该域置为“no”，则表明开启该服务</div><div class="line"> flags = REUSE</div><div class="line"> socket_type = stream </div><div class="line"> <span class="built_in">wait</span> = no</div><div class="line"> user = root</div><div class="line"> server = /usr/sbin/in.telnetd</div><div class="line"> log_on_failure += USERID</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后，需要使用/etc/rc.d/init.d/xinetd restart来激活Telnet服务即可。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;相对应的，如果用户想要关闭某个不需要的服务，则将上述的disable = no改为disable = yes即可，这样就修改了服务配置，并且再次使用/etc/rc.d/init.d/xinetd restart来启用最新的配置。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这种方法使用起来相对于Windows下的图形配置方法较为复杂，用户需要对其中的每个参数都有清楚地了解，不能够随意修改，所以建议高级用户或者是有经验的用户使用。</p>
<h3 id="2-使用图形用户界面进行配置："><a href="#2-使用图形用户界面进行配置：" class="headerlink" title="2.使用图形用户界面进行配置："></a>2.使用图形用户界面进行配置：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用户可以在终端下键入“setup”命令来对系统提供的服务、防火墙配置、用户授权配置、网络配置、声卡配置、打印机配置等进行全方位的配置。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用户选择其中的System services进行配置即可.<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用户将会看到系统罗列出了anacron,apmd,autofs,chargen,telnet,http等包括我们上面所讲述的xinetd管理的网络服务在内的系统服务进程，用户通过选择这些进程，则可以开启相应的服务。而如果用户想关掉其中的某个服务，则取消选择，保存退出即可以完成配置。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;而用户这样设置的结果，就相当于直接对/etc/xinetd.d相应网络服务的配置文件进行了改写，只不过使用起来更加直观和方便，且不需要用户具有比较熟练的Linux使用技巧。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;同样需要注意的是，在配置好了相应的网络服务之后，需要执行/etc/rc.d/init.d/xinetd restart命令来对新的改动进行激活，那么就能够使用最新配置的服务了。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后强调用户注意的是，本文给出的使用方法使用效率的高低、正确与否，极大程度上取决于具体的应用，以及用户对各项服务理解程度的不同。希望用户在配置自己的Linux服务器之前，对各种应用服务都作深入地了解，待到根据实际的应用需求确定好需要开启和哪些网络服务之后再使用xinetd机制进行配置，切忌稀里糊涂地进行配置，反而导致产生较大的漏洞和风险。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/16. Linux 环境变量之“PS1”" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/16. Linux 环境变量之“PS1”/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.296Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/16. Linux 环境变量之“PS1”/">
        Linux 环境变量之“PS1”
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PS1（是数字1而不是字母l），每个版本bash的PS1变量内的特殊符号可能有些小的差异，你可以先man bash 一下。下面是FC4环境下默认的特殊符号所代表的意义：</p>
<ul>
<li><p>\d   ：代表日期，格式为weekday month date，例如：”Mon Aug 1”</p>
</li>
<li><p>\H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux</p>
</li>
<li><p>\h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略</p>
</li>
<li><p>\t ：显示时间为24小时格式，如：HH：MM：SS</p>
</li>
<li><p>\T ：显示时间为12小时格式</p>
</li>
<li><p>\A ：显示时间为24小时格式：HH：MM</p>
</li>
<li><p>\u ：当前用户的账号名称</p>
</li>
<li><p>\v ：BASH的版本信息</p>
</li>
<li><p>\w ：完整的工作目录名称。家目录会以 ~代替</p>
</li>
<li><p>\W ：利用basename取得工作目录名称，所以只会列出最后一个目录</p>
</li>
<li><p>\# ：下达的第几个命令</p>
</li>
<li><p>\$ ：提示字符，如果是root时，提示符为：#   ，普通用户则为：$</p>
</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认的PS1内容为： ‘[\u@\h \W]\$ ‘ ，所以默认的提示符就是： [root@localhost ~]# 。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;但设置PS1的时候需要稍微处理一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=<span class="string">"[\\u@\\h \\W]\\$ "</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样显示的结果才是正确的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/7. Linux 密码文件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/7. Linux 密码文件/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.294Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/7. Linux 密码文件/">
        Linux 密码文件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;密码文件 <code>/etc/shadow</code> 和 ·/etc/passwd·，类似，都是 Linux 系统最重要的文件之一，用 <code>：</code> 分割成9个字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># cat /etc/shadow |head -n 3</span></div><div class="line">root:<span class="variable">$6</span><span class="variable">$Wo0kPkgm</span><span class="variable">$OAp0Wl2AsaE4ei4YVbxo3DIU5OBSYxn1y7qxB5Jns70Yk91AvzElsR5GmoGCC8DUXkKzK7vyiV8wXNeaWNm861</span>:15832:0:99999:7:::</div><div class="line">bin:*:15628:0:99999:7:::</div><div class="line">daemon:*:15628:0:99999:7:::</div></pre></td></tr></table></figure>
<h2 id="每个字段的含义"><a href="#每个字段的含义" class="headerlink" title="每个字段的含义"></a>每个字段的含义</h2><h3 id="1-用户名"><a href="#1-用户名" class="headerlink" title="1. 用户名"></a>1. 用户名</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;跟 /etc/passwd 对应。</p>
<h3 id="2-用户密码"><a href="#2-用户密码" class="headerlink" title="2. 用户密码"></a>2. 用户密码</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个才是该帐号真正的密码，不过这个密码已经加密了，但是还是能够解密的。所以该文件属性设置为000，但是 root 账户是可以访问或更改的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># ls -l /etc/shadow</span></div><div class="line">---------- 1 root root 719 5月  10 09:02 /etc/shadow</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root的密码很长，通常以 <code>$6$</code> 开头；<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;“*” 表示账户被 <code>锁定</code><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;“!!” 账户还没有密码<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注意：CentOS 的加密方式就是 sha-512。 <code>$6$ 开头是 sha-512 ；$5$ 开头是 sha-256 ；$1$ 表明是用 MD5 加密。</code> </p>
<h3 id="3-上次更改密码的日期"><a href="#3-上次更改密码的日期" class="headerlink" title="3. 上次更改密码的日期"></a>3. 上次更改密码的日期</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个数字的计算是，距离1970年1月1日到上次更改密码的日期，单位是天。例如上次更改密码的日期为2012年1月1日，则这个值就是 ‘365×(2012-1970)+(2012-1970)÷4+1 = 15341’。因为如果是闰年，则有366天。</p>
<h3 id="4-要过多少天才可以可以更改密码"><a href="#4-要过多少天才可以可以更改密码" class="headerlink" title="4. 要过多少天才可以可以更改密码"></a>4. 要过多少天才可以可以更改密码</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认是0，即不限制。</p>
<h3 id="5-密码多少天后到期"><a href="#5-密码多少天后到期" class="headerlink" title="5. 密码多少天后到期"></a>5. 密码多少天后到期</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;即在多少天内必须更改密码，例如这里设置成30，则30天内必须更改一次密码，否则将不能登录系统，默认是99999，可以理解为永远不需要改。</p>
<h3 id="6-密码到期前的警告期限"><a href="#6-密码到期前的警告期限" class="headerlink" title="6. 密码到期前的警告期限"></a>6. 密码到期前的警告期限</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;若这个值设置成7，则表示当7天后密码过期时，系统就发出告警告诉用户，提醒用户他的密码将在7天后到期。</p>
<h3 id="7-帐号失效期限"><a href="#7-帐号失效期限" class="headerlink" title="7. 帐号失效期限"></a>7. 帐号失效期限</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可以这样理解，如果设置这个值为3，则表示：密码已经到期，然而用户并没有在到期前修改密码，那么再过3天，则这个帐号就失效了，即锁定了。</p>
<h3 id="8-帐号的生命周期"><a href="#8-帐号的生命周期" class="headerlink" title="8. 帐号的生命周期"></a>8. 帐号的生命周期</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;跟第三段一样，是按距离1970年1月1日多少天算的。它表示的含义是，帐号在这个日期前可以使用，到期后帐号作废。</p>
<h3 id="9-作为保留用的"><a href="#9-作为保留用的" class="headerlink" title="9. 作为保留用的"></a>9. 作为保留用的</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;没有什么意义。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/41.Linux环境变量之“PS1”" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/41.Linux环境变量之“PS1”/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.293Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/41.Linux环境变量之“PS1”/">
        Linux环境变量之“PS1”
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PS1（是数字1而不是字母l），每个版本bash的PS1变量内的特殊符号可能有些小的差异，你可以先man bash 一下。下面是FC4环境下默认的特殊符号所代表的意义：</p>
<ul>
<li><p>\d ：代表日期，格式为weekday month date，例如：”Mon Aug 1”</p>
</li>
<li><p>\H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux</p>
</li>
<li><p>\h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略</p>
</li>
<li><p>\t ：显示时间为24小时格式，如：HH：MM：SS</p>
</li>
<li><p>\T ：显示时间为12小时格式</p>
</li>
<li><p>\A ：显示时间为24小时格式：HH：MM</p>
</li>
<li><p>\u ：当前用户的账号名称</p>
</li>
<li><p>\v ：BASH的版本信息</p>
</li>
<li><p>\w ：完整的工作目录名称。家目录会以 ~代替</p>
</li>
<li><p>\W ：利用basename取得工作目录名称，所以只会列出最后一个目录</p>
</li>
<li><p>\# ：下达的第几个命令</p>
</li>
<li><p>\$ ：提示字符，如果是root时，提示符为：#   ，普通用户则为：$</p>
</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认的PS1内容为： ‘[\u@\h \W]\$ ‘ ，所以默认的提示符就是： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># 。</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;但设置PS1的时候需要稍微处理一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=<span class="string">"[\\u@\\h \\W]\\$ "</span>  这样显示的结果才是正确的</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/23. 如何区别NAS.SAN与DAS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/23. 如何区别NAS.SAN与DAS/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.292Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/23. 如何区别NAS.SAN与DAS/">
        如何区别NAS.SAN与DAS
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SAN (Storage Attached Network)，即存储区域网络。为什么写NAS就不得不提到SAN呢?原因之一是它们的名字有69关系，容易混淆;之二是NAS和SAN既竞争又合作，很多高端NAS的后端存储就是SAN。NAS和SAN的整合也是存储设备的发展趋势，比如EMC的新产品VNX系列。右图展示了一台NAS的逻辑结构：双虚线框表示一台NAS。它通过Fibre Channel从后端SAN获得存储空间，创建文件系统后，再通过以太网共享给服务器。SAN提供的存储单位是LUN，属于block级别的。经过NAS创建成文件系统后，就变成文件级别的了。</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%ABNAS.SAN%E4%B8%8EDAS/01.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果上边的逻辑图还不够清楚，可以看看下面的物理连接。NAS通过FC Switch连到SAN上，应用服务器再通过Ethernet Switch连到NAS上。同时SAN也直接提供block级别的存储给应用服务器。</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%ABNAS.SAN%E4%B8%8EDAS/02.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于NAS和SAN的区别，可以列出很多来。比如带宽大小，距离长短，共享优劣等等。几乎所有区别都是由两个因素衍生出来的。一个是FC与Ethernet，另一个是block与file system。简而言之，如果用户需要通过FC访问block，就用SAN;如果需要通过Ethernet访问file system，就用NAS。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;除了NAS和SAN，还有一类存储设备经常被提到。那就是DAS (Direct Attached Storage) ，即“直连存储”。“直连”指服务器和存储设备之间没有FC网络，而是直接相连。比如我们都熟知的个人电脑就是DAS，因为磁盘被直连到了主板上。DAS已经存在很多年了，就算到今天也是很多服务器的理想选择。但是它的问题很多，而且也跟不上IT技术，比如虚拟化的发展。下面列举几个：</p>
<ol>
<li><p>可管理性差：每台服务器都使用自己的存储，光硬件的监控和维护就要花费不少时间。如果都要做容灾或备份，对于管理员简直是噩梦。</p>
</li>
<li><p>可扩展性差：在服务器安装结束后，如果发现存储空间分配过多，就造成了浪费。如果发现空间不足，要扩展也很麻烦。</p>
</li>
<li><p>跟不上IT发展趋势，比如不支持VMware VMotion等高级功能。</p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SAN解决了这些问题。因为它既提供了统一的存储，同时又是一个网络。统一性和网络性给SAN带来了很多优势：</p>
<ol>
<li><p>可管理性：由一台SAN统一给多台服务器提供存储。无论是硬件的监控维护，还是数据的容灾备份，都只要在SAN上进行。使存储管理变得更轻松。</p>
</li>
<li><p>可扩展性：在物理层面，SAN支持数以百计的磁盘(比如EMC的CX4可以支持960块磁盘)，提供了海量的存储空间。在逻辑层面，这个海量空间可以按需要分成不同大小的LUN，再分配给服务器。LUN是逻辑设备，所以很容易扩展或迁移。</p>
</li>
<li><p>符合IT发展趋势：比如对炙手可热的虚拟化有很好的支持。</p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当然，除了解决DAS的这些问题，SAN还有其他明显的优势：</p>
<ol>
<li>高性能:<br>a. SAN 更好的支持RAID，因为它拥有更多硬盘和更强的控制器。下图展示了RAID0对性能提升的基本原理：当有一大块数据写到RAID Group上，它可以被分成数小块，同时写到几个磁盘上。这就象有一批档案需要录入到电脑上，经理一个人打字需要做5天。分给5位员工一起做，一天就可以做完了。</li>
</ol>
<p><img src="https://github.com/hcldirgit/image/blob/master/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%ABNAS.SAN%E4%B8%8EDAS/03.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;b. SAN有更大的cache。比如CX4的write cache可以达到10.7 GB。Cache对性能的提高也有明显的作用。</p>
<ol>
<li><p>更稳定：多机头，热备盘，多路径等机制杜绝了单点故障。</p>
</li>
<li><p>更安全：统一的容灾，备份和远程复制保证了数据的安全性。</p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;此外还有很多新技术，比如VNX的FASTCache和FASTVP。因为主要介绍NAS，SAN就不深入讨论了。</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%ABNAS.SAN%E4%B8%8EDAS/04.jpeg?raw=true" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/54. Linux下使用pmap指令查看进程的内存使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/54. Linux下使用pmap指令查看进程的内存使用/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.291Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/54. Linux下使用pmap指令查看进程的内存使用/">
        Linux下使用pmap指令查看进程的内存使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pmap这个指令是用来查看进程占用的内存及使用地址空间。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常使用的选项为 -d ，如下查看进程 （pid为24030）的内存使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">pmap -d 24030</div><div class="line">24030: /usr/<span class="built_in">local</span>/php/bin/php-cgi --fpm --fpm-config /usr/<span class="built_in">local</span>/php/etc/php-fpm.conf</div><div class="line">Address Kbytes Mode Offset Device Mapping</div><div class="line">0000000000400000 6444 r-x-- 0000000000000000 008:00002 php-cgi</div><div class="line">0000000000c4b000 272 rw--- 000000000064b000 008:00002 php-cgi</div><div class="line">0000000000c8f000 52 rw--- 0000000000c8f000 000:00000 [ anon ]</div><div class="line">00000000059dc000 9572 rw--- 00000000059dc000 000:00000 [ anon ]</div><div class="line">0000003519000000 508 r-x-- 0000000000000000 008:00002 libfreetype.so.6.3.10</div><div class="line">000000351907f000 2048 ----- 000000000007f000 008:00002 libfreetype.so.6.3.10</div><div class="line">中间部分省略</div><div class="line">00002b757df75000 4 rw--- 000000000000a000 008:00002 libnss_files-2.5.so</div><div class="line">00002b757df76000 32768 rw<span class="_">-s</span>- 0000000000000000 000:00008 zero (deleted)</div><div class="line">00002b7580685000 4 rw<span class="_">-s</span>- 0000000000000000 000:00008 zero (deleted)</div><div class="line">00007fff2e126000 476 rwx-- 00007fff2e126000 000:00000 [ stack ]</div><div class="line">00007fff2e19d000 8 rw--- 00007fff2e19d000 000:00000 [ anon ]</div><div class="line">ffffffffff600000 8192 ----- 0000000000000000 000:00000 [ anon ]</div><div class="line">mapped: 139548K writeable/private: 12344K shared: 32772K</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每列的含义如下：</p>
<ul>
<li>Address: 进程所占的地址空间</li>
<li>Kbytes 该虚拟段的大小</li>
<li>Mode 权限：r=read, w=write, x=execute, s=shared, p=private(copy on write)</li>
<li>Mapping: bash 对应的映像文件名.要看的是最后一行的值</li>
<li>mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz</li>
<li>writeable/private  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小      </li>
<li>shared 表示进程和其他进程共享的内存大小</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Linux 会把一些shared libraries 载入到内存中，在pmap 的输出中，这些shared libraries 的名字通常是 lib*.so ,如 libX11.so.6.2.0 。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个 libX11.so.6.2.0 会被很多process load 到自己的运行环境中，同时，ps 输出的RSS 结果中，每个process 都包含了这个libX11.so.6.2.0 ，而事实上它只被load 了一次，如果单纯把ps 的结果相加，这样就重复计算了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;看pmap输出的结果，其实php-cgi 单纯进程所占的内存是这个writeable/private: 12344K</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1. Linux 基础/24. ext4，ext3的特点和区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/1. Linux 基础/24. ext4，ext3的特点和区别/" class="article-date">
  	<time datetime="2017-09-02T17:55:11.289Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/1. Linux 基础/24. ext4，ext3的特点和区别/">
        ext4，ext3的特点和区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。 Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能：</p>
<ol>
<li><p>与 Ext3 兼容。 执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。</p>
</li>
<li><p>更大的文件系统和更大的文件。 较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。</p>
</li>
<li><p>无限数量的子目录。 Ext3 目前只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。</p>
</li>
<li><p>Extents。 Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25,600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率。</p>
</li>
<li><p>多块分配。 当 写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。</p>
</li>
<li><p>延迟分配。 Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。</p>
</li>
<li><p>快速 fsck。 以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。</p>
</li>
<li><p>日志校验。 日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。</p>
</li>
<li><p>“无日志”（No Journaling）模式。 日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。</p>
</li>
<li><p>在线碎片整理。 尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。</p>
</li>
<li><p>inode 相关特性。 Ext4 支持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes）和 inode 保留（inodes reservation）。</p>
</li>
<li><p>持久预分配（Persistent preallocation）。 P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失败。 Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate()），比应用软件自己实现更有效率。</p>
</li>
<li><p>默认启用 barrier。 磁 盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录，若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 “mount -o barrier=0” 命令禁用该特性。）</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/54/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="page-number" href="/page/54/">54</a><span class="page-number current">55</span><a class="page-number" href="/page/56/">56</a><a class="page-number" href="/page/57/">57</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/56/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 失落的乐章
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: ,
		mathjax: ,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



  </div>
</body>
</html>