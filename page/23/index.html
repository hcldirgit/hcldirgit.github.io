<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>失落的乐章</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="失落的乐章的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="失落的乐章">
<meta property="og:url" content="https://hcldirgit.github.io/page/23/index.html">
<meta property="og:site_name" content="失落的乐章">
<meta property="og:description" content="失落的乐章的Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失落的乐章">
<meta name="twitter:description" content="失落的乐章的Blog">
  
    <link rel="alternative" href="/atom.xml" title="失落的乐章" type="application/atom+xml">
  
  
    <link rel="icon" href="https://github.com/hcldirgit/image/blob/master/0.png?raw=true">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">失落的乐章</a></h1>
		</hgroup>

		
		<p class="header-subtitle">技术面前，永远都是学生。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ansible/" style="font-size: 10.42px;">Ansible</a> <a href="/tags/Apache/" style="font-size: 18.33px;">Apache</a> <a href="/tags/Cacti/" style="font-size: 11.67px;">Cacti</a> <a href="/tags/DNS/" style="font-size: 13.33px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/FTP/" style="font-size: 11.25px;">FTP</a> <a href="/tags/Git/" style="font-size: 10.83px;">Git</a> <a href="/tags/HA集群/" style="font-size: 11.67px;">HA集群</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/Jenkins/" style="font-size: 10.42px;">Jenkins</a> <a href="/tags/LAMP/" style="font-size: 19.58px;">LAMP</a> <a href="/tags/LNMP/" style="font-size: 17.08px;">LNMP</a> <a href="/tags/LVS/" style="font-size: 16.67px;">LVS</a> <a href="/tags/Linux/" style="font-size: 19.17px;">Linux</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux安全/" style="font-size: 14.17px;">Linux安全</a> <a href="/tags/Memcached/" style="font-size: 11.25px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 15.42px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nagios/" style="font-size: 11.67px;">Nagios</a> <a href="/tags/Nginx/" style="font-size: 17.92px;">Nginx</a> <a href="/tags/OpenStack/" style="font-size: 11.25px;">OpenStack</a> <a href="/tags/Php/" style="font-size: 14.58px;">Php</a> <a href="/tags/Puppet/" style="font-size: 11.25px;">Puppet</a> <a href="/tags/Python/" style="font-size: 14.58px;">Python</a> <a href="/tags/Redis/" style="font-size: 16.25px;">Redis</a> <a href="/tags/Resin/" style="font-size: 10px;">Resin</a> <a href="/tags/Saltstack/" style="font-size: 10px;">Saltstack</a> <a href="/tags/Samba/" style="font-size: 12.08px;">Samba</a> <a href="/tags/Squid/" style="font-size: 14.58px;">Squid</a> <a href="/tags/Tomcat/" style="font-size: 13.75px;">Tomcat</a> <a href="/tags/Zabbix/" style="font-size: 15.83px;">Zabbix</a> <a href="/tags/haproxy/" style="font-size: 12.5px;">haproxy</a> <a href="/tags/keepalived/" style="font-size: 12.92px;">keepalived</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/shell练习/" style="font-size: 18.75px;">shell练习</a> <a href="/tags/正则表达式/" style="font-size: 12.92px;">正则表达式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">失落的乐章</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">失落的乐章</h1>
			</hgroup>
			
			<p class="header-subtitle">技术面前，永远都是学生。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-MongoDB/10.   Mongodb 3.0 配置身份验证db.createUser()说明" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MongoDB/10.   Mongodb 3.0 配置身份验证db.createUser()说明/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.750Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MongoDB/10.   Mongodb 3.0 配置身份验证db.createUser()说明/">
        Mongodb 3.0 配置身份验证db.createUser()说明
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;创建一个数据库新用户用db.createUser()方法，如果用户存在则返回一个用户重复错误。</p>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createUser(user, writeConcern)</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;user这个文档创建关于用户的身份认证和访问信息；</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;writeConcern这个文档描述保证MongoDB提供写操作的成功报告。</p>
<h3 id="user文档，定义了用户的以下形式-："><a href="#user文档，定义了用户的以下形式-：" class="headerlink" title="user文档，定义了用户的以下形式**："></a>user文档，定义了用户的以下形式**：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; user: <span class="string">"&lt;name&gt;"</span>,</div><div class="line">  <span class="built_in">pwd</span>: <span class="string">"&lt;cleartext password&gt;"</span>,</div><div class="line">  customData: &#123; &lt;any information&gt; &#125;,</div><div class="line">  roles: [</div><div class="line">    &#123; role: <span class="string">"&lt;role&gt;"</span>, db: <span class="string">"&lt;database&gt;"</span> &#125; | <span class="string">"&lt;role&gt;"</span>,</div><div class="line">    ...</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="user文档字段介绍："><a href="#user文档字段介绍：" class="headerlink" title="user文档字段介绍："></a>user文档字段介绍：</h3><ul>
<li>user字段，为新用户的名字；</li>
<li>pwd字段，用户的密码；</li>
<li>cusomData字段，为任意内容，例如可以为用户全名介绍；</li>
<li>roles字段，指定用户的角色，可以用一个空数组给新用户设定空角色；</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在roles字段,可以指定内置角色和用户定义的角色。</p>
<h3 id="Built-In-Roles（内置角色）："><a href="#Built-In-Roles（内置角色）：" class="headerlink" title="Built-In Roles（内置角色）："></a>Built-In Roles（内置角色）：</h3><ol>
<li><p>数据库用户角色：read、readWrite;</p>
</li>
<li><p>数据库管理角色：dbAdmin、dbOwner、userAdmin；</p>
</li>
<li><p>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</p>
</li>
<li><p>备份恢复角色：backup、restore；</p>
</li>
<li><p>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p>
</li>
<li><p>超级用户角色：root  </p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</strong></p>
<ol>
<li>内部角色：__system</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>PS：关于每个角色所拥有的操作权限可以点击上面的内置角色链接查看详情</strong>。</p>
<h3 id="writeConcern文档（官方说明）"><a href="#writeConcern文档（官方说明）" class="headerlink" title="writeConcern文档（官方说明）"></a>writeConcern文档（官方说明）</h3><ul>
<li>w选项：允许的值分别是 1、0、大于1的值、”majority”、<tag set="">；</tag></li>
<li>j选项：确保mongod实例写数据到磁盘上的journal（日志），这可以确保mongd以外关闭不会丢失数据。设置true启用。</li>
<li>wtimeout：指定一个时间限制,以毫秒为单位。wtimeout只适用于w值大于1。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;例如：在products数据库创建用户accountAdmin01，并给该用户admin数据库上clusterAdmin和readAnyDatabase的角色，products数据库上readWrite角色。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use products</div><div class="line">db.createUser( &#123; <span class="string">"user"</span> : <span class="string">"accountAdmin01"</span>,</div><div class="line">                 <span class="string">"pwd"</span>: <span class="string">"cleartext password"</span>,</div><div class="line">                 <span class="string">"customData"</span> : &#123; employeeId: 12345 &#125;,</div><div class="line">                 <span class="string">"roles"</span> : [ &#123; role: <span class="string">"clusterAdmin"</span>, db: <span class="string">"admin"</span> &#125;,</div><div class="line">                             &#123; role: <span class="string">"readAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125;,</div><div class="line">                             <span class="string">"readWrite"</span></div><div class="line">                             ] &#125;,</div><div class="line">               &#123; w: <span class="string">"majority"</span> , wtimeout: 5000 &#125; )</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo -u accountAdmin01 -p yourpassward --authenticationDatabase products</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MongoDB/1. MongoDB 介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/MongoDB/1. MongoDB 介绍/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.749Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/MongoDB/1. MongoDB 介绍/">
        MongoDB 介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是-MongoDB"><a href="#什么是-MongoDB" class="headerlink" title="什么是 MongoDB"></a>什么是 MongoDB</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统，属于NoSQL。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在高负载的情况下，可以添加更多的节点，可以保证服务器性能。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h2 id="和关型数据库对比"><a href="#和关型数据库对比" class="headerlink" title="和关型数据库对比"></a>和关型数据库对比</h2><p><img src="https://github.com/hcldirgit/image/blob/master/MongoDB%20%E4%BB%8B%E7%BB%8D/01.png?raw=true" alt=""></p>
<h2 id="关系型数据库数据结构"><a href="#关系型数据库数据结构" class="headerlink" title="关系型数据库数据结构"></a>关系型数据库数据结构</h2><p><img src="https://github.com/hcldirgit/image/blob/master/MongoDB%20%E4%BB%8B%E7%BB%8D/02.png?raw=true" alt=""></p>
<h2 id="MongoDB-数据结构"><a href="#MongoDB-数据结构" class="headerlink" title="MongoDB 数据结构"></a>MongoDB 数据结构</h2><p><img src="https://github.com/hcldirgit/image/blob/master/MongoDB%20%E4%BB%8B%E7%BB%8D/03.png?raw=true" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/9. nginx 配置优化的几个参数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/9. nginx 配置优化的几个参数/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.746Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/9. nginx 配置优化的几个参数/">
        nginx 配置优化的几个参数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最近在服务器上搞了一些nginx，研究了一下，总结总结。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx配置文件里面需要注意的一些参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker_processes 8</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx要开启的进程数 一般等于cpu的总核数 其实一般情况下开4个或8个就可以了，多了没有太多用</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每个nginx进程消耗的内存10兆的模样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker_cpu_affinity</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;仅适用于Linux，使用该选项可以绑定worker进程和CPU（2.4内核的机器用不<br>了）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;假如是8 cpu 分配如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000</div><div class="line">00100000 01000000 10000000</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx可以使用多个worker进程，原因如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">to use SMP </div><div class="line">to decrease latency when workers blockend on disk I/O </div><div class="line">to <span class="built_in">limit</span> number of connections per process when select()/poll() is</div><div class="line">used </div><div class="line">The worker_processes and worker_connections from the event sections</div><div class="line">allows you to calculate maxclients value: k</div><div class="line">max_clients = worker_processes * worker_connections</div><div class="line">worker_rlimit_nofile 102400;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每个nginx进程打开文件描述符最大数目 配置要和系统的单进程打开文件数一致,linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx调度时分配请求到进程并不是那么的均衡，假如超过会返回502错误。这里写的大一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">use epoll</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx使用了最新的epoll（Linux 2.6内核）和kqueue（freebsd）网络I/O模型，而Apache则使用的是传统的select模型。处理大量的连接的读写，Apache所采用的select网络I/O模型非常低效。在高并发服务器中，轮询I/O是最耗时间的操作 目前Linux下能够承受高并发访问的Squid、Memcached都采用的是epoll网络I/O模型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker_connections 65535;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每个工作进程允许最大的同时连接数 （Maxclient = work_processes *　worker_connections）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keepalive_timeout 75</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;keepalive超时时间</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里需要注意官方的一句话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The parameters can differ from each other. Line Keep-Alive:</div><div class="line">timeout=time understands Mozilla and Konqueror. MSIE itself shuts</div><div class="line">keep-alive connection approximately after 60 seconds.</div><div class="line">client_header_buffer_size 16k</div><div class="line">large_client_header_buffers 4 32k</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;客户请求头缓冲大小 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。如果设置过小HTTP头/Cookie过大 会报400 错误 nginx 400 bad request。求行如果超过buffer，就会报HTTP 414错误(URI Too Long)。nginx接受最长的HTTP头部大小必须比其中一个buffer大，否则就会报400的HTTP错误(Bad Request)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_file_cache max 102400</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用字段:http, server, location 这个指令指定缓存是否启用,如果启用,将记录文件以下信息: 打开的文件描述符,大小信息和修改时间；存在的目录信息；在搜索文件过程中的错误信息； – 没有这个文件,无法正确读取,参考open_file_cache_errors 指令选项:</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max - 指定缓存的最大数目,如果缓存溢出,最长使用过的文件(LRU)将被移除</p>
<p>例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open_file_cache max=1000 inactive=20s;</div><div class="line">open_file_cache_valid 30s; </div><div class="line">open_file_cache_min_uses 2; </div><div class="line">open_file_cache_errors on;</div><div class="line">open_file_cache_errors</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_file_cache_errors on | off</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;open_file_cache_min_uses</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_file_cache_min_uses number</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如 果使用更大的值,文件描述符在cache中总是打开状态.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;open_file_cache_valid</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_file_cache_valid time</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开启gzip</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_buffers 4 16k;</div><div class="line">gzip_http_version 1.0;</div><div class="line">gzip_comp_level 2;</div><div class="line">gzip_types text/plain application/x-JavaScript text/css</div><div class="line">application/xml;</div><div class="line">gzip_vary on;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;缓存静态文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location ~* ^.+\.(swf|gif|png|jpg|js|css)$ &#123;</div><div class="line">root /usr/<span class="built_in">local</span>/ku6/ktv/show.ku6.com/;</div><div class="line">expires 1m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;优化Linux内核参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysctl.conf</div><div class="line">　　</div><div class="line"><span class="comment"># Add</span></div><div class="line">net.ipv4.tcp_max_syn_backlog = 65536</div><div class="line">net.core.netdev_max_backlog = 32768</div><div class="line">net.core.somaxconn = 32768</div><div class="line">net.core.wmem_default = 8388608</div><div class="line">net.core.rmem_default = 8388608</div><div class="line">net.core.rmem_max = 16777216</div><div class="line">net.core.wmem_max = 16777216</div><div class="line">net.ipv4.tcp_timestamps = 0</div><div class="line">net.ipv4.tcp_synack_retries = 2</div><div class="line">net.ipv4.tcp_syn_retries = 2</div><div class="line">net.ipv4.tcp_tw_recycle = 1</div><div class="line"><span class="comment">#net.ipv4.tcp_tw_len = 1</span></div><div class="line">net.ipv4.tcp_tw_reuse = 1</div><div class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</div><div class="line">net.ipv4.tcp_max_orphans = 3276800</div><div class="line"><span class="comment">#net.ipv4.tcp_fin_timeout = 30</span></div><div class="line"><span class="comment">#net.ipv4.tcp_keepalive_time = 120</span></div><div class="line">net.ipv4.ip_local_port_range = 1024 65535</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;附录：一些错误排查</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP-cgi进程数不够用、php执行时间长（MySQL慢）、或者是php-cgi进程死掉，都会出现502错误</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一般来说Nginx 502 Bad Gateway和php-fpm.conf的设置有关，而Nginx 504 Gateway Time-out则是与nginx.conf的设置有关</p>
<ol>
<li>查看当前的PHP FastCGI进程数是否够用：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -anpo | grep <span class="string">"php-cgi"</span> | wc -l</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果实际使用的“FastCGI进程数”接近预设的“FastCGI进程数”，那么，说明“FastCGI进程数”不够用，需要增大。</p>
<ol>
<li>部分PHP程序的执行时间超过了Nginx的等待时间，可以适当增加nginx.conf配置文件中FastCGI的timeout时间，例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http </div><div class="line">&#123;</div><div class="line">......</div><div class="line">fastcgi_connect_timeout 300;</div><div class="line">fastcgi_send_timeout 300;</div><div class="line">fastcgi_read_timeout 300;</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;413 Request Entity Too Large</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;增大client_max_body_size</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;client_max_body_size:指令指定允许客户端连接的最大请求实体大小,它出现在请求头部的Content-Length字段. 如果请求大于指定的值,客户端将收到一个”Request Entity Too Large” (413)错误. 记住,浏览器并不知道怎样显示这个错误.</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;php.ini中增大post_max_size 和upload_max_filesize</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/8. Nginx配置文件nginx.conf中文详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/8. Nginx配置文件nginx.conf中文详解/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.745Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/8. Nginx配置文件nginx.conf中文详解/">
        Nginx配置文件nginx.conf中文详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></div><div class="line">user www www;</div><div class="line"><span class="comment">#nginx进程数，建议设置为等于CPU总核心数。</span></div><div class="line">worker_processes 8;</div><div class="line"><span class="comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></div><div class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log info;</div><div class="line"><span class="comment">#进程文件</span></div><div class="line">pid /var/run/nginx.pid;</div><div class="line"><span class="comment">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span></div><div class="line">worker_rlimit_nofile 65535;</div><div class="line"><span class="comment">#工作模式与连接数上限</span></div><div class="line">events</div><div class="line">&#123;</div><div class="line"><span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span></div><div class="line">use epoll;</div><div class="line"><span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span></div><div class="line">worker_connections 65535;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#设定http服务器</span></div><div class="line">http</div><div class="line">&#123;</div><div class="line">include mime.types; <span class="comment">#文件扩展名与文件类型映射表</span></div><div class="line">default_type application/octet-stream; <span class="comment">#默认文件类型</span></div><div class="line"><span class="comment">#charset utf-8; #默认编码</span></div><div class="line">server_names_hash_bucket_size 128; <span class="comment">#服务器名字的hash表大小</span></div><div class="line">client_header_buffer_size 32k; <span class="comment">#上传文件大小限制</span></div><div class="line">large_client_header_buffers 4 64k; <span class="comment">#设定请求缓</span></div><div class="line">client_max_body_size 8m; <span class="comment">#设定请求缓</span></div><div class="line">sendfile on; <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></div><div class="line">autoindex on; <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></div><div class="line">tcp_nopush on; <span class="comment">#防止网络阻塞</span></div><div class="line">tcp_nodelay on; <span class="comment">#防止网络阻塞</span></div><div class="line">keepalive_timeout 120; <span class="comment">#长连接超时时间，单位是秒</span></div><div class="line"><span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></div><div class="line">fastcgi_connect_timeout 300;</div><div class="line">fastcgi_send_timeout 300;</div><div class="line">fastcgi_read_timeout 300;</div><div class="line">fastcgi_buffer_size 64k;</div><div class="line">fastcgi_buffers 4 64k;</div><div class="line">fastcgi_busy_buffers_size 128k;</div><div class="line">fastcgi_temp_file_write_size 128k;</div><div class="line"><span class="comment">#gzip模块设置</span></div><div class="line">gzip on; <span class="comment">#开启gzip压缩输出</span></div><div class="line">gzip_min_length 1k; <span class="comment">#最小压缩文件大小</span></div><div class="line">gzip_buffers 4 16k; <span class="comment">#压缩缓冲区</span></div><div class="line">gzip_http_version 1.0; <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></div><div class="line">gzip_comp_level 2; <span class="comment">#压缩等级</span></div><div class="line">gzip_types text/plain application/x-javascript text/css application/xml;</div><div class="line"><span class="comment">#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></div><div class="line">gzip_vary on;</div><div class="line"><span class="comment">#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span></div><div class="line">upstream blog.ha97.com &#123;</div><div class="line"><span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></div><div class="line">server 192.168.80.121:80 weight=3;</div><div class="line">server 192.168.80.122:80 weight=2;</div><div class="line">server 192.168.80.123:80 weight=3;</div><div class="line">&#125;</div><div class="line"><span class="comment">#虚拟主机的配置</span></div><div class="line">server</div><div class="line">&#123;</div><div class="line"><span class="comment">#监听端口</span></div><div class="line">listen 80;</div><div class="line"><span class="comment">#域名可以有多个，用空格隔开</span></div><div class="line">server_name www.ha97.com ha97.com;</div><div class="line">index index.html index.htm index.php;</div><div class="line">root /data/www/ha97;</div><div class="line">location ~ .*\.(php|php5)?$</div><div class="line">&#123;</div><div class="line">fastcgi_pass 127.0.0.1:9000;</div><div class="line">fastcgi_index index.php;</div><div class="line">include fastcgi.conf;</div><div class="line">&#125;</div><div class="line"><span class="comment">#图片缓存时间设置</span></div><div class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</div><div class="line">&#123;</div><div class="line">expires 10d;</div><div class="line">&#125;</div><div class="line"><span class="comment">#JS和CSS缓存时间设置</span></div><div class="line">location ~ .*\.(js|css)?$</div><div class="line">&#123;</div><div class="line">expires 1h;</div><div class="line">&#125;</div><div class="line"><span class="comment">#日志格式设定</span></div><div class="line">log_format access <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line"><span class="string">'$status $body_bytes_sent "$http_referer" '</span></div><div class="line"><span class="string">'"$http_user_agent" $http_x_forwarded_for'</span>;</div><div class="line"><span class="comment">#定义本虚拟主机的访问日志</span></div><div class="line">access_log /var/<span class="built_in">log</span>/nginx/ha97access.log access;</div><div class="line"><span class="comment">#对 "/" 启用反向代理</span></div><div class="line">location / &#123;</div><div class="line">proxy_pass http://127.0.0.1:88;</div><div class="line">proxy_redirect off;</div><div class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line"><span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></div><div class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line"><span class="comment">#以下是一些反向代理的配置，可选。</span></div><div class="line">proxy_set_header Host <span class="variable">$host</span>;</div><div class="line">client_max_body_size 10m; <span class="comment">#允许客户端请求的最大单文件字节数</span></div><div class="line">client_body_buffer_size 128k; <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></div><div class="line">proxy_connect_timeout 90; <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></div><div class="line">proxy_send_timeout 90; <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></div><div class="line">proxy_read_timeout 90; <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></div><div class="line">proxy_buffer_size 4k; <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></div><div class="line">proxy_buffers 4 32k; <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></div><div class="line">proxy_busy_buffers_size 64k; <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></div><div class="line">proxy_temp_file_write_size 64k;</div><div class="line"><span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></div><div class="line">&#125;</div><div class="line"><span class="comment">#设定查看Nginx状态的地址</span></div><div class="line">location /NginxStatus &#123;</div><div class="line">stub_status on;</div><div class="line">access_log on;</div><div class="line">auth_basic <span class="string">"NginxStatus"</span>;</div><div class="line">auth_basic_user_file conf/htpasswd;</div><div class="line"><span class="comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span></div><div class="line">&#125;</div><div class="line"><span class="comment">#本地动静分离反向代理配置</span></div><div class="line"><span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></div><div class="line">location ~ .(jsp|jspx|<span class="keyword">do</span>)?$ &#123;</div><div class="line">proxy_set_header Host <span class="variable">$host</span>;</div><div class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">proxy_pass http://127.0.0.1:8080;</div><div class="line">&#125;</div><div class="line"><span class="comment">#所有静态文件由nginx直接读取不经过tomcat或resin</span></div><div class="line">location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$</div><div class="line">&#123; expires 15d; &#125;</div><div class="line">location ~ .*.(js|css)?$</div><div class="line">&#123; expires 1h; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/6. 概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/6. 概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.744Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/6. 概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM/">
        概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。</p>
<h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 模式）。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。</p>
<h3 id="FastCGI特点"><a href="#FastCGI特点" class="headerlink" title="FastCGI特点"></a>FastCGI特点</h3><ol>
<li>FastCGI具有语言无关性.<ol>
<li>FastCGI在进程中的应用程序，独立于核心web服务器运行，提供了一个比API更安全的环境。APIs把应用程序的代码与核心的web服务器链接在一起，这意味着在一个错误的API的应用程序可能会损坏其他应用程序或核心服务器。 恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥。</li>
<li>FastCGI技术目前支持语言有：C/C++、Java、Perl、Tcl、Python、SmallTalk、Ruby等。相关模块在Apache, ISS, Lighttpd等流行的服务器上也是可用的。</li>
<li>FastCGI的不依赖于任何Web服务器的内部架构，因此即使服务器技术的变化, FastCGI依然稳定不变。</li>
</ol>
</li>
</ol>
<h3 id="FastCGI的工作原理"><a href="#FastCGI的工作原理" class="headerlink" title="FastCGI的工作原理"></a>FastCGI的工作原理</h3><ol>
<li>Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</li>
<li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li>
<li>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li>
<li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p>
<h3 id="FastCGI的不足"><a href="#FastCGI的不足" class="headerlink" title="FastCGI的不足"></a>FastCGI的不足</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M<em>10=150M），开启的64个php-cgi进程消耗1280M内存  （20M</em>64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存 较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)</p>
<h2 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP-CGI是PHP自带的FastCGI管理器。</p>
<h3 id="PHP-CGI的不足："><a href="#PHP-CGI的不足：" class="headerlink" title="PHP-CGI的不足："></a>PHP-CGI的不足：</h3><ol>
<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。</li>
<li>直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）</li>
</ol>
<h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的，可以<a href="http://php-fpm.org/download" target="_blank" rel="external">下载</a>下载得到。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;现在我们可以在最新的PHP 5.3.2的源码树里下载得到直接整合了PHP-FPM的分支，据说下个版本会融合进PHP的主分支去。相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p>
<h2 id="Spawn-FCGI"><a href="#Spawn-FCGI" class="headerlink" title="Spawn-FCGI"></a>Spawn-FCGI</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作，不过有不少缺点。而PHP-FPM的出现多少缓解了一些问题，但PHP-FPM有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险(refer)，在php 5.3.3中可以直接使用PHP-FPM了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Spawn-FCGI目前已经独成为一个项目，更加稳定一些，也给很多Web 站点的配置带来便利。已经有不少站点将它与nginx搭配来解决动态网页。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最新的<a href="http://www.lighttpd.net" target="_blank" rel="external">lighttpd</a>也没有包含这一块了，但可以在以前版本中找到它。在<a href="http://www.lighttpd.net/download/lighttpd-1.4.15.tar.gz" target="_blank" rel="external">lighttpd-1.4.15版本</a>中就包含了 ，<a href="http://redmine.lighttpd.net/projects/spawn-fcgi" target="_blank" rel="external">Spawn-FCGI的下 载地址</a>，<a href="http://www.lighttpd.net/download/spawn-fcgi-1.6.3.tar.gz" target="_blank" rel="external">最新版本Spawn-FCGI的下 载地址</a>。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：最新的Spawn-FCGI可以到lighttpd.net网站搜索“Spawn-FCGI”找到它的最新版本发布地址。</p>
<h2 id="PHP-FPM与spawn-CGI对比"><a href="#PHP-FPM与spawn-CGI对比" class="headerlink" title="PHP-FPM与spawn-CGI对比"></a>PHP-FPM与spawn-CGI对比</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PHP-FPM的使用非常方便，配置都是在PHP-FPM.ini的文件内，而启动、重启都可以从php/sbin/PHP-FPM中进行。更方便的是修改php.ini后可以直接使用PHP-FPM reload进行加载，无需杀掉进程就可以完成php.ini的修改加载</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;结果显示使用PHP-FPM可以使php有不小的性能提升。PHP-FPM控制的进程cpu回收的速度比较慢,内存分配的很均匀。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Spawn-FCGI控制的进程CPU下降的很快，而内存分配的比较不均匀。有很多进程似乎未分配到，而另外一些却占用很高。可能是由于进程任务分配的不均匀导致的。而这也导致了总体响应速度的下降。而PHP-FPM合理的分配，导致总体响应的提到以及任务的平均。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/7. nginx启动脚本和配置文件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/7. nginx启动脚本和配置文件/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.744Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/7. nginx启动脚本和配置文件/">
        nginx启动脚本和配置文件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>编写 nginx 启动脚本，并加入系统服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/init.d/nginx</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;写入内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># chkconfig: - 30 21</span></div><div class="line"><span class="comment"># description: http service.</span></div><div class="line"><span class="comment"># Source Function Library</span></div><div class="line">. /etc/init.d/<span class="built_in">functions</span></div><div class="line"><span class="comment"># Nginx Settings</span></div><div class="line"></div><div class="line">NGINX_SBIN=<span class="string">"/usr/local/nginx/sbin/nginx"</span></div><div class="line">NGINX_CONF=<span class="string">"/usr/local/nginx/conf/nginx.conf"</span></div><div class="line">NGINX_PID=<span class="string">"/usr/local/nginx/logs/nginx.pid"</span></div><div class="line">RETVAL=0</div><div class="line">prog=<span class="string">"Nginx"</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">        <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span></div><div class="line">        mkdir -p /dev/shm/nginx_temp</div><div class="line">        daemon <span class="variable">$NGINX_SBIN</span> -c <span class="variable">$NGINX_CONF</span></div><div class="line">        RETVAL=$?</div><div class="line">        <span class="built_in">echo</span></div><div class="line">        <span class="built_in">return</span> <span class="variable">$RETVAL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">        <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span></div><div class="line">        killproc -p <span class="variable">$NGINX_PID</span> <span class="variable">$NGINX_SBIN</span> -TERM</div><div class="line">        rm -rf /dev/shm/nginx_temp</div><div class="line">        RETVAL=$?</div><div class="line">        <span class="built_in">echo</span></div><div class="line">        <span class="built_in">return</span> <span class="variable">$RETVAL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">reload</span></span>()&#123;</div><div class="line">        <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span></div><div class="line">        killproc -p <span class="variable">$NGINX_PID</span> <span class="variable">$NGINX_SBIN</span> -HUP</div><div class="line">        RETVAL=$?</div><div class="line">        <span class="built_in">echo</span></div><div class="line">        <span class="built_in">return</span> <span class="variable">$RETVAL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">restart</span></span>()&#123;</div><div class="line">        stop</div><div class="line">        start</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">configtest</span></span>()&#123;</div><div class="line">    <span class="variable">$NGINX_SBIN</span> -c <span class="variable">$NGINX_CONF</span> -t</div><div class="line">    <span class="built_in">return</span> 0</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">        start</div><div class="line">        ;;</div><div class="line">  stop)</div><div class="line">        stop</div><div class="line">        ;;</div><div class="line">  reload)</div><div class="line">        reload</div><div class="line">        ;;</div><div class="line">  restart)</div><div class="line">        restart</div><div class="line">        ;;</div><div class="line">  configtest)</div><div class="line">        configtest</div><div class="line">        ;;</div><div class="line">  *)</div><div class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|reload|restart|configtest&#125;"</span></div><div class="line">        RETVAL=1</div><div class="line"><span class="keyword">esac</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> <span class="variable">$RETVAL</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说明：该启动脚本来自互联网。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存后，更改权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 755 /etc/init.d/nginx</div><div class="line">chkconfig --add nginx</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果需要开机启动，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig nginx on</div></pre></td></tr></table></figure>
<ol>
<li>更改 nginx 配置</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先把原来的配置文件清空</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;“&gt;”这个符号为重定向的意思，单独用它，可以把一个文本文档快速清空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">user nobody nobody;</div><div class="line">worker_processes 2;</div><div class="line">error_log /usr/<span class="built_in">local</span>/nginx/logs/nginx_error.log crit;</div><div class="line">pid /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid;</div><div class="line">worker_rlimit_nofile 51200;</div><div class="line"></div><div class="line">events</div><div class="line">&#123;</div><div class="line">    use epoll;</div><div class="line">    worker_connections 6000;</div><div class="line">&#125;</div><div class="line"></div><div class="line">http</div><div class="line">&#123;</div><div class="line">    include mime.types;</div><div class="line">    default_type application/octet-stream;</div><div class="line">    server_names_hash_bucket_size 3526;</div><div class="line">    server_names_hash_max_size 4096;</div><div class="line">    log_format combined_realip <span class="string">'$remote_addr $http_x_forwarded_for [$time_local]'</span></div><div class="line">    <span class="string">'$host "$request_uri" $status'</span></div><div class="line">    <span class="string">'"$http_referer" "$http_user_agent"'</span>;</div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    keepalive_timeout 30;</div><div class="line">    client_header_timeout 3m;</div><div class="line">    client_body_timeout 3m;</div><div class="line">    send_timeout 3m;</div><div class="line">    connection_pool_size 256;</div><div class="line">    client_header_buffer_size 1k;</div><div class="line">    large_client_header_buffers 8 4k;</div><div class="line">    request_pool_size 4k;</div><div class="line">    output_buffers 4 32k;</div><div class="line">    postpone_output 1460;</div><div class="line">    client_max_body_size 10m;</div><div class="line">    client_body_buffer_size 256k;</div><div class="line">    client_body_temp_path /usr/<span class="built_in">local</span>/nginx/client_body_temp;</div><div class="line">    proxy_temp_path /usr/<span class="built_in">local</span>/nginx/proxy_temp;</div><div class="line">    fastcgi_temp_path /usr/<span class="built_in">local</span>/nginx/fastcgi_temp;</div><div class="line">    fastcgi_intercept_errors on;</div><div class="line">    tcp_nodelay on;</div><div class="line">    gzip on;</div><div class="line">    gzip_min_length 1k;</div><div class="line">    gzip_buffers 4 8k;</div><div class="line">    gzip_comp_level 5;</div><div class="line">    gzip_http_version 1.1;</div><div class="line">    gzip_types text/plain application/x-javascript text/css text/htm application/xml;</div><div class="line"></div><div class="line">server</div><div class="line">&#123;</div><div class="line">    listen 80;</div><div class="line">    server_name localhost;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /usr/<span class="built_in">local</span>/nginx/html;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">        include fastcgi_params;</div><div class="line">        fastcgi_pass unix:/tmp/php-fcgi.sock;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME /usr/<span class="built_in">local</span>/nginx/html<span class="variable">$fastcgi_script_name</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">include /usr/<span class="built_in">local</span>/nginx/conf/vhosts/*.conf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说明：该配置文件可以作为一个模版，可以用虚拟机服务器上，工作中也可以参考</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nginx 的虚拟主机配置文件放在 <code>/usr/local/nginx/conf/vhosts</code> 下边，该部分配置改为<code>include /usr/local/nginx/conf/vhosts/*.conf</code>;</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存配置后，先检验一下配置文件是否有错误存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果显示内容如下，则配置正确，否则需要根据错误提示修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nginx: the configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf <span class="built_in">test</span> is successful</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;重启 nginx 服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service nginx restart</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;apache 有一个默认虚拟主机，也就是说无论什么域名只要指向到这台机器都会访问到这个虚拟主机。其实，在 nginx 里面也有一个这样的默认虚拟主机，但它有一个配置可以用来标记哪个虚拟主机是默认的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/<span class="built_in">local</span>/nginx/conf/vhost</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf/vhost</div><div class="line">vim defaule.conf</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;加入配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">&#123;</div><div class="line">    listen 80 default_server;</div><div class="line">    server_name localhost;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /tmp/tmp;</div><div class="line">    deny all;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说明：在之前的 nginx.conf 中就已经定义了 include 语句，意思是它会包含一些配置，在这里它会把 /usr/local/nginx/conf/vhosts/ 目录下的所有 *.conf 文件加载。所以，在这个目录下定义了一个 default.conf 文件，在这里会发现 listen 80 后面还有一个关键词叫做 “default_server”，这个就是用来标记它是默认虚拟主机的。使用 deny all 限制了该虚拟主机禁止被任何人访问。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;创建默认主机下定义的文件夹，不然会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir /tmp/tmp</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果有新的虚拟主机如 123.com 则编辑配置文件 123.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim 123.conf</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;加入内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">&#123;</div><div class="line">    listen 80;</div><div class="line">    server_name 123.com;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /data/www;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">        include fastcgi_params;</div><div class="line">        fastcgi_pass unix:/tmp/php-fcgi.sock;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME /data/www<span class="variable">$fastcgi_script_name</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;查看监听端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -lnp</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;监听的是 ip+prot 的形式，所以配置文件需要更改为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">&#123;</div><div class="line">    listen 80;</div><div class="line">    server_name 123.com;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /data/www;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">        include fastcgi_params;</div><div class="line">        <span class="comment">#fastcgi_pass unix:/tmp/php-fcgi.sock;</span></div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME /data/www<span class="variable">$fastcgi_script_name</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/5. mod_php和mod_fastcgi和php-fpm的介绍,对比,和性能数据" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/5. mod_php和mod_fastcgi和php-fpm的介绍,对比,和性能数据/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.743Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/5. mod_php和mod_fastcgi和php-fpm的介绍,对比,和性能数据/">
        mod_php和mod_fastcgi和php-fpm的介绍,对比,和性能数据
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是mod-php和mod-fastcgi"><a href="#什么是mod-php和mod-fastcgi" class="headerlink" title="什么是mod_php和mod_fastcgi"></a>什么是mod_php和mod_fastcgi</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在lamp体系中，对于apache端php的配置，我们最常用的就是mod_php, 它把PHP做为APACHE一个内置模块。让apache http服务器本身能够支持PHP语言，不需要每一个请求就启动PHP解释器来解释PHP。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;和把webserver与php绑定起来的方式不同，fastcgi是HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，相当于一个程序接口。它可以接受来自web服务器的请求，解释输入信息，将处理后的结果返回给服务器(apache,lighty等)。mod_fastcgi就是在apache下支持fastcgi协议的模块。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在介绍这两种模式的工作原理前，我们先了解一下php的架构 </p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/01.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上面是php的架构图，从图上可以看到， SAPI提供了一个和外部通信的接口，使得PHP可以和其他应用进行交互数据。php默认提供了很多种SAPI，常见的给apache的mod_php5，CGI，给IIS的ISAPI，还有Shell的CLI。对于一个基于apache的php应用，其运行流程可以简单归结如下 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>apache -&gt; httpd -&gt; mod_phpfastcgi -&gt; sapi -&gt; php</strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面提到的两种工作方式就分别用到了mod_php5和cgi的sapi。  </p>
<h2 id="mod-php"><a href="#mod-php" class="headerlink" title="mod_php"></a>mod_php</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; mod_php是在lamp体系中最常使用的工作方式，在这种模式下，php被编译为apache的一个内置模块，在启动时加载。当有一个php请求过来时，直接在httpd进程里完成php的解释运行，将结果返回。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在php的sapi中，有这样一个函数: sapi_cgibin_ub_write, 这个函数告诉了Zend，如何输出数据。查看mod_php的sapi源码，我们会发现，这个函数直接调用了apache的ap_rwrite函数。所以，用mod_php，我们可以把php和apache看做一个模块，两者绑定在一起。其工作原理如下图所示</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/02.png?raw=true" alt=""></p>
<h2 id="mod-fastcgi"><a href="#mod-fastcgi" class="headerlink" title="mod_fastcgi"></a>mod_fastcgi</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在说明fastcgi之前，先了解一下普通cgi的工作流程： </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;web server收到用户请求，并把请求提交给cgi程序，cgi程序根据请求提交的参数作应处理，然后输出标准的html语句返回给web server，web server再返回给客户端，这就是普通cgi的工作原理。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fastcgi是基于cgi架构的扩展，他的核心思想就是在web server和具体cgi程序之间建立一个智能的可持续的中间层，统管cgi程序的运行，这样web server只需要将请求提交给这个层，这个层再派生出几个可复用的cgi程序实例，然后再把请求分发给这些实例，这些实例是可控的，可持续，可复用的， 因此一方面避免了进程反复fork，另一方面又可以通过中间层的控制和探测机制来监视这些实例的运行情况，根据不同的状况fork或者回收实例，达到灵活 性和稳定性兼得的目的。modFastCGI的主要优点是把动态语言和web server分离开来。这种技术允许把web server和动态语言运行在不同的主机上，以大规模扩展和改进安全性而不损失生产效率。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;基于mod_fastcgi方式的php应用，其典型工作流程如下 </p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/03.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从图上可以看出， apache启动后，mod_fastcgi会在启动多个cgi程序，也就是php-cgi脚本。具体脚本的数目通过配置来指定。当有http请求到来后，httpd进程会选择一个当前空闲的一个php-cgi程序来执行，执行的方式和mod_php类似，也是通过php-cgi提供的sapi完成交互。查看源码，可以发现对于cgi的sapi，和mod_php不同，它是把结果输出到fastcgi提供的stdout上，fastcgi再将数据返回给httpd完成交互。 </p>
<h2 id="mod-factcgi的三种配置方式"><a href="#mod-factcgi的三种配置方式" class="headerlink" title="mod_factcgi的三种配置方式"></a>mod_factcgi的三种配置方式</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;基于mod_fastcgi的fastcgi应用一共有三种配置方式：静态、动态和远程。他们通过apache配置中的伪指令来代替，对应于三种方式的伪指令分别是FastCgiServer, FastCgiConfig, 以及FastCgiExternalServer。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于静态和动态这两种方式，apache将通过mod_fastcgi自带的进程管理工具(fcgi-pm)来管理fastcgi应用程序，也就是php-cgi。fcgi-pm在apache启动时就被自动激活了。相对于前两种，远程模式下，php-cgi不由fcgi-pm来管理，apache不会去关心php-cgi程序的状态。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面详细说一下三种配置方式 </p>
<h3 id="静态配置"><a href="#静态配置" class="headerlink" title="静态配置"></a>静态配置</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过FastCGIServer 伪指令将文件名定义为静态 FastCGI 应用程序。初始时需要指定启动的php-cgi进程数目，默认为1个。apache运行过程中，如果静态应用程序实例因为任何原因死了，那么fcgi-pm将衍生另一个实例来替换。 </p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FastCgiServer file name [options]</div></pre></td></tr></table></figure>
<h4 id="重要参数说明"><a href="#重要参数说明" class="headerlink" title="重要参数说明"></a>重要参数说明</h4><ul>
<li><strong>idle-timeout n</strong>（30 秒）。在请求异常终止和事件记录在 error LogLevel 前，所允许的 FastCGI 应用程序不活动秒数。仅当存在与 FastCGI 应用程序的暂挂连接时，该不活动计时器才应用。如果应用程序在此期间不响应队列的请求，那么请求异常终止。如果与应用程序的通信完成，但是与客户机的通信未完成（缓存的响应），那么超时不应用。  </li>
<li><strong>processes n</strong>（1）。在服务器初始化时衍生的应用程序实例数。 </li>
<li><strong>port n</strong> 无。应用程序用于与 Web 服务器通信的 TCP 端口号（1-65535）。此选项使应用程序可以从网络中的其他机器访问。-socket 选项和 -port 选项是互斥的。 </li>
<li><strong>socket</strong> filename unix sock文件名  </li>
<li><strong>Restart-delay</strong> n（5 秒）。此应用程序的失败实例重新衍生之间的最小秒数。此延迟阻止中断的应用程序使用过多系统资源。 </li>
</ul>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在静态配置中，我们初始就指定了要启动的php进程数。和静态的相反，动态应用程序根据需求启动。php应用实例的数目根据当前http请求数目动态变化，进程的管理也是通过fcgi-pm来完成。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FastCgiConfig option [option ...]</div></pre></td></tr></table></figure>
<h4 id="重要参数说明-1"><a href="#重要参数说明-1" class="headerlink" title="重要参数说明"></a>重要参数说明</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;和静态方式相比，动态配置的参数主要增加了以下几个 </p>
<ul>
<li><strong>maxProcesses n</strong>  在任何时候允许运行的最大动态 FastCGI 应用程序实例数。 </li>
<li><strong>minProcesses n</strong> 任何时候允许运行，且无须由fcgi-pm（因没有需求）杀死的最小动态 FastCGI 应用程序实例数。  </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在dyn模式下，因为fastcgi实例数目是动态改变的。所以没有静态方式中process这个参数 </p>
<h3 id="远程方式"><a href="#远程方式" class="headerlink" title="远程方式"></a>远程方式</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这种模式下，fastcgi实例和apache分离开来，这两者可以分开来部署。他们之间的通信通过tcp或者unix sock来完成。使用ext方式，fastcgi实例将不会由fcgi-pm来管理，而是独立的运行。 </p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FastCgiExternalServer 文件名 -host 主机名端口 [-appConnTimeout n] </div><div class="line">FastCgiExternalServer 文件名 -socket 文件名 [-appConnTimeout n]</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;重要参数说明 </p>
<ul>
<li><strong>idle-timeout n</strong> （30 秒） 在请求异常终止，并且事件记录之前，允许 FastCGI 应用程序保持不活动的秒数。只有当与 FastCGI 应用程序的连接暂挂时，此不活动定时器才适用。如果请求进入应用程序的请求队列，而此应用程序在此期间没有响应（通过写和刷新），则此请求将异常终止。如果与应用程序的通信已完成，而与客户机的通信尚未完成（响应被高速缓存），则此超时不适用。 </li>
<li><strong>host host:port</strong> 应用程序用于与 Web 服务器通信的主机名或 IP 地址和 TCP 端口号 (1-65535)。-socket 和 -host 选项是互斥的。  </li>
<li><strong>socket</strong> 文件名 无 </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;应用程序用于与 Web 服务器通信的 UNIX 域套接字的文件名。此文件名相对于 FastCgiIpcDir。-socket 和 -port 选项是互斥的。 </p>
<h2 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用FastCGI，最主要优点是把应用和web server(apache)分离开来。这样允许把web server和动态语言(php)运行在不同的主机上，以大规模扩展和改进安全性而不损失效率。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样的情况下，对于php-cgi程序，由于从apache中分离出来，就需要一个单独的工具来对这些进程进行管理，在stc和dyn两种模式下，mod_fastcgi中自带的fcgi-pm会充当了这样的角色。可是，ext模式下却没有。我们只能通过一个脚本静态的启动n个实例，一旦进程死掉，还需要手工重启。当然，你可以使用supervise来管理这些进程，但是毕竟不那么灵活而且也仅仅一部份问题。甚至于fcgi-pm，因为实现的原因，其本身也有很多问题，例如不太稳定，压力下出core，无法平滑的完成切换等。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;基于上述的原因，我们需要一个稳定可靠的进程管理工具，就像lighty下的spwn-cgi。幸运的是，出现了php-fpm。它是一个类似于spwn-cgi的管理工具，可以和任何支持远端FastCGI的web server工作。在官方的手册上，列举了以下php-fpm所具有的特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Php自带的</th>
<th>Spwn-cgi</th>
<th>Php-fpm</th>
</tr>
</thead>
<tbody>
<tr>
<td>php守护程序： pid file, log file, setsid(), setuid(), setgid(), chroot()</td>
<td>(-)</td>
<td>(-)</td>
<td>(+) </td>
</tr>
<tr>
<td>进程控制，可以平滑地重启、重新载入配置和二进制模块而不丢失请求</td>
<td>Php4 (-) Php5 只能平滑停止</td>
<td>(-)</td>
<td>(+)</td>
</tr>
<tr>
<td>限制ip地址，可以满足web server的要求</td>
<td>php4 (-) php5.2.2 &gt; (+)</td>
<td>(-)</td>
<td>(+)</td>
</tr>
<tr>
<td>如果使用优化器，在遇到opcode缓存随机损坏的时候紧急重启所有进程</td>
<td>(-)</td>
<td>(-)</td>
<td>(+)</td>
</tr>
<tr>
<td>使用用不同的uid / gid / chroot / 环境变量，不同的 php.ini 选项，不需要safe mode</td>
<td>(-)</td>
<td>(-)</td>
<td>(+)</td>
<td></td>
</tr>
<tr>
<td>记录work process的stdout和stderr</td>
<td>(-)</td>
<td>(-)</td>
<td>(+)</td>
</tr>
<tr>
<td>如果set_time_limit没有起作用，强制结束过期进程</td>
<td>(-)</td>
<td>(-)</td>
<td>(+)</td>
</tr>
</tbody>
</table>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;特色功能 Error header、优化的上传支持、fastcgi_finish_request() 另外，php-fpm还可以兼容zend Optimize，各种缓存优化器。</p>
<h2 id="Php-fpm的安装"><a href="#Php-fpm的安装" class="headerlink" title="Php-fpm的安装"></a>Php-fpm的安装</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;php-fpm是以patch的方式安装的，如果要使用它，必须在安装php前打上这个补丁。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip -<span class="built_in">cd</span> php-5.2.6-fpm-0.5.9.diff.gz | patch -d php-5.2.6 -p1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在configure时加上–enable-fpm选项。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;安装完php后，会有以下几个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$prefix</span>/ext/php-fpm.conf </div><div class="line"><span class="variable">$prefix</span>/<span class="built_in">log</span>/php-fpm.log </div><div class="line"><span class="variable">$prefix</span>/<span class="built_in">log</span>/php-fpm.pid</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中php-fpm.conf是配置文件，具体如何配置文件里有非常详尽的注释。 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后，执行./bin/php-cgi –fpm &amp;就可以了。  </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外，你也可以使用$prexif/sbin/php-fpm脚本来方便的维护。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h3><ul>
<li><strong>ab</strong>  apache自测的性能测试工具，主要用于测试极限压力：对于同一url每秒所能执行的次数及响应时间。</li>
<li><strong>myab</strong>  baidu开发的压力测试工具，区别于ab，其更主要的功能是测试指定压力条件下机器的负载情况。</li>
<li><strong>eacc</strong>  一种php加速器，主要是将php程序编译后的结果缓存起来。加速php的执行，对性能有很大幅度的提升 ，更详细的情况可以参见另一篇关于php缓存优化的文档 《缓存优化工具-php加速的利器》</li>
<li><strong>etc、stc、dyn</strong>  mod_fastcgi运行的模式，分别指远程、静态和动态模式    </li>
</ul>
<h3 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;测试中我们将针对不同的运行模式和页面类型进行极限压力测试及机器负载测试。同时，我们还将测试使用缓存优化和不使用缓存优化下机器的表现情况。另外，由于我们的测试主要是对比两种模式的性能差别，因此对于机器的硬件配置不是特别敏感，测试的时候只需要保证机器负载为0即可。</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul>
<li>最简单的php页面<br>压力工具：mysql<br>压力情况：每秒1000次请求，并发数70。<br>性能指标：cpu idle     </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不同模式下机器idle情况如下图</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/04.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从图上我们可以看出，测试最简单的php页面时，各种模式下性能几乎没有差别，且由于页面非常简单，eacc的效果也基本没有。</p>
<ul>
<li>复杂的php程序（2000行代码+）<br>压力工具：mysql<br>压力情况：每秒400次请求,并发数70<br>性能指标：cpu idle    </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;测试结果如下图</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/05.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从图上可以看出，在php代码复杂的情况下，前面4中模式性能差别不大，mod_php略优，然后fastcgi动态配置的方式在此情况下性能差距非常之大，idle直接降为0，同时虽然每秒是400次的压力，其只能处理200次左右的请求。 由于php代码很复杂，eacc的作用明显体现出来，使用缓存优化后性能提升一倍以上。  </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外，还可以看出，eacc这样的缓存优化工具对于mod_php和fastcgi方式起到的作用基本相同，他们之间的性能差异和使用前维持相同。  在上述情况下，如果不适应fpm，fastcgi模式会出core，主要原因还在在于进程管理的问题。</p>
<ul>
<li>实际项目中的php程序<br>这里我们采用群组项目中的pb页面，涉及到和数据库交互，db交互2次。<br>db部署在其他机器，每次请求耗时50ms左右。<br>压力工具：mysql<br>压力情况：每秒400次请求,并发数70<br>性能指标：cpu idle     </li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;测试结果如下</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/06.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从图上可以看出，性能的情况和图2类似，各种模式的差距仍然不大。 </p>
<ul>
<li>极限压力测试<br>压力工具：ab<br>测试参数：并发请求数100，总次数10000次。<br>测试页面：pb页面<br>性能指标：每秒请求数 rps </li>
</ul>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/07.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从上图我们可以看到，极限压力下，使用eacc后，mod_php和ext(fpm)基本差不多，保持在860/s左右的水平，而使用fpm方式进行管理的模式略优于其他两种fastcgi模式。  </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;测试中发现，fastcgi模式下，不使用php-fpm管理的话，仍然会有core出现。   </p>
<h2 id="fastcgi配置项对性能的影响。"><a href="#fastcgi配置项对性能的影响。" class="headerlink" title="fastcgi配置项对性能的影响。"></a>fastcgi配置项对性能的影响。</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在mod_fastcgi下，不管是ext还是stc方式，有一个配置项是非常关键的：默认启动的php-cgi进程实例数 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从fastcgi原理可以看出，当有一个httpd进程到来时，它需要调用fastcgi server来执行，如果此时所有server都出于服务状态，则这个httpd进程将出于等待状态得不到服务，导致请求无法响应。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对pb页面进行测试，配置不同的实例数目进行极限压力测试，得到结果如下</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/08.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;分析一下这个原因：   </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们的pb页面执行时间是50ms，也就是说一个php-cgi程序在1s内可以处理的请求数目是1000/50 = 20。假设启动的实例数目是n，则1s内最多能完成的请求数为n<em>20，从图上可以看出，实际结果符合我们的计算。另外，这个数值也不是无限增大了，当n</em>20大于server本身所能承受的极限时，rps也不会继续往上增长了。   </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;所以，使用fastcgi，对于n的选择，要综合页面平均处理时间，最大压力等多种因素结合来配置。     </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;同时，在ext方式下，webserver和fastcgi server交互的方式有两种：通过tcp或者unix sock。测试一下这两种方式的情况 </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;使用myab每秒400次请求pb页面，机器idle </p>
<p><img src="https://github.com/hcldirgit/image/blob/master/mod_php%E5%92%8Cmod_fastcgi%E5%92%8Cphp-fpm%E7%9A%84%E4%BB%8B%E7%BB%8D,%E5%AF%B9%E6%AF%94,%E5%92%8C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/09.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从图上可以看出，不管是否使用eacc，tcp方式的idle都有一个百分点的下降，这个差异主要是因为多了tcp连接过程造成的。   </p>
<h2 id="分析-amp-结论"><a href="#分析-amp-结论" class="headerlink" title="分析&amp;结论"></a>分析&amp;结论</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;根据各种测试结果，可以看出和fastcgi方式相比，mod_php的性能在各种情况下都稍优，这种差异主要是在于后一种方式增加了一次数据交互过程php-&gt;fascgi-&gt;apache。但是这个差距并不大，在使用了eacc等缓存优化工具后，性能有了很大提升。他们之间的差距完全不是瓶颈。从使用的角度来说，fastcgi具有以下优点：<br>1． webserver和php程序分离，两者可以部署在不同的地方，通过socket方式通信带来一定安全性<br>2． 使用fastcgi，在出现问题时可以更好的定位是webserver还是php的原因<br>3． fastcgi方式不依赖于webserver，更加灵活，扩展性也更好<br>4． fastcgi本身会有一些进程监控和日志记录，更便于分析问题，跟踪状态。<br>5． 灵活多样的配置，可以根据实际的应用进行合理配置达到最佳效果。   </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当然fastcgi也有一些缺点<br>1． mod_fastcgi在进程管理上有一些问题，容易出core。这个问题通过使用php-fpm可以解决<br>2． 由于fastcgi应用单独分离出来，因此需要单独监控进程的状态。防止进程挂掉后导致服务出现问题，这个可以通过使用用supervise管理一定程度上避免这个问题。<br>3． 文档相对缺乏，mod_fastcgi对apache的支持也不是特别好，且基本没有升级。   </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于fastcgi运行方式的选择，从效率、稳定性等各方面来说，ext方式是最佳选择了。而且考虑到我们可能会将webserver和php分开到不同机器，选择远程方式也是必须的。  </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进程管理工具，从各方面来说，php-fpm是最优选择了，即时使用lighty作用web server，也完全可以用它代替spwn-cgi。   </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;综合测试结果和上述分析，我们完全可以采用fastcgi代替传统的mod_php。推荐使用下面的组合方式</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;apache + ext + php-fpm(with superwise)</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果webserver和fastcgi部署在同一机器上，使用unix sock方式通信，否则使用tcp方式。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="apache-mod-fastcgi-php搭建"><a href="#apache-mod-fastcgi-php搭建" class="headerlink" title="apache+mod_fastcgi+php搭建"></a>apache+mod_fastcgi+php搭建</h3><ul>
<li>php<br>mod_fastcgi的搭建主要有三种方式<br>stc、ext和dyn，不管是哪种方式，首先在安装php的时候需要加上如下选项<br>–enable-fastcgi，并且不能使用—with-apxs。<br>以下是一个配置php例子 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">./configure \</div><div class="line">--prefix=/home/club/hongdk/env/php5.26-fcgi/ \</div><div class="line">--<span class="built_in">enable</span>-trace-vars \ </div><div class="line">--with-zlib-dir=/home/club/hongdk/tool/zlib/ \</div><div class="line">--with-mysql=/home/club/hongdk/env/mysql5/ \  </div><div class="line">--with-mysqli=/home/club/hongdk/env/mysql5/bin/mysql_config \</div><div class="line">--with-gettext \</div><div class="line">--with-iconv \ </div><div class="line">--<span class="built_in">enable</span>-mbstring=gbk \</div><div class="line">--with-xmlrpc \  </div><div class="line">--<span class="built_in">enable</span>-safe-mode \</div><div class="line">--<span class="built_in">enable</span>-sockets \</div><div class="line">--<span class="built_in">enable</span>-url-fopen-wrapper \</div><div class="line">--<span class="built_in">enable</span>-ftp \</div><div class="line">--<span class="built_in">enable</span>-shmop \</div><div class="line">--with-config-file-path=/home/club/hongdk/env/php5.26-fcgi/ \</div><div class="line">--<span class="built_in">enable</span>-xml \</div><div class="line">--with-dom=/home/club/hongdk/tool/libxml/ \</div><div class="line">--with-libxml-dir=/home/club/hongdk/tool/libxml/ \ </div><div class="line">--with-curl=/home/club/hongdk/tool/curl \</div><div class="line">--with-curlwrappers \</div><div class="line">--<span class="built_in">enable</span>-fastcgi \</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在安装完后，会在php的bin目录下找到如下文件php-cgi</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;执行 <code>./php-cgi –v</code>，如果看到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PHP 5.2.5 (cgi-fcgi) (built: Nov 12 2008 20:44:08)</div><div class="line">Copyright (c) 1997-2007 The PHP Group </div><div class="line">Zend Engine v2.2.0, Copyright (c) 1998-2007 Zend Technologies</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;就表明安装成功了</p>
<ul>
<li>mod_fastcgi </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mod_fastcgi-2.4.6 </div><div class="line">cp Makefile.AP2 Makefile </div><div class="line">vi Makefile</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;修改top_dir为apache安装目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<ul>
<li>apache配置<br>修改httpd.conf<br>首先增加 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LoadModule fastcgi_module modules/mod_fastcgi.so</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后根据不同的运行模式进行配置</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eg </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ext模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;IfModule mod_fastcgi.c&gt; </div><div class="line">    FastCgiExternalServer <span class="variable">$php</span>-server -socket /home/club/fastcgi.sock</div><div class="line">    ScriptAlias /cgi-bin/ <span class="string">"/home/club/hongdk/env/apache-fcgi/cgi-bin/"</span></div><div class="line">    AddHandler php-fastcgi .php </div><div class="line">    Action php-fastcgi /cgi-bin/php-cgi</div><div class="line">    AddType application/x-httpd-php .php</div><div class="line">&lt;/IfModule&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中 <code>$php-sever</code> 为php-cgi程序,例如/home/club/hongdk/env/apache-fcgi/cgi-bin/php-cgi</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stc模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;IfModule mod_fastcgi.c&gt;</div><div class="line">    FastCgiServer <span class="variable">$php</span>-server -processes 10 </div><div class="line">    ScriptAlias /cgi-bin/ <span class="string">"/home/club/hongdk/env/apache-fcgi/cgi-bin/"</span></div><div class="line">    AddHandler php-fastcgi .php </div><div class="line">    Action php-fastcgi /cgi-bin/php-cgi</div><div class="line">    AddType application/x-httpd-php .php</div><div class="line">&lt;/IfModule&gt; </div><div class="line">`</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dyn模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;IfModule mod_fastcgi.c&gt;</div><div class="line">    FastcgiConfig –idle-timeout 120 </div><div class="line">    ScriptAlias /cgi-bin/ <span class="string">"/home/club/hongdk/env/apache-fcgi/cgi-bin/"</span></div><div class="line">    AddHandler php-fastcgi .php</div><div class="line">    Action php-fastcgi /cgi-bin/php-cgi </div><div class="line">    AddType application/x-httpd-php .php</div><div class="line">&lt;/IfModule&gt;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后，定义fastcgi server也就是我们的php-cgi程序所在文件夹的权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Directory <span class="variable">$php</span>-server&gt;</div><div class="line">    Options ExecCGI</div><div class="line">    Order allow,deny</div><div class="line">    Allow from all</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<ul>
<li>fastcgi应用<br>在我们的应用中就是php-cgi<br>如果是stc和dyn方式，不需要单独再启动php-cgi，他们的管理有mod_fastcgi自带的fcgi-pm来完成<br>在etc模式下，我们需要单独启动php-cgi程序<br>可以用php-fpm来完成。也可以独立的使用一个脚本来启动，例如</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">exec</span> &amp;&gt; /dev/null</div><div class="line"><span class="built_in">exec</span> &lt; /dev/null</div><div class="line">PHP_FCGI_CHILDREN=32</div><div class="line"><span class="built_in">export</span> PHP_FCGI_CHILDREN</div><div class="line"><span class="built_in">exec</span> /home/club/hongdk/env/apache-fcgi/cgi-bin/php-cgi -b ./xl.sock -c /home/club/hongdk/env/php5-fcgi/php.ini</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;推荐使用php-fpm来完成</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/4. Nginx为什么比Apache Httpd高效：原理篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/4. Nginx为什么比Apache Httpd高效：原理篇/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.742Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/4. Nginx为什么比Apache Httpd高效：原理篇/">
        Nginx为什么比Apache Httpd高效：原理篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nginx才短短几年，就拿下了web服务器大笔江山，众所周知，Nginx在处理大并发静态请求方面，效率明显高于httpd，甚至能轻松解决C10K问题。下面我们就来聊聊Web服务器背后的一些原理。</p>
<h2 id="一、进程、线程？"><a href="#一、进程、线程？" class="headerlink" title="一、进程、线程？"></a>一、进程、线程？</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;进程是具有一定独立功能的，在计算机中已经运行的程序的实体。在早期系统中（如linux 2.4以前），进程是基本运作单位，在支持线程的系统中（如windows，linux2.6）中，线程才是基本的运作单位，而进程只是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多 CPU 主机或网络上真正同时运行（在不同的CPU上）。</p>
<h2 id="二、常见Web服务方式"><a href="#二、常见Web服务方式" class="headerlink" title="二、常见Web服务方式"></a>二、常见Web服务方式</h2><h3 id="三种工作模型比较："><a href="#三种工作模型比较：" class="headerlink" title="三种工作模型比较："></a>三种工作模型比较：</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Web服务器要为用户提供服务，必须以某种方式，工作在某个套接字上。一般Web服务器在处理用户请求是，一般有如下三种方式可选择：多进程方式、多线程方式、异步方式。</p>
<ul>
<li>多进程方式：为每个请求启动一个进程来处理。由于在操作系统中，生成进程、销毁进程、进程间切换都很消耗CPU和内存，当负载高是，性能会明显降低。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>优点： 稳定性！</strong>由于采用独立进程处理独立请求，而进程之间是独立的，单个进程问题不会影响其他进程，因此稳定性最好。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>缺点： 资源占用！</strong>当请求过大时，需要大量的进程处理请求，进程生成、切换开销很大，而且进程间资源是独立的，造成内存重复利用。</p>
<ul>
<li>多线程方式：一个进程中用多个线程处理用户请求。由于线程开销明显小于进程，而且部分资源还可以共享，因此效率较高。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>优点：开销较小！</strong>线程间部分数据是共享的，且线程生成与线程间的切换所需资源开销比进程间切换小得多。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>缺点：稳定性！</strong>线程切换过快可能造成线程抖动，且线程过多会造成服务器不稳定。</p>
<ul>
<li>异步方式：使用非阻塞方式处理请求，是三种方式中开销最小的。但异步方式虽然效率高，但要求也高，因为多任务之间的调度如果出现问题，就可能出现整体故障，因此使用异步工作的，一般是一些功能相对简单，但却符合服务器任务调度、且代码中没有影响调度的错误代码存在的程序。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>优点：性能最好！</strong>一个进程或线程处理多个请求，不需要额外开销，性能最好，资源占用最低。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>缺点：稳定性！</strong>某个进程或线程出错，可能导致大量请求无法处理，甚至导致整个服务宕机。</p>
<h3 id="一个Web请求的处理过程："><a href="#一个Web请求的处理过程：" class="headerlink" title="一个Web请求的处理过程："></a>一个Web请求的处理过程：</h3><p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/01.png?raw=true" alt=""></p>
<ol>
<li>客户发起情况到服务器网卡；</li>
<li>服务器网卡接受到请求后转交给内核处理；</li>
<li>内核根据请求对应的套接字，将请求交给工作在用户空间的Web服务器进程</li>
<li>Web服务器进程根据用户请求，向内核进行系统调用，申请获取相应资源（如index.html）</li>
<li>内核发现web服务器进程请求的是一个存放在硬盘上的资源，因此通过驱动程序连接磁盘</li>
<li>内核调度磁盘，获取需要的资源</li>
<li>内核将资源存放在自己的缓冲区中，并通知Web服务器进程</li>
<li>Web服务器进程通过系统调用取得资源，并将其复制到进程自己的缓冲区中</li>
<li>Web服务器进程形成响应，通过系统调用再次发给内核以响应用户请求</li>
<li>内核将响应发送至网卡</li>
<li>网卡发送响应给用户</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过这样的一个复杂过程，一次请求就完成了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;简单来说就是：<strong>用户请求–&gt;送达到用户空间–&gt;系统调用–&gt;内核空间–&gt;内核到磁盘上读取网页资源-&gt;返回到用户空间-&gt;响应给用户</strong>。上述简单的说明了一下，客户端向Web服务请求过程，在这个过程中，有两个I/O过程，一个就是客户端请求的网络I/O，另一个就是Web服务器请求页面的磁盘I/O。 下面我们就来说说Linux的I/O模型。</p>
<h2 id="三、各种I-O模型详解"><a href="#三、各种I-O模型详解" class="headerlink" title="三、各种I/O模型详解"></a>三、各种I/O模型详解</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过上面的对连接的处理分析，我们知道工作在用户空间的web服务器进程是无法直接操作IO的，需要通过系统调用进行，其关系如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/02.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;即进程向内核进行系统调用申请IO，内核将资源从IO调度到内核的buffer中（<code>wait阶段</code>），内核还需将数据从内核buffer中复制（<code>copy阶段</code>）到web服务器进程所在的用户空间，才算完成一次IO调度。这几个阶段都是需要时间的。根据wait和copy阶段的处理等待的机制不同，可将I/O动作分为如下五种模式：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O复用（select和poll）</li>
<li>信号（事件）驱动I/O（SIGIO）</li>
<li>异步I/O（aio）</li>
</ul>
<h3 id="I-O模型简介"><a href="#I-O模型简介" class="headerlink" title="I/O模型简介"></a>I/O模型简介</h3><pre><code>这里有必要先解释一下**阻塞、非阻塞，同步、异步、I/O**的概念。
</code></pre><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞:"></a>阻塞和非阻塞:</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;阻塞和非阻塞指的是执行一个操作是等操作结束再返回，还是马上返回。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;比如餐馆的服务员为用户点菜，当有用户点完菜后，服务员将菜单给后台厨师，此时有两种方式：</p>
<ul>
<li>第一种：就在出菜窗口等待，直到厨师炒完菜后将菜送到窗口，然后服务员再将菜送到用户手中；</li>
<li>第二种：等一会再到窗口来问厨师，某个菜好了没？如果没有先处理其他事情，等会再去问一次；</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第一种就是阻塞方式，第二种则是非阻塞的。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步:"></a>同步和异步:</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;同步和异步又是另外一个概念，它是事件本身的一个属性。还拿前面点菜为例，服务员直接跟厨师打交道，菜出来没出来，服务员直接指导，但只有当厨师将菜送到服务员手上，这个过程才算正常完成，这就是同步的事件。同样是点菜，有些餐馆有专门的传菜人员，当厨师炒好菜后，传菜员将菜送到传菜窗口，并通知服务员，这就变成异步的了。其实异步还可以分为两种：带通知的和不带通知的。前面说的那种属于带通知的。有些传菜员干活可能主动性不是很够，不会主动通知你，你就需要时不时的去关注一下状态。这种就是不带通知的异步。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于同步的事件，你只能以阻塞的方式去做。而对于异步的事件，阻塞和非阻塞都是可以的。非阻塞又有两种方式：主动查询和被动接收消息。被动不意味着一定不好，在这里它恰恰是效率更高的，因为在主动查询里绝大部分的查询是在做无用功。对于带通知的异步事件，两者皆可。而对于不带通知的，则只能用主动查询。</p>
<h4 id="全异步I-O"><a href="#全异步I-O" class="headerlink" title="全异步I/O"></a>全异步I/O</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回到I/O，不管是I还是O，对外设(磁盘)的访问都可以分成请求和执行两个阶段。请求就是看外设的状态信息（比如是否准备好了），执行才是真正的I/O操作。在Linux 2.6之前，只有“请求”是异步事件，2.6之后才引入AIO（asynchronous I/O ）把“执行”异步化。别看Linux/Unix是用来做服务器的，这点上比Windows落后了好多，IOCP（Windows上的AIO，效率极高）在Win2000上就有了。所以学linux的别老觉得Windows这里不好那里不好（Windows的多线程机制也由于linux）。</p>
<h4 id="I-O的五种模型"><a href="#I-O的五种模型" class="headerlink" title="I/O的五种模型"></a>I/O的五种模型</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;根据以上分析，I/O可分为五种模型：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/03.png?raw=true" alt=""></p>
<ul>
<li><strong>阻塞I/O</strong>：所有过程全阻塞</li>
<li><strong>非阻塞I/O</strong>：如果没有数据buffer，则立即返回EWOULDBLOCK</li>
<li><strong>I/O复用（select和poll）</strong>：在wait和copy阶段分别阻塞</li>
<li><strong>信号驱动I/O（SIGIO）</strong>：在wait阶段不阻塞，但copy阶段阻塞（信号驱动I/O，即通知）</li>
<li><strong>异步I/O（aio）</strong>：完全五阻塞方式，当I/O完成是提供信号</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Linux上的前四种I/O模型的“执行”阶段都是同步的，只有最后一种才做到了真正的全异步。第一种阻塞式是最原始的方法，也是最累的办法。当然累与不累要看针对谁。应用程序是和内核打交道的。对应用程序来说，这种方式是最累的，但对内核来说这种方式恰恰是最省事的。还拿点菜这事为例，你就是应用程序，厨师就是内核，如果你去了一直等着，厨师就省事了（不用同时处理其他服务员的菜）。当然现在计算机的设计，包括操作系统，越来越为终端用户考虑了，为了让用户满意，内核慢慢的承担起越来越多的工作，IO模型的演化也是如此。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;非阻塞I/O ，I/O复用，信号驱动式I/O其实都是非阻塞的，当然是针对“请求”这个阶段。非阻塞式是主动查询外设状态。I/O复用里的select，poll也是主动查询，不同的是select和poll可以同时查询多个fd（文件句柄）的状态，另外select有fd个数的限制。epoll是基于回调函数的。信号驱动式I/O则是基于信号消息的。这两个应该可以归到“被动接收消息”那一类中。最后就是伟大的AIO的出现，内核把什么事都干了，对上层应用实现了全异步，性能最好，当然复杂度也最高。</p>
<h3 id="各I-O模型详细介绍："><a href="#各I-O模型详细介绍：" class="headerlink" title="各I/O模型详细介绍："></a>各I/O模型详细介绍：</h3><h4 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说明：应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。这个不用多解释吧，阻塞套接字。下图是它调用过程的图示：（注，一般网络I/O都是阻塞I/O，客户端发出请求，Web服务器进程响应，在进程没有返回页面之前，这个请求会处于一直等待状态）</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/04.png?raw=true" alt=""></p>
<h4 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们把一个套接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间，所有一般Web服务器都不使用这种I/O模型。具体过程如下图:</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/05.png?raw=true" alt=""></p>
<h4 id="I-O复用（select和poll）"><a href="#I-O复用（select和poll）" class="headerlink" title="I/O复用（select和poll）"></a>I/O复用（select和poll）</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I/O复用模型会用到select或poll函数或epoll函数(Linux2.6以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。具体过程如下图:</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/06.png?raw=true" alt=""></p>
<h4 id="信号驱动I-O（SIGIO）"><a href="#信号驱动I-O（SIGIO）" class="headerlink" title="信号驱动I/O（SIGIO）"></a>信号驱动I/O（SIGIO）</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先，我们允许套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。具体过程如下图:</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/07.jpg?raw=true" alt=""></p>
<h4 id="异步I-O（aio）"><a href="#异步I-O（aio）" class="headerlink" title="异步I/O（aio）"></a>异步I/O（aio）</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。具体过程如下图:</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/08.png?raw=true" alt=""></p>
<h4 id="模型总结（如下图）"><a href="#模型总结（如下图）" class="headerlink" title="模型总结（如下图）"></a>模型总结（如下图）</h4><p><img src="https://github.com/hcldirgit/image/blob/master/Nginx%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Apache%20Httpd%E9%AB%98%E6%95%88%EF%BC%9A%E5%8E%9F%E7%90%86%E7%AF%87/09.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从上图中我们可以看出，可以看出，越往后，阻塞越少，理论上效率也是最优。其五种I/O模型中，前三种属于同步I/O，后两者属于异步I/O。</p>
<p><strong>同步I/O</strong>:</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O复用（select和poll）</li>
</ul>
<p><strong>异步I/O</strong>:</p>
<ul>
<li>信号驱动I/O（SIGIO） （半异步）</li>
<li>异步I/O（aio） （真正的异步）</li>
</ul>
<p><strong>异步 I/O 和 信号驱动I/O的区别</strong>:</p>
<ul>
<li>信号驱动 I/O 模式下，内核可以复制的时候通知给我们的应用程序发送SIGIO 消息。</li>
<li>异步 I/O 模式下，内核在所有的操作都已经被内核操作结束之后才会通知我们的应用程序。</li>
</ul>
<h3 id="Linux-I-O模型的具体实现"><a href="#Linux-I-O模型的具体实现" class="headerlink" title="Linux I/O模型的具体实现"></a>Linux I/O模型的具体实现</h3><h4 id="主要实现方式有以下几种："><a href="#主要实现方式有以下几种：" class="headerlink" title="主要实现方式有以下几种："></a>主要实现方式有以下几种：</h4><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>/dev/poll</li>
<li>iocp</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注，其中iocp是Windows实现的，select、poll、epoll是Linux实现的，kqueue是FreeBSD实现的，/dev/poll是SUN的Solaris实现的。select、poll对应第3种（I/O复用）模型，iocp对应第5种（异步I/O）模型，那么epoll、kqueue、/dev/poll呢？其实也同select属于同一种模型，只是更高级一些，可以看作有了第4种（信号驱动I/O）模型的某些特性，如callback机制。</p>
<h4 id="为什么epoll、kqueue、-dev-poll比select高级？"><a href="#为什么epoll、kqueue、-dev-poll比select高级？" class="headerlink" title="为什么epoll、kqueue、/dev/poll比select高级？"></a>为什么epoll、kqueue、/dev/poll比select高级？</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;答案是，他们无轮询。因为他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll、kqueue、/dev/poll做的。这样子说可能不好理解，那么我说一个现实中的例子，假设你在大学读书，住的宿舍楼有很多间房间，你的朋友要来找你。select版宿管大妈就会带着你的朋友挨个房间去找，直到找到你为止。而epoll版宿管大妈会先记下每位同学的房间号，你的朋友来时，只需告诉你的朋友你住在哪个房间即可，不用亲自带着你的朋友满大楼找人。如果来了10000个人，都要找自己住这栋楼的同学时，select版和epoll版宿管大妈，谁的效率更高，不言自明。同理，在高并发服务器中，轮询I/O是最耗时间的操作之一，select、epoll、/dev/poll的性能谁的性能更高，同样十分明了。</p>
<h4 id="Windows-or-nix-（IOCP-or-kqueue、epoll、-dev-poll）？"><a href="#Windows-or-nix-（IOCP-or-kqueue、epoll、-dev-poll）？" class="headerlink" title="Windows or *nix （IOCP or kqueue、epoll、/dev/poll）？"></a>Windows or *nix （IOCP or kqueue、epoll、/dev/poll）？</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;诚然，Windows的IOCP非常出色，目前很少有支持asynchronous I/O的系统，但是由于其系统本身的局限性，大型服务器还是在UNIX下。而且正如上面所述，kqueue、epoll、/dev/poll 与 IOCP相比，就是多了一层从内核copy数据到应用层的阻塞，从而不能算作asynchronous I/O类。但是，这层小小的阻塞无足轻重，kqueue、epoll、/dev/poll 已经做得很优秀了。</p>
<h4 id="总结一些重点"><a href="#总结一些重点" class="headerlink" title="总结一些重点"></a>总结一些重点</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;只有IOCP(windows实现)是asynchronous I/O，其他机制或多或少都会有一点阻塞。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;select（Linux实现）低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;epoll(Linux实现)、kqueue（FreeBSD实现）、/dev/poll（Solaris实现）是Reacor模式，IOCP是Proactor模式。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Apache 2.2.9之前只支持select模型，2.2.9之后支持epoll模型</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nginx 支持epoll模型</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Java nio包是select模型</p>
<h2 id="四、Apache-Httpd的工作模式"><a href="#四、Apache-Httpd的工作模式" class="headerlink" title="四、Apache Httpd的工作模式"></a>四、Apache Httpd的工作模式</h2><h3 id="apache三种工作模式"><a href="#apache三种工作模式" class="headerlink" title="apache三种工作模式"></a>apache三种工作模式</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们都知道Apache有三种工作模块，分别为prefork、worker、event。</p>
<ul>
<li>prefork：多进程，每个请求用一个进程响应，这个过程会用到select机制来通知。</li>
<li>worker：多线程，一个进程可以生成多个线程，每个线程响应一个请求，但通知机制还是select不过可以接受更多的请求。</li>
<li>event：基于异步I/O模型，一个进程或线程，每个进程或线程响应多个用户请求，它是基于事件驱动（也就是epoll机制）实现的。</li>
</ul>
<h3 id="prefork的工作原理"><a href="#prefork的工作原理" class="headerlink" title="prefork的工作原理"></a>prefork的工作原理</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果不用“–with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache1.3中采用的模式。prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的,这也使其成为最稳定的MPM之一。</p>
<h3 id="worker的工作原理"><a href="#worker的工作原理" class="headerlink" title="worker的工作原理"></a>worker的工作原理</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;相对于prefork，worker是2.0版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理，所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器。但是，worker也使用了多进程,每个进程又生成多个线程，以获得基于进程服务器的稳定性，这种MPM的工作方 式将是Apache2.0的发展趋势。</p>
<h3 id="event-基于事件机制的特性"><a href="#event-基于事件机制的特性" class="headerlink" title="event 基于事件机制的特性"></a>event 基于事件机制的特性</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一个进程响应多个用户请求，利用callback机制，让套接字复用，请求过来后进程并不处理请求，而是直接交由其他机制来处理，通过epoll机制来通知请求是否完成；在这个过程中，进程本身一直处于空闲状态，可以一直接收用户请求。可以实现一个进程程响应多个用户请求。支持持海量并发连接数，消耗更少的资源。</p>
<h2 id="五、如何提高Web服务器的并发连接处理能力"><a href="#五、如何提高Web服务器的并发连接处理能力" class="headerlink" title="五、如何提高Web服务器的并发连接处理能力"></a>五、如何提高Web服务器的并发连接处理能力</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;有几个基本条件：</p>
<ul>
<li>基于线程，即一个进程生成多个线程，每个线程响应用户的每个请求。</li>
<li>基于事件的模型，一个进程处理多个请求，并且通过epoll机制来通知用户请求完成。</li>
<li>基于磁盘的AIO（异步I/O）</li>
<li>支持mmap内存映射，mmap传统的web服务器，进行页面输入时，都是将磁盘的页面先输入到内核缓存中，再由内核缓存中复制一份到web服务器上，mmap机制就是让内核缓存与磁盘进行映射，web服务器，直接复制页面内容即可。不需要先把磁盘的上的页面先输入到内核缓存去。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;刚好，Nginx 支持以上所有特性。所以Nginx官网上说，Nginx支持50000并发，是有依据的。</p>
<h2 id="六、Nginx优异之处"><a href="#六、Nginx优异之处" class="headerlink" title="六、Nginx优异之处"></a>六、Nginx优异之处</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;传统上基于进程或线程模型架构的web服务通过每进程或每线程处理并发连接请求，这势必会在网络和I/O操作时产生阻塞，其另一个必然结果则是对内存或CPU的利用率低下。生成一个新的进程/线程需要事先备好其运行时环境，这包括为其分配堆内存和栈内存，以及为其创建新的执行上下文等。这些操作都需要占用CPU，而且过多的进程/线程还会带来线程抖动或频繁的上下文切换，系统性能也会由此进一步下降。另一种高性能web服务器/web服务器反向代理：Nginx（Engine X），nginx的主要着眼点就是其高性能以及对物理计算资源的高密度利用，因此其采用了不同的架构模型。受启发于多种操作系统设计中基于“事件”的高级处理机制，nginx采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在nginx中，连接请求由为数不多的几个仅包含一个线程的进程worker以高效的回环(run-loop)机制进行处理，而每个worker可以并行处理数千个的并发连接及请求。</p>
<h3 id="Nginx-工作原理"><a href="#Nginx-工作原理" class="headerlink" title="Nginx 工作原理"></a>Nginx 工作原理</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份运行。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主进程主要完成如下工作：</p>
<ul>
<li>读取并验正配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止及维护worker进程的个数；</li>
<li>无须中止服务而重新配置工作特性；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式perl脚本；</li>
<li>worker进程主要完成的任务包括：</li>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx任何能完成的其它任务；</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注：如果负载以CPU密集型应用为主，如SSL或压缩应用，则worker数应与CPU数相同；如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。</p>
<h3 id="Nginx-架构"><a href="#Nginx-架构" class="headerlink" title="Nginx 架构"></a>Nginx 架构</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。不过，大多跟协议相关的功能和某应用特有的功能都是由nginx的模块实现的。这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream和负载均衡几个类别，这些共同组成了nginx的http功能。事件模块主要用于提供OS独立的(不同操作系统的事件机制有所不同)事件通知机制如kqueue或epoll等。协议模块则负责实现nginx通过http、tls/ssl、smtp、pop3以及imap与对应的客户端建立会话。在Nginx内部，进程间的通信是通过模块的pipeline或chain实现的；换句话说，每一个功能或操作都由一个模块来实现。例如，压缩、通过FastCGI或uwsgi协议与upstream服务器通信，以及与memcached建立会话等。</p>
<h3 id="Nginx-基础功能"><a href="#Nginx-基础功能" class="headerlink" title="Nginx 基础功能"></a>Nginx 基础功能</h3><ul>
<li>处理静态文件，索引文件以及自动索引；</li>
<li>反向代理加速(无缓存)，简单的负载均衡和容错；</li>
<li>FastCGI，简单的负载均衡和容错；</li>
<li>模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；</li>
<li>SSL 和 TLS SNI 支持；</li>
</ul>
<h3 id="Nginx-IMAP-POP3-代理服务功能"><a href="#Nginx-IMAP-POP3-代理服务功能" class="headerlink" title="Nginx IMAP/POP3 代理服务功能"></a>Nginx IMAP/POP3 代理服务功能</h3><ul>
<li>使用外部 HTTP 认证服务器重定向用户到 IMAP/POP3 后端；</li>
<li>使用外部 HTTP 认证服务器认证用户后连接重定向到内部的 SMTP 后端；</li>
<li>认证方法：</li>
<li>POP3: POP3 USER/PASS, APOP, AUTH LOGIN PLAIN CRAM-MD5;</li>
<li>IMAP: IMAP LOGIN;</li>
<li>SMTP: AUTH LOGIN PLAIN CRAM-MD5;</li>
<li>SSL 支持；</li>
<li>在 IMAP 和 POP3 模式下的 STARTTLS 和 STLS 支持；</li>
</ul>
<h3 id="Nginx-支持的操作系统"><a href="#Nginx-支持的操作系统" class="headerlink" title="Nginx 支持的操作系统"></a>Nginx 支持的操作系统</h3><ul>
<li>FreeBSD 3.x, 4.x, 5.x, 6.x i386; FreeBSD 5.x, 6.x amd64;</li>
<li>Linux 2.2, 2.4, 2.6 i386; Linux 2.6 amd64;</li>
<li>Solaris 8 i386; Solaris 9 i386 and sun4u; Solaris 10 i386;</li>
<li>MacOS X (10.4) PPC;</li>
<li>Windows 编译版本支持 windows 系列操作系统;</li>
</ul>
<h3 id="Nginx-结构与扩展"><a href="#Nginx-结构与扩展" class="headerlink" title="Nginx 结构与扩展"></a>Nginx 结构与扩展</h3><ul>
<li>一个主进程和多个工作进程，工作进程运行于非特权用户；</li>
<li>kqueue (FreeBSD 4.1+), epoll (Linux 2.6+), rt signals (Linux 2.2.19+), /dev/poll (Solaris 7 11/99+), select, 以及 poll 支持；</li>
<li>kqueue支持的不同功能包括 EV_CLEAR, EV_DISABLE （临时禁止事件）， NOTE_LOWAT, EV_EOF, 有效数据的数目，错误代码；</li>
<li>sendfile (FreeBSD 3.1+), sendfile (Linux 2.2+), sendfile64 (Linux 2.4.21+), 和 sendfilev (Solaris 8 7/01+) 支持；</li>
<li>输入过滤 (FreeBSD 4.1+) 以及 TCP_DEFER_ACCEPT (Linux 2.4+) 支持；</li>
<li>10,000 非活动的 HTTP keep-alive 连接仅需要 2.5M 内存。</li>
<li>最小化的数据拷贝操作；</li>
</ul>
<h3 id="Nginx-其他HTTP功能"><a href="#Nginx-其他HTTP功能" class="headerlink" title="Nginx 其他HTTP功能"></a>Nginx 其他HTTP功能</h3><ul>
<li>基于IP 和名称的虚拟主机服务；</li>
<li>Memcached 的 GET 接口；</li>
<li>支持 keep-alive 和管道连接；</li>
<li>灵活简单的配置；</li>
<li>重新配置和在线升级而无须中断客户的工作进程；</li>
<li>可定制的访问日志，日志写入缓存，以及快捷的日志回卷；</li>
<li>4xx-5xx 错误代码重定向；</li>
<li>基于 PCRE 的 rewrite 重写模块；</li>
<li>基于客户端 IP 地址和 HTTP 基本认证的访问控制；</li>
<li>PUT, DELETE, 和 MKCOL 方法；</li>
<li>支持 FLV （Flash 视频）；</li>
<li>带宽限制；</li>
</ul>
<h3 id="为什么选择Nginx"><a href="#为什么选择Nginx" class="headerlink" title="为什么选择Nginx"></a>为什么选择Nginx</h3><ul>
<li>在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型。</li>
<li>Nginx作为负载均衡服务器: Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。</li>
<li>作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验.</li>
<li>Nginx 安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）,Bugs 非常少的服务器: Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够 不间断服务的情况下进行软件版本的升级 。</li>
<li>Nginx 的诞生主要解决C10K问题</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LNMP/">LNMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/36. nginx 代理多台机器导致用户登陆异常，长连接(会话保持)解决问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/36. nginx 代理多台机器导致用户登陆异常，长连接(会话保持)解决问题/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.741Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/36. nginx 代理多台机器导致用户登陆异常，长连接(会话保持)解决问题/">
        nginx 代理多台机器导致用户登陆异常，长连接(会话保持)解决问题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;网站使用程序 discuzx3  访问都正常，只有用户登陆存在异常，具体的情况是这样的：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用户登陆后，会马上显示未登陆，然后刷新一下或者多下又变成了登陆中。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这个问题很显然是由于session导致，后台有多个web机器，当用户登陆后，会把登陆态session保存到当前web,但是再次发送请求时则会到另一台机器，所以原来的session信息找不到了。解决这个问题有两个思路：</p>
<ol>
<li><p>可以把session时时同步到另外的机器。</p>
</li>
<li><p>可以让前端的调度器保持长连接，也就是说某个用户的请求在某一时间段内始终抓发到固定的一台机器上。</p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这两种方式，第二种更容易实现。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我使用的是nginx的代理，其中nginx有一种算法支持长连接，具体配置是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream <span class="built_in">test</span> &#123;</div><div class="line"> ip_hash;</div><div class="line">server 192.168.109.5;</div><div class="line">server 192.168.109.3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关键代码： ip_hash </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">E = mc^2</div></pre></td></tr></table></figure></p>
<p>这样，nginx会把用户的请求一直转发到后端的某台机器。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Nginx/37. nginx的location优先级" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/Nginx/37. nginx的location优先级/" class="article-date">
  	<time datetime="2017-09-02T18:06:42.741Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/Nginx/37. nginx的location优先级/">
        nginx的location优先级
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在nginx配置文件中，location主要有这几种形式：</p>
<ol>
<li><p>正则匹配  location ~ /abc { }</p>
</li>
<li><p>不区分大小写的正则匹配 location ~* /abc { }</p>
</li>
<li><p>匹配路径的前缀，如果找到停止搜索 location ^~ /abc { }</p>
</li>
<li><p>精确匹配  location = /abc { }</p>
</li>
</ol>
<p>5.普通路径前缀匹配  location  /abc { }</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先说优先级</p>
<p>4  &gt; 3  &gt; 2  &gt; 1 &gt;  5</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;再来解释一下各个格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">location  = / &#123;</div><div class="line">  <span class="comment"># 精确匹配 / ，主机名后面不能带任何字符串</span></div><div class="line">  [ configuration A ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location  / &#123;</div><div class="line">  <span class="comment"># 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span></div><div class="line">  <span class="comment"># 但是正则和最长字符串会优先匹配</span></div><div class="line">  [ configuration B ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location /documents/ &#123;  </div><div class="line">  <span class="comment"># 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span></div><div class="line">  <span class="comment"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></div><div class="line">  [ configuration C ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /documents/Abc &#123;  </div><div class="line">  <span class="comment"># 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span></div><div class="line">  <span class="comment"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></div><div class="line">  [ configuration CC ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location ^~ /images/ &#123;  </div><div class="line">  <span class="comment"># 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span></div><div class="line">  [ configuration D ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~* \.(gif|jpg|jpeg)$ &#123;  </div><div class="line">  <span class="comment"># 匹配所有以 gif,jpg或jpeg 结尾的请求</span></div><div class="line">  <span class="comment"># 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span></div><div class="line">  [ configuration E ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location /images/ &#123;  </div><div class="line">  <span class="comment"># 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span></div><div class="line">  [ configuration F ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location /images/abc &#123;  </div><div class="line">  <span class="comment"># 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span></div><div class="line">  <span class="comment"># F与G的放置顺序是没有关系的</span></div><div class="line">  [ configuration G ] </div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /images/abc/ &#123;  </div><div class="line">  <span class="comment"># 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span></div><div class="line">    [ configuration H ] </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;再来分析一下A-H配置的执行顺序。</p>
<ol>
<li>下面2个配置同时存在时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location = / &#123;</div><div class="line">[ configuration A ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">[ configuration B ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;此时A生效，因为=/优先级高于/</p>
<ol>
<li>下面3个配置同时存在时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location  /documents/ &#123;</div><div class="line">[ configuration C ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /documents/ &#123;</div><div class="line"></div><div class="line">[configuration CB]</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /documents/abc &#123;</div><div class="line">[ configuration CC ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当访问的url为/documents/abc/1.html，此时CC生效，首先CB优先级高于C，而CC更优先于CB</p>
<ol>
<li>下面4个配置同时存在时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">location ^~ /images/ &#123;</div><div class="line">[ configuration D ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /images/ &#123;</div><div class="line">[ configuration F ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /images/abc &#123;</div><div class="line">[ configuration G ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /images/abc/ &#123;</div><div class="line">[ configuration H ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当访问的链接为/images/abc/123.jpg时，此时D生效。虽然4个规则都能匹配到，但^~优先级是最高的。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;若^~不存在时，H优先，因为~/images/ &gt; /images/</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;而/images/和/images/abc同时存在时，/images/abc优先级更高，因为后者更加精准</p>
<ol>
<li>下面两个配置同时存在时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</div><div class="line">[ configuration E ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">location ~ /images/abc/ &#123;</div><div class="line"></div><div class="line">[ configuration H ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当访问的链接为/images/abc/123.jpg时，E生效。因为上面的规则更加精准。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/22/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/24/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 失落的乐章
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>