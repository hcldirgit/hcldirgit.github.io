<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>失落的乐章</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="失落的乐章的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="失落的乐章">
<meta property="og:url" content="https://hcldirgit.github.io/page/28/index.html">
<meta property="og:site_name" content="失落的乐章">
<meta property="og:description" content="失落的乐章的Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失落的乐章">
<meta name="twitter:description" content="失落的乐章的Blog">
  
    <link rel="alternative" href="/atom.xml" title="失落的乐章" type="application/atom+xml">
  
  
    <link rel="icon" href="https://github.com/hcldirgit/image/blob/master/0.png?raw=true">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">失落的乐章</a></h1>
		</hgroup>

		
		<p class="header-subtitle">技术面前，永远都是学生。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">静心阅读</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ansible/" style="font-size: 10.42px;">Ansible</a> <a href="/tags/Apache/" style="font-size: 18.33px;">Apache</a> <a href="/tags/Cacti/" style="font-size: 11.67px;">Cacti</a> <a href="/tags/DNS/" style="font-size: 13.33px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/FTP/" style="font-size: 11.25px;">FTP</a> <a href="/tags/Git/" style="font-size: 10.83px;">Git</a> <a href="/tags/HA集群/" style="font-size: 11.67px;">HA集群</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/Jenkins/" style="font-size: 10.42px;">Jenkins</a> <a href="/tags/LAMP/" style="font-size: 19.58px;">LAMP</a> <a href="/tags/LNMP/" style="font-size: 17.08px;">LNMP</a> <a href="/tags/LVS/" style="font-size: 16.67px;">LVS</a> <a href="/tags/Linux/" style="font-size: 19.17px;">Linux</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux安全/" style="font-size: 14.17px;">Linux安全</a> <a href="/tags/Memcached/" style="font-size: 11.25px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 15.42px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nagios/" style="font-size: 11.67px;">Nagios</a> <a href="/tags/Nginx/" style="font-size: 17.92px;">Nginx</a> <a href="/tags/OpenStack/" style="font-size: 11.25px;">OpenStack</a> <a href="/tags/Php/" style="font-size: 14.58px;">Php</a> <a href="/tags/Puppet/" style="font-size: 11.25px;">Puppet</a> <a href="/tags/Python/" style="font-size: 14.58px;">Python</a> <a href="/tags/Redis/" style="font-size: 16.25px;">Redis</a> <a href="/tags/Resin/" style="font-size: 10px;">Resin</a> <a href="/tags/Saltstack/" style="font-size: 10px;">Saltstack</a> <a href="/tags/Samba/" style="font-size: 12.08px;">Samba</a> <a href="/tags/Squid/" style="font-size: 14.58px;">Squid</a> <a href="/tags/Tomcat/" style="font-size: 13.75px;">Tomcat</a> <a href="/tags/Zabbix/" style="font-size: 15.83px;">Zabbix</a> <a href="/tags/haproxy/" style="font-size: 12.5px;">haproxy</a> <a href="/tags/keepalived/" style="font-size: 12.92px;">keepalived</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/shell练习/" style="font-size: 18.75px;">shell练习</a> <a href="/tags/正则表达式/" style="font-size: 12.92px;">正则表达式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">失落的乐章</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/hcldirgit/image/blob/master/0.png?raw=true" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">失落的乐章</h1>
			</hgroup>
			
			<p class="header-subtitle">技术面前，永远都是学生。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">静心阅读</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-LVS/2. LVS 的 nat 模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/2. LVS 的 nat 模式/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.045Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/2. LVS 的 nat 模式/">
        LVS 的 nat 模式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84nat%E6%A8%A1%E5%BC%8F/01.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>类似于iptables的DNAT，但支持多目标转发。客户端和realserver不能再同一个网段，不然直接响应，不走网关</strong></p>
<h2 id="1-模块讲解"><a href="#1-模块讲解" class="headerlink" title="1.模块讲解"></a>1.模块讲解</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;客户端发起请求</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nat模式中，vip机器进行ip的转发，只改变目的ip</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;res1和res2需要提供web服务(nginx或者httpd都可以)</p>
<h2 id="2-请求流程图"><a href="#2-请求流程图" class="headerlink" title="2.请求流程图"></a>2.请求流程图</h2><ol>
<li>客户端发起请求到vip机器上，vip服务器根据lvs的算法，转发给realserver服务器（改变目的ip为res1或者res2），并记录连接信息，只改变目的ip，源ip不变。</li>
<li>real-server收到request请求包之后，发现目的ip是自己的ip，处理请求，然后走网关，经过vip</li>
<li>vip收到reply包后，修改reply包的源ip地址为vip，发给客户端</li>
<li>从客户端来的属于本地连接的包，查hash表，然后转发给real-server</li>
<li>当client发送完毕以后，此次连接结束或者连接超时，lvs自动从hast表中删除此条记录；</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;数据包流程如下：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.客户端发起请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span>      	192.168.147.1			dest    192.168.147.150:80</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在vip服务器上，eth1网卡上抓包如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84nat%E6%A8%A1%E5%BC%8F/02.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.lvs(vip)处理请求：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vip服务器上抓包，在eth1网卡：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span>		192.168.147.1:59334		dst	192.168.1.112/111:80</div></pre></td></tr></table></figure>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84nat%E6%A8%A1%E5%BC%8F/03.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.realserver处理完请求以后，网关是eth0；在vip的eth0上抓包如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span>             192.168.1.112              dst    192.168.147.1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.包经过eth0返回vip服务器，然后经过eth1返回给客户端，源ip改成vip，目的ip不变，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span>		192.168.147.150           dst        192.168.147.1</div></pre></td></tr></table></figure>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84nat%E6%A8%A1%E5%BC%8F/04.jpeg?raw=true" alt=""></p>
<h2 id="lvs-nat模式部署过程："><a href="#lvs-nat模式部署过程：" class="headerlink" title="lvs_nat模式部署过程："></a>lvs_nat模式部署过程：</h2><ol>
<li>（确保所有服务器的iptables   selinux都是关闭状态）</li>
<li>两个realserver上安装nginx或者http提供web服务</li>
<li>vip上安装ipvsadm </li>
<li>在vip服务器上新建lvs_nat.sh脚本，然后执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment"># director 服务器上开启路由转发功能: </span></div><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward </div><div class="line"><span class="comment"># 关闭icmp的重定向</span></div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/all/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/default/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/eth0/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/eth1/send_redirects</div><div class="line"></div><div class="line">iptables -F</div><div class="line">iptables -t nat -F</div><div class="line">iptables -t nat -X</div><div class="line"><span class="comment">#iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -j MASQUERADE</span></div><div class="line"></div><div class="line">ipvsadm -C</div><div class="line">ipvsadm -A -t 192.168.147.150:80 -s rr -p 300</div><div class="line"><span class="comment">#-p 300   长链接300秒</span></div><div class="line">ipvsadm -a -t 192.168.147.150:80 -r 192.168.1.111:80 -m -w 1</div><div class="line">ipvsadm -a -t 192.168.147.150:80 -r 192.168.1.112:80 -m -w 1</div></pre></td></tr></table></figure>
<ol>
<li>realserver的网关是eth0，及vip的内网ip</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>lvs——nat模式的缺点：当流量比较高时，因为所有的流量进入和出去都要进过lvs，所以瓶颈就在lvs上，而dr模式就比这个效果好很多</strong></p>
<h2 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当访问res2的时候，在111上可以抓到112:80到147.1上的包，如下：</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84nat%E6%A8%A1%E5%BC%8F/05.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当访问res1时，在111上抓不到112:80到147.1上的包</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/19. LVS结合keepalived配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/19. LVS结合keepalived配置/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.044Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/19. LVS结合keepalived配置/">
        LVS结合keepalived配置
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因为 NAT、DR 已经配置过一些操作，而使用 keepalived 操作和以前的操作是有些冲突的，所以先做一些处理。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在 dr 上执行 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># ipvsadm -C</span></div><div class="line">[root@dir ~]<span class="comment"># ifconfig eth0:0 down</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;为什么要引入 keepalived ，之前的 lvs 虽然已经配置成功也实现了负载均衡，但是测试的时候发现，当某台 real server 把 nginx 停掉，那么 director 照样会把请求转发过去，这样就造成了某些请求不正常。所以需要有一种机制用来检测 real server 的状态，也就是 keepalived 。它的作用除了可以检测 RS 状态外，还可以检测备用 director 的状态，也就是说 keepalived 可以实现 HA 集群的功能，当然也需要一台备用 director 服务器。备用 director 也需要安装一下 keepalived 软件。两台 director 上都执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y keepalived</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主 director 上安装好后，编辑配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;加入或更改如下配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER <span class="comment">#备用服务器上为 BACKUP</span></div><div class="line">    interface eth0</div><div class="line">    virtual_router_id 51</div><div class="line">    priority 100 <span class="comment">#备用服务器上为90</span></div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass 1111</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        192.168.0.64</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">virtual_server 192.168.0.64 80 &#123;</div><div class="line">    delay_loop 6 <span class="comment">#(每隔10秒查询realserver状态)</span></div><div class="line">    lb_algo wlc <span class="comment">#(lvs 算法)</span></div><div class="line">    lb_kind DR <span class="comment">#(Direct Route)</span></div><div class="line">    persistence_timeout 60 <span class="comment">#(同一IP的连接60秒内被分配到同一台realserver)</span></div><div class="line">    protocol TCP <span class="comment">#(用TCP协议检查realserver状态)</span></div><div class="line"></div><div class="line">    real_server 192.168.0.66 80 &#123;</div><div class="line">        weight 100 <span class="comment">#(权重)</span></div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 10 <span class="comment">#(10秒无响应超时)</span></div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 192.168.0.65 80 &#123;</div><div class="line">        weight 100</div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 10</div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以上为主 director 的配置文件，从 director 的配置文件只需要修改如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">state MASTER -&gt; state BACKUP</div><div class="line">priority 100 -&gt; priority 90</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;更改后从配置为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state BACKUP <span class="comment">#主服务器上为 MASTER</span></div><div class="line">    interface eth0</div><div class="line">    virtual_router_id 51</div><div class="line">    priority 90 <span class="comment">#主服务器上为100</span></div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass 1111</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        192.168.0.64</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">virtual_server 192.168.0.64 80 &#123;</div><div class="line">    delay_loop 6 <span class="comment">#(每隔10秒查询realserver状态)</span></div><div class="line">    lb_algo wlc <span class="comment">#(lvs 算法)</span></div><div class="line">    lb_kind DR <span class="comment">#(Direct Route)</span></div><div class="line">    persistence_timeout 60 <span class="comment">#(同一IP的连接60秒内被分配到同一台realserver)</span></div><div class="line">    protocol TCP <span class="comment">#(用TCP协议检查realserver状态)</span></div><div class="line"></div><div class="line">    real_server 192.168.0.66 80 &#123;</div><div class="line">        weight 100 <span class="comment">#(权重)</span></div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 10 <span class="comment">#(10秒无响应超时)</span></div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 192.168.0.65 80 &#123;</div><div class="line">        weight 100</div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 10</div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;配置完成 keepalived 后，需要开启端口转发（主从都要做）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后，两个 rs 上执行 /usr/local/sbin/lvs_dr_rs.sh 脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh /usr/<span class="built_in">local</span>/sbin/lvs_dr_rs.sh</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后，两个 director 上启动 keepalived 服务（先主后从）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/keepalived start</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/keepalived/">keepalived</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/18. 只有一个公网IP也可以使用LVS的DR模式！(外带php session粘滞问题解决）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/18. 只有一个公网IP也可以使用LVS的DR模式！(外带php session粘滞问题解决）/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.043Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/18. 只有一个公网IP也可以使用LVS的DR模式！(外带php session粘滞问题解决）/">
        只有一个公网IP也可以使用LVS的DR模式！(外带php session粘滞问题解决）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/hcldirgit/image/blob/master/%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%AC%E7%BD%91IP%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8LVS%E7%9A%84DR%E6%A8%A1%E5%BC%8F/01.jpeg?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;单个公网ip怎么才能使用LVS的DR模式？倒不是因为没有公网IP，而是由于安全性的考虑不希望服务器都暴漏在外，又不想因为这个小项目买防火墙，所以就提了这个要求。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;怎么样才能实现呢？一个公网IP也可以做DR啊，前面加个路由器就可以了</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;具体结构就想上面那个图那样</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;原理就是让 路由器把所有的80端口请求都分给VIP，分发器再分给每个web服务器，而web服务器处理完请求后跟客户连接就不走分发器了，直接通过路由器去外网了，这样就实现了只用一个公网IP也能用DR模式，呵呵 具体配置如下</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先从内网找了三台服务器分别是：</p>
<ul>
<li>192.168.1.166 web1</li>
<li>192.168.1.167 web2</li>
<li>192.168.1.160 分发器</li>
<li>192.168.1.169 VIP</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;192.168.1.1   路由器内网ip(网关) 路由器是随便找的一台tplink adal路由器，凑合着测试用的</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;211.83.113.119 路由器的WAN口IP </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先安装ipvsadm 直接yum install ipvsadm就行了</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;用的是keepalived，配置文件贴上来，以下是分发器上的设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">        ufo@xman.com</div><div class="line">   &#125;</div><div class="line"></div><div class="line">notification_email_from Alexandre.Cassen@firewall.loc</div><div class="line">   smtp_server smtp.qq.com</div><div class="line">   smtp_connect_timeout 30</div><div class="line">   router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_sync_group VG1 &#123;</div><div class="line">        group&#123;</div><div class="line">        VI_1</div><div class="line">                &#125;</div><div class="line">                    &#125;</div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">        state MASTER</div><div class="line">        interface eth0</div><div class="line">        virtual_router_id 51</div><div class="line">        priority 100</div><div class="line">        advert_int 1</div><div class="line"></div><div class="line">        authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass 33210</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">        virtual_ipaddress &#123;</div><div class="line">        192.168.1.169</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">        virtual_server 192.168.1.169 80 &#123;</div><div class="line">        delay_loop 6</div><div class="line">        lb_algo rr</div><div class="line">        lb_kind DR</div><div class="line">        protocol TCP</div><div class="line"></div><div class="line">                real_server 192.168.1.166 80 &#123;</div><div class="line">                weight 1</div><div class="line">                inhibit_on_failure</div><div class="line">                TCP_CHECK &#123;</div><div class="line">                connect_timeout 5</div><div class="line">                nb_get_retry 3</div><div class="line">                delay_before_retry 3</div><div class="line">                connect_port 80</div><div class="line">                          &#125;</div><div class="line">                                              &#125;</div><div class="line">                real_server 192.168.1.167 80 &#123;</div><div class="line">                weight 1</div><div class="line">                inhibit_on_failure</div><div class="line">                TCP_CHECK &#123;</div><div class="line">                connect_timeout 5</div><div class="line">                nb_get_retry 3</div><div class="line">                delay_before_retry 3</div><div class="line">                connect_port 80</div><div class="line">                          &#125;</div><div class="line">                                              &#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;配置文件写完了，然后就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir /etc/keepalived  <span class="comment">#系统默认会到这里去找配置文件</span></div><div class="line">cp /usr/<span class="built_in">local</span>/keepalive/etc/keepalived/keepalived.conf /etc/keepalived/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalive/etc/rc.d/init.d/keepalived /etc/init.d/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalive/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalive/sbin/keepalived /bin/ <span class="comment">#将可执行程序放入sbin 或者 bin目录里</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.conf</div><div class="line"></div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存退出 后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;route add defaule gw 192.168.1.1 把路由内网地址添加为默认网关</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>web服务器设置</strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;两台web服务器也要修改 /etc/sysctl.conf 修改内容如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.conf</div><div class="line"><span class="comment"># LVS</span></div><div class="line">net.ipv4.conf.all.arp_ignore = 1</div><div class="line">net.ipv4.conf.all.arp_announce = 2</div><div class="line">net.ipv4.conf.lo.arp_ignore = 1</div><div class="line">net.ipv4.conf.lo.arp_announce = 2</div><div class="line">sysctl -p</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;之后还要增加vip</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ifconfig lo:1 192.168.1.169 netmask 255.255.255.255 别忘了加到rc.local里面</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;route add defaule gw 192.168.1.1 把路由内网地址添加为默认网关</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>路由器设置</strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;路由器的设置没什么好说的，除了上网设置以外还要做一个端口映射，就是把80端口映射到 vip上也就是192.168.1.169</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;现在启动keepalived吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/keepalived start</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开始的时候比较慢，大概1分钟后系统日志里面出现下面这条记录就OK了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avahi-daemon[3012]: Registering new address record <span class="keyword">for</span> 192.168.1.169 on eth0</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;访问一下 <a href="http://211.83.113.119" target="_blank" rel="external">http://211.83.113.119</a> 成功了 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ipvsadm -L -n</div><div class="line">IP Virtual Server version 1.2.1 (size=4096)</div><div class="line">Prot LocalAddress:Port Scheduler Flags</div><div class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</div><div class="line">TCP  192.168.1.169:80 rr</div><div class="line">  -&gt; 192.168.1.166:80             Route   1      5          6         </div><div class="line">  -&gt; 192.168.1.167:80             Route   1      3          9</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;后来遇到了一个问题，由于这套应用处在一个大网站的后台，所以大部分的请求都来自同一个IP地址，而有一部分程序需要给每个连接做session粘滞，</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这样就不能用lvs 的-p参数来设置ip粘滞时间，如果用lvs的粘滞时间的话大部分的请求都将分给同一台web服务器(注意：这里是session粘滞而不是IP粘滞)，</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lvs可做不到这点，怎么办呢？</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;解决办法是 将session共享，共享到什么地方就有很多选择了</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里是把所有web服务器的php session都给memcached ，这样不管分发器把 ip连接分给哪个web服务器都不会有问题了，配置方法很简单，就在php的配置文件内</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;增加一条语句就可以了，不过前提需要装好memcache模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[Session]</div><div class="line">; Handler used to store/retrieve data.</div><div class="line">session.save_handler = memcache</div><div class="line">session.save_path = <span class="string">"tcp://192.168.1.161:11213"</span></div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/17. LVS的NAT设置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/17. LVS的NAT设置/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.041Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/17. LVS的NAT设置/">
        LVS的NAT设置
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1.环境说明"></a>1.环境说明</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;三台服务器一台作为 director ，两台作为 real server ，Diretcor 有一个外网 ip （192.168.119.110）和一个内网 ip（192.168.0.67），两个 real server 上只有内网 ip （192.168.0.66）和（192.168.0.65）并且需要把两个 real server 的内网网关设置为 diretcor 的内网 ip （192.168.0.67）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;更改 hostname </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dir 192.168.0.67</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rs1 192.168.0.66</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rs2 192.168.0.65</p>
<h2 id="2-安装和配置"><a href="#2-安装和配置" class="headerlink" title="2.安装和配置"></a>2.安装和配置</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;两个 real server 上都安装 nginx 服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y nginx</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;director 上安装 ipvsadm</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># yum install -y ipvsadm</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Director 上编辑 nat 实现脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># vim /usr/local/sbin/lvs_nat.sh</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;写入一下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment"># director 服务器上开启路由转发功能: </span></div><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward </div><div class="line"><span class="comment"># 关闭icmp的重定向</span></div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/all/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/default/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/eth0/send_redirects</div><div class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/eth1/send_redirects</div><div class="line"></div><div class="line"><span class="comment"># director 设置nat防火墙</span></div><div class="line">iptables -t nat -F</div><div class="line">iptables -t nat -X</div><div class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE</div><div class="line"><span class="comment"># director设置ipvsadm</span></div><div class="line">IPVSADM=<span class="string">'/sbin/ipvsadm'</span></div><div class="line"><span class="variable">$IPVSADM</span> -C</div><div class="line"><span class="variable">$IPVSADM</span> -A -t 192.168.119.110:80 -s lc -p 300</div><div class="line"><span class="variable">$IPVSADM</span> -a -t 192.168.119.110:80 -r 192.168.0.66:80 -m -w 1</div><div class="line"><span class="variable">$IPVSADM</span> -a -t 192.168.119.110:80 -r 192.168.0.65:80 -m -w 1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存后，在 Director 上直接运行这个脚本就可以完成 lvs/nat 的配置了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># sh /usr/local/sbin/lvs_nat.sh</span></div></pre></td></tr></table></figure>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84NAT%E8%AE%BE%E7%BD%AE/01.png?raw=true" alt=""></p>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;通过浏览器测试两台机器上的 web 内容 <a href="http://192.168.119.110" target="_blank" rel="external">http://192.168.119.110</a> 。为了区分开，可以把 nginx 的默认页修改一下</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在 rs1 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rs1 ~]<span class="comment"># echo "rs1rs1" &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在 rs2 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rs2 ~]<span class="comment"># echo "rs2rs2" &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;注意，切记一定要在两台 rs </p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84NAT%E8%AE%BE%E7%BD%AE/02.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;刷新一下</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84NAT%E8%AE%BE%E7%BD%AE/03.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或者使用 curl</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84NAT%E8%AE%BE%E7%BD%AE/04.png?raw=true" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/16. LVS的DR设置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/16. LVS的DR设置/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.040Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/16. LVS的DR设置/">
        LVS的DR设置
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1.环境说明"></a>1.环境说明</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;三台机器</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;director  （eth0： 192.168.0.67， vip eth0:0： 192.168.0.64）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;real server1 （eth0 rip：192.168.0.66 ，vip lo:0：192.168.0.64）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;real server2 （eth0 rip：192.168.0.65 ，vip lo:0：192.168.0.64）</p>
<h2 id="2-编写脚本"><a href="#2-编写脚本" class="headerlink" title="2.编写脚本"></a>2.编写脚本</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;director 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># vim /usr/local/sbin/lvs_dr.sh</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;增加内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">ipv=/sbin/ipvsadm</div><div class="line">vip=192.168.0.64</div><div class="line">rs1=192.168.0.66</div><div class="line">rs2=192.168.0.65</div><div class="line">ifconfig eth0:0 <span class="variable">$vip</span> broadcast <span class="variable">$vip</span> netmask 255.255.255.255 up</div><div class="line">route add -host <span class="variable">$vip</span> dev eth0:0</div><div class="line"><span class="variable">$ipv</span> -C</div><div class="line"><span class="variable">$ipv</span> -A -t <span class="variable">$vip</span>:80 -s rr </div><div class="line"><span class="variable">$ipv</span> -a -t <span class="variable">$vip</span>:80 -r <span class="variable">$rs1</span>:80 -g -w 1</div><div class="line"><span class="variable">$ipv</span> -a -t <span class="variable">$vip</span>:80 -r <span class="variable">$rs2</span>:80 -g -w 1</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;保存后在两台 rs 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/sbin/lvs_dr_rs.sh</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;增加内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line">vip=192.168.0.64</div><div class="line">ifconfig lo:0 <span class="variable">$vip</span> broadcast <span class="variable">$vip</span> netmask 255.255.255.255 up </div><div class="line">route add -host <span class="variable">$vip</span> lo:0</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于 arp_ignore 和 arp_announce 参考：<a href="https://hcldirgit.github.io/2017/08/07/15.%20LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%ADarp_ignore%E5%92%8Carp_annonuce%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%9A%84%E5%90%AB%E4%B9%89/">LVS负载均衡中arp_ignore和arp_annonuce参数配置的含义</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;然后 driector 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@dir ~]<span class="comment"># sh /usr/local/sbin/lvs_dr.sh</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;两台 rs 上执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh /usr/<span class="built_in">local</span>/sbin/lvs_dr_rs.sh</div></pre></td></tr></table></figure>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;windows 下浏览器测试访问 <a href="http://192.168.0.64" target="_blank" rel="external">http://192.168.0.64</a></p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84DR%E8%AE%BE%E7%BD%AE/03.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;更换浏览器</p>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84DR%E8%AE%BE%E7%BD%AE/01.png?raw=true" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;或者换台计算机用 curl</p>
<p> <img src="https://github.com/hcldirgit/image/blob/master/LVS%E7%9A%84DR%E8%AE%BE%E7%BD%AE/02.png?raw=true" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/15. LVS负载均衡中arp_ignore和arp_annonuce参数配置的含义" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/15. LVS负载均衡中arp_ignore和arp_annonuce参数配置的含义/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.039Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/15. LVS负载均衡中arp_ignore和arp_annonuce参数配置的含义/">
        LVS负载均衡中arp_ignore和arp_annonuce参数配置的含义
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先简单的介绍下关于LVS负载均衡</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LVS（Linux  Virtual Server）Linux服务器集群系统</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;针对高可伸缩，高可用服务的需求，给予IP层和内容请求分发的负载均衡调度解决方法，并在Linux的内核中实现，将一组服务器构成一个实现可伸缩，高可用网络服务的虚拟服务器</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ol>
<li>大量的兵法访问或数据流量分担到多态节点设备分别处理，减少用户的等待时间</li>
<li>单个重负载的运算分担到多态节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户</li>
</ol>
<h2 id="负载调度器"><a href="#负载调度器" class="headerlink" title="负载调度器"></a>负载调度器</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一组服务器通过高速的局域网或者地理分布的广域网相互相连，在他们的前端有一个负载均衡调度器（Load Balancer），负载均衡调度器能无缝的将网络请求调度到真实的服务器上，从而使得服务器集群的结构对用户是透明的，用户通过访问集群系统提供的网络服务，就像访问一台高性能，高可用的服务器。</p>
<h2 id="IP负载均衡技术（三种）"><a href="#IP负载均衡技术（三种）" class="headerlink" title="IP负载均衡技术（三种）"></a>IP负载均衡技术（三种）</h2><ol>
<li><p>VS/NAT（网络地址转换）<br>通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分发给后端的真实服务器，真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回到客户端，完成整个调度的过程</p>
</li>
<li><p>VS/TUN（IP隧道模式）<br>调度器将请求的报文通过IP隧道转发至真实服务器，而真实的服务器直接将结果返回给用户，调度器只处理请求报文，由于一般网路服务的应答大于请求，采用IP隧道模式，集群系统的最大吞吐量可以提高10倍。</p>
</li>
<li><p>VS/DR（直接路由）<br>通过改写请求报文的MAC地址，将请求发送到真是服务器，真实服务器将响应直接返回给用户，之际额路由模式可以极大的提高集群系统的伸缩性，这种方法没有IP隧道的开销，集群中真实的服务器也没有必要必须支持IP隧道协议，只是需要调度器与真实服务器有一块网卡连在同一物理网段上。</p>
</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其中在这三种IP负载均衡的技术中，DR和TUN模式都需要在真实服务器上对arp_ignore和arp_announce参数进行配置，主要是实现禁止响应对VIP的ARP请求。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在lvs环境中，需要设定以下的参数 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt; /proc/sys/net/ipv4/conf/all/arp_announce</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;先来看看关于arp_ignore和arp_announce的有关介绍</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;有关<strong>arp_ignore</strong>的相关介绍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arp_ignore - INTEGER Define different modes <span class="keyword">for</span> sending replies <span class="keyword">in</span> response to received ARP requests that resolve <span class="built_in">local</span> target IP addresses: 0 - (default): reply <span class="keyword">for</span> any <span class="built_in">local</span> target IP address, configured on any interface 1 - reply only <span class="keyword">if</span> the target IP address is <span class="built_in">local</span> address configured on the incoming interface 2 - reply only <span class="keyword">if</span> the target IP address is <span class="built_in">local</span> address configured on the incoming interface and both with the sender<span class="string">'s IP address are part from same subnet on this interface 3 - do not reply for local addresses configured with scope host, only resolutions for global and link addresses are replied 4-7 - reserved 8 - do not reply for all local addresses The max value from conf/&#123;all,interface&#125;/arp_ignore is used when ARP request is received on the &#123;interface&#125;</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arp_ignore:定义对目标地址为本地IP的ARP询问不同的应答模式0 </p>
<ul>
<li>0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求 </li>
<li>1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求 </li>
<li>2 -只回答目标IP地址是来访网络接口本地地址的ARP查询请求,且来访IP必须在该网络接口的子网段内 </li>
<li>3 - 不回应该网络界面的arp请求，而只对设置的唯一和连接地址做出回应 </li>
<li>4-7 - 保留未使用 </li>
<li>8 -不回应所有（本地地址）的arp查询</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;有关<strong>arp_announce</strong>的相关介绍：</p>
<blockquote>
<p>arp_announce - INTEGER Define different restriction levels for announcing the local source IP address from IP packets in ARP requests sent on interface: 0 - (default) Use any local address, configured on any interface 1 - Try to avoid local addresses that are not in the target’s subnet for this interface. This mode is useful when target hosts reachable via this interface require the source IP address in ARP requests to be part of their logical network configured on the receiving interface. When we generate the request we will check all our subnets that include the target IP and will preserve the source address if it is from such subnet. If there is no such subnet we select source address according to the rules for level 2. 2 - Always use the best local address for this target. In this mode we ignore the source address in the IP packet and try to select local address that we prefer for talks with the target host. Such local address is selected by looking for primary IP addresses on all our subnets on the outgoing interface that include the target IP address. If no suitable local address is found we select the first local address we have on the outgoing interface or on all other interfaces, with the hope we will receive reply for our request and even sometimes no matter the source IP address we announce. The max value from conf/{all,interface}/arp_announce is used. Increasing the restriction level gives more chance for receiving answer from the resolved target while decreasing the level announces more valid sender’s information.</p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arp_announce:对网络接口上，本地IP地址的发出的，ARP回应，作出相应级别的限制: 确定不同程度的限制,宣布对来自本地源IP地址发出Arp请求的接口 </p>
<ul>
<li>0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址 </li>
<li>1 -尽量避免不在该网络接口子网段的本地地址做出arp回应. 当发起ARP请求的源IP地址是被设置应该经由路由达到此网络接口的时候很有用.此时会检查来访IP是否为所有接口上的子网段内ip之一.如果改来访IP不属于各个网络接口上的子网段内,那么将采用级别2的方式来进行处理. </li>
<li>2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. 如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于对arp_announce 理解的一点补充 </p>
<blockquote>
<p>Assume that a linux box X has three interfaces - eth0, eth1 and eth2. Each interface has an IP address IP0,<br>IP1 and IP2. When a local application tries to send an IP packet with IP0 through the eth2. Unfortunately,<br>the target node’s mac address is not resolved. Thelinux box X will send the ARP request to know<br>the mac address of the target(or the gateway). In this case what is the IP source address of the<br>“ARP request message”? The IP0- the IP source address of the transmitting IP or IP2 - the outgoing<br> interface? Until now(actually just 3 hours before) ARP request uses the IP address assigned to<br>the outgoing interface(IP2 in the above example) However the linux’s behavior is a little bit<br>different. Actually the selection of source address in ARP request is totally configurable<br>bythe proc variable “arp_announce”<br>If we want to use the IP2 not the IP0 in the ARP request, we should change the value to 1 or 2.<br>The default value is 0 - allow IP0 is used for ARP request.</p>
</blockquote>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其实就是路由器的问题，因为路由器一般是动态学习ARP包的（一般动态配置DHCP的话），当内网的机器要发送一个到外部的ip包，那么它就会请求 路由器的Mac地址，发送一个arp请求，这个arp请求里面包括了自己的ip地址和Mac地址，而linux默认是使用ip的源ip地址作为arp里面 的源ip地址，而不是使用发送设备上面的 ，这样在lvs这样的架构下，所有发送包都是同一个VIP地址，那么arp请求就会包括VIP地址和设备 Mac，而路由器收到这个arp请求就会更新自己的arp缓存，这样就会造成ip欺骗了，VIP被抢夺，所以就会有问题。  </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arp缓存为什么会更新了，什么时候会更新呢，为了减少arp请求的次数，当主机接收到询问自己的arp请求的时候，就会把源ip和源Mac放入自 己的arp表里面，方便接下来的通讯。如果收到不是询问自己的包（arp是广播的，所有人都收到），就会丢掉，这样不会造成arp表里面无用数据太多导致 有用的记录被删除。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在设置参数的时候将arp_ignore 设置为1，意味着当别人的arp请求过来的时候，如果接收的设备上面没有这个ip，就不做出响应，默认是0，只要这台机器上面任何一个设备上面有这个ip，就响应arp请求，并发送mac地址</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/13. LB 集群之 LVS 介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/13. LB 集群之 LVS 介绍/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.038Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/13. LB 集群之 LVS 介绍/">
        LB 集群之 LVS 介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LB 集群是 load balance 集群的简写，翻译成中文就是负载均衡集群。常用的负载均衡开源软件有 nginx 、lvs 、keepalived ，商业的硬件负载设备 F5 、Netscale 。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LB 集群的架构如下图，原理也很简单，就是当用户的请求过来时，会直接发到分发器（Director Server）上，然后它把用户的请求根据预先设置好的算法，智能均衡地分发到后端的真正服务器（real server）上。如果不同的机器，可能用户请求到的数据不一样，为了避免这样的情况发生，所以用到了共享存储，这样保证所有用户请求的数据是一样的。</p>
<p><img src="" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LVS 是一个实现负载均衡集群的开源软件项目，LVS 架构从罗技上可分为调度层（Director）、server 集群层（real server）和共享存储。 LVS 从实现上分为下面三种模式。</p>
<ol>
<li>NAT （调度器将请求的目标 ip 即 vip 地址改为 real server 的 ip ，返回的数据包也经过调度器，调度器再把源地址修改为 vip）。</li>
</ol>
<p><img src="" alt=""></p>
<ol>
<li><p>TUN （调度器将请求来的数据包封装加密通过 ip 隧道转发到后端的 real server 上，而 real server 会直接把数据返回给客户端，而不再经过调度器）。</p>
</li>
<li><p>DR （调度器将请求来的数据包的目标 mac 地址改为 real server 的 mac 地址，返回的时候也不经过调度器，直接返回给客户端）。参考资料<a href="https://hcldirgit.github.io/2017/08/07/9.%20LVS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E9%83%A8%E7%BD%B2%E4%B9%8B%E4%BA%8C%EF%BC%9ALVS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%883%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F8%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/">LVS原理详解及部署之二：LVS原理详解（3种工作方式8种调度算法）</a></p>
</li>
</ol>
<p><img src="" alt=""></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;图中出现的几个 IP 概念，需要解释一下，其中 DIP（driector ip）为分发器的 IP， NAT 模式下它必须为公网 IP ，要对外服务。VIP （virtual ip）为虚拟 IP ，用在 TUN 和 DR 模式中，需要同时配置在分发器和后端真实服务器上。RIP （Resl IP）为后端真实服务器的 IP ，在 TUN 和 DR 模式中，RIP 为公网 IP。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;要想把用户的请求调度给后端的 RS ,是需要经过调度算法来实现的，那么关于 LVS 的调度算法，都有哪些？</p>
<ul>
<li>轮叫调度（Round Robin）（简称 rr），这种算法是最简单的，不管后端 RS 配置和处理能力，非常均衡地分发下去。</li>
<li>加权调度（Weighted Round Robin）（简称 wrr），比上面的算法多了一个权重的概念，可以给 RS 设置权重，权重越高，那么分发的请求越多，权重取值范围 0-100</li>
<li>最少连接（least connection）（LC），这个算法会根据后端 RS 的连接数来决定把请求分给谁，比如 RS1 连接数比 RS2 连接数少，那么请求就优先发给 - 加权最少链接（Weighted Least Connections）（WLC），比第三个算法多了一个权重的概念。</li>
</ul>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;其他算法参考<a href="https://hcldirgit.github.io/2017/08/07/14.%20LVS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">LVS调度算法</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/14. LVS调度算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/14. LVS调度算法/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.038Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/14. LVS调度算法/">
        LVS调度算法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LVS主要的调度算法</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;轮询调度-加权轮询调度-最小连接调度-加权最小连接调度-基于局部性的最少连接-带复制的基于局部性的最少连接-目标地址散列调度-源地址散列调度</p>
<ol>
<li><p>轮询算法(RR)就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都是一样的，调度器会将所有的请求平均分配给每个真实服务器</p>
</li>
<li><p>加权轮询算法(WRR)主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p>
</li>
<li><p>最小连接调度算法(LC)将把请求调度到连续数量最小的服务器上，</p>
</li>
<li><p>加权最小连接算法(WLC)则是给每台服务器一个权值，调度器会尽可能保持服务器连接数量与权值之间的平衡</p>
</li>
<li><p>基于局部性的最少连接调度算法(lblc)是请求数据包的目标IP地址的一种调度算法，该算法先根据请求的目标IP地址寻找最近的该目标IP地址所有使用的服务器，如果这台服务器依然可用，并且用能力处理该请求，调度器会尽量选择相同的服务器，否则会继续选择其他可行的服务器。</p>
</li>
<li><p>带复杂的基于局部性最少的连接算法(lblcr)激励的不是一个目标IP与一台服务器之间的连接记录，他会维护一个目标IP到一组服务器之间的映射关系，防止单点服务器负责过高</p>
</li>
<li><p>目标地址散列调度算法(DH)也是根据目标IP地址通过散列函数将目标IP与服务器建立映射关系，出现服务器不可用或负载过高的情况下，发往该目标IP的请求会固定发给该服务器。</p>
</li>
<li><p>源地址散列调度算法(SH)与目标地址散列调度算法类似，但它是根据源地址散列算法进行静态分配固定的服务器资源</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/12. LVS原理详解及部署之五：LVS+keepalived实现负载均衡&amp;高可用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/12. LVS原理详解及部署之五：LVS+keepalived实现负载均衡&高可用/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.037Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/12. LVS原理详解及部署之五：LVS+keepalived实现负载均衡&高可用/">
        LVS原理详解及部署之五：LVS+keepalived实现负载均衡&amp;高可用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、实验环境需求-amp-准备"><a href="#一、实验环境需求-amp-准备" class="headerlink" title="一、实验环境需求&amp;准备"></a>一、实验环境需求&amp;准备</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这次实验要完成的一个架构如下图所示，通过LVS-DR-MASTER,LVS-DR-BACKUP作为LVS负载均衡调度器，并且两者之间通过keepalived来两者之间的HA。keepalived本身就是为了LVS为开发的，所以说通过keepalived来进行LVS的配置就显得十分的方便。而且keepalived是直接操作ip_vs不用通过ipvsadm，所以更加方便。</p>
<ol>
<li>实验架构图&amp;需求表：</li>
</ol>
<p><img src="https://github.com/hcldirgit/image/blob/master/LVS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E9%83%A8%E7%BD%B2%E4%B9%8B%E4%BA%94%EF%BC%9ALVS+keepalived%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&amp;%E9%AB%98%E5%8F%AF%E7%94%A8/01.jpeg?raw=true" alt=""></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>IP地址</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>主LVS调度器（MASTER)</td>
<td>192.168.41.181</td>
<td>使用keepalived配置备</td>
</tr>
<tr>
<td>LVS调度器（BACKUP)</td>
<td>192.168.41.25</td>
<td>&#160;</td>
</tr>
<tr>
<td>1HTTP服务器（RS1)</td>
<td>192.168.41.31</td>
<td>apache服务器（一般生产环境需要外网IP地址，这里用内网IP地址替代）</td>
</tr>
<tr>
<td>HTTP服务器（RS2)</td>
<td>192.168.41.33</td>
<td>&#160;</td>
</tr>
<tr>
<td>虚拟IP地址（VIP)</td>
<td>192.168.41.249</td>
<td>虚拟IP地址</td>
</tr>
</tbody>
</table>
<ol>
<li>部署http服务器，验证能正常访问</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这里就是要保证http能正常访问。</p>
<h2 id="二、配置keepalived实现负载均衡-amp-高可用"><a href="#二、配置keepalived实现负载均衡-amp-高可用" class="headerlink" title="二、配置keepalived实现负载均衡&amp;高可用"></a>二、配置keepalived实现负载均衡&amp;高可用</h2><h3 id="安装keepalived软件"><a href="#安装keepalived软件" class="headerlink" title="安装keepalived软件"></a>安装keepalived软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget http://www.keepalived.org/software/keepalived-1.2.8.tar.gz</div><div class="line">tar -zxf keepalived-1.2.8.tar.gz</div><div class="line"><span class="built_in">cd</span> keepalived-1.2.8</div><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;配置keepalived的自启动&amp;拷贝keepalived的执行程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开启内核的转发功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysctl  net.ipv4.ip_forword = 1</div></pre></td></tr></table></figure>
<h3 id="配置LVS-DR-MASK的keepalived-conf配置文件"><a href="#配置LVS-DR-MASK的keepalived-conf配置文件" class="headerlink" title="配置LVS-DR-MASK的keepalived.conf配置文件"></a>配置LVS-DR-MASK的keepalived.conf配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">! Configuration File <span class="keyword">for</span> keepalived</div><div class="line">global_defs &#123;</div><div class="line"> notification_email &#123;</div><div class="line"> 752119102@qq.com <span class="comment">#设置报警邮箱，一般不再这做，而是用其他方式报警。</span></div><div class="line"> &#125;</div><div class="line"> notification_email_from keepalived@localhost <span class="comment">#设定发送邮件地址</span></div><div class="line"> smtp_server 127.0.0.1 <span class="comment">#设定发送邮件服务器</span></div><div class="line"> smtp_connect_timeout 30 <span class="comment">#设定SMTP连接超时时间</span></div><div class="line"> router_id LVS_DEVEL <span class="comment">#查阅说明文档得知route_id配置是为了标识当前节点，我将其设置为NodeA。当然两个节点的此项设置可相同，也可不相同。</span></div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123; <span class="comment">#定义虚拟路由实例，不同实例ID不同。</span></div><div class="line"> state MASTER  <span class="comment">#定义服务器在keepalived中的角色主服务器</span></div><div class="line"> interface eth0 <span class="comment">#定义进行检测的端口eth0</span></div><div class="line"> virtual_router_id 51 <span class="comment">#定义虚拟路由ID，同一个实例的主从一样。</span></div><div class="line"> priority 100  <span class="comment">#定义在虚拟路由器组的权限，越大越高</span></div><div class="line"> advert_int 1 <span class="comment">#定义检测时间间隔</span></div><div class="line"> authentication &#123; <span class="comment">#定义认证方式密码，主从必须一样</span></div><div class="line"> auth_type PASS</div><div class="line"> auth_pass 1111</div><div class="line"> &#125;</div><div class="line"> virtual_ipaddress &#123; <span class="comment">#指定虚拟IP地址</span></div><div class="line"> 192.168.41.249</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">virtual_server 192.168.41.249 80 &#123; <span class="comment">#定义虚拟服务，需指定IP地址和端口，空格隔开。</span></div><div class="line"> delay_loop 6  <span class="comment">#定义RS运行情况监测时间间隔</span></div><div class="line"> lb_algo rr  <span class="comment">#定义负载调度算法</span></div><div class="line"> lb_kind DR <span class="comment">#定义LVS的工作模式</span></div><div class="line"> nat_mask 255.255.255.0 <span class="comment">#定义虚拟服务的mask</span></div><div class="line"> persistence_timeout 50 <span class="comment">#定义会话保持时间，S为单位</span></div><div class="line"> protocol TCP <span class="comment">#指定转发协议</span></div><div class="line"> real_server 192.168.41.31 80 &#123; <span class="comment">#定义真实服务器IP地址和端口</span></div><div class="line"> weight 1 <span class="comment">#定义RS的权重</span></div><div class="line"> TCP_CHECK&#123; <span class="comment">#RS server健康检查部分</span></div><div class="line"> connect_timeout 10 <span class="comment">#定义超出10s连接超时</span></div><div class="line"> nb_get_retry 3 <span class="comment">#定义重试次数</span></div><div class="line"> delay_before_retry 3 <span class="comment">#定义重试时间间隔</span></div><div class="line"> connect_port 80 <span class="comment">#定义健康检查端口</span></div><div class="line"> &#125;</div><div class="line"> real_server 192.168.41.33 80 &#123; </div><div class="line"> weight 1</div><div class="line"> TCP_CHECK&#123; </div><div class="line"> connect_timeout 10 </div><div class="line"> nb_get_retry 3 </div><div class="line"> delay_before_retry 3 </div><div class="line"> connect_port 80 </div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="配置LVS-DR-BACKUP的keepalived-conf配置文件"><a href="#配置LVS-DR-BACKUP的keepalived-conf配置文件" class="headerlink" title="配置LVS-DR-BACKUP的keepalived.conf配置文件"></a>配置LVS-DR-BACKUP的keepalived.conf配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">! Configuration File <span class="keyword">for</span> keepalived</div><div class="line">global_defs &#123;</div><div class="line"> notification_email &#123;</div><div class="line"> 752119102@qq.com <span class="comment">#设置报警邮箱，一般不再这做，而是用其他方式报警。</span></div><div class="line"> &#125;</div><div class="line"> notification_email_from keepalived@localhost <span class="comment">#设定发送邮件地址</span></div><div class="line"> smtp_server 127.0.0.1 <span class="comment">#设定发送邮件服务器</span></div><div class="line"> smtp_connect_timeout 30 <span class="comment">#设定SMTP连接超时时间</span></div><div class="line"> router_id LVS_DEVEL  <span class="comment">#负载均衡器标示，在局域网内是唯一的</span></div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123; <span class="comment">#定义虚拟路由实例，不同实例ID不同。</span></div><div class="line"> state BACKUP  <span class="comment">#定义服务器在keepalived中的角色</span></div><div class="line"> interface eth0 <span class="comment">#定义进行检测的端口eth0</span></div><div class="line"> virtual_router_id 51 <span class="comment">#定义虚拟路由ID，同一个实例的主从一样。</span></div><div class="line"> priority 50  <span class="comment">#定义在虚拟路由器组的权限，越大越高</span></div><div class="line"> advert_int 1 <span class="comment">#定义检测时间间隔</span></div><div class="line"> authentication &#123; <span class="comment">#定义认证方式密码，主从必须一样</span></div><div class="line"> auth_type PASS</div><div class="line"> auth_pass 1111</div><div class="line"> &#125;</div><div class="line"> virtual_ipaddress &#123; <span class="comment">#指定虚拟IP地址</span></div><div class="line"> 192.168.41.249</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">virtual_server 192.168.41.249 80 &#123; <span class="comment">#定义虚拟服务，需指定IP地址和端口，空格隔开。</span></div><div class="line"> delay_loop 6 <span class="comment">#定义RS运行情况监测时间间隔</span></div><div class="line"> lb_algo rr <span class="comment">#定义负载调度算法</span></div><div class="line"> lb_kind DR <span class="comment">#定义LVS的工作模式</span></div><div class="line"> nat_mask 255.255.255.0 <span class="comment">#定义虚拟服务的mask</span></div><div class="line"> persistence_timeout 50 <span class="comment">#定义会话保持时间，S为单位</span></div><div class="line"> protocol TCP <span class="comment">#指定转发协议</span></div><div class="line"> real_server 192.168.41.31 80 &#123; <span class="comment">#定义真实服务器IP地址和端口</span></div><div class="line"> weight 1 <span class="comment">#定义RS的权重</span></div><div class="line"> TCP_CHECK&#123; <span class="comment">#RS server健康检查部分</span></div><div class="line"> connect_timeout 10 <span class="comment">#定义超出10s连接超时</span></div><div class="line"> nb_get_retry 3 <span class="comment">#定义重试次数</span></div><div class="line"> delay_before_retry 3 <span class="comment">#定义重试时间间隔</span></div><div class="line"> connect_port 80 <span class="comment">#定义健康检查端口</span></div><div class="line"> &#125;</div><div class="line"> real_server 192.168.41.33 80 &#123; </div><div class="line"> weight 1</div><div class="line"> TCP_CHECK&#123; </div><div class="line"> connect_timeout 10 </div><div class="line"> nb_get_retry 3 </div><div class="line"> delay_before_retry 3 </div><div class="line"> connect_port 80 </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说明：这里主LVS-DR-MASTER和LVS-DR-BACKUP之间的配置的差别就只有红色部分：HA的角色（MASTER,BACKUP)和优先级不同，还有router_id。</p>
<h3 id="客户端配置LVS参数"><a href="#客户端配置LVS参数" class="headerlink" title="客户端配置LVS参数"></a>客户端配置LVS参数</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;客户端需要做的工作就是绑定我们的VIP在lo口，并且进行ARP抑制，之前的文章已经提过此方法咯。现在我们就换成将配置写成脚本来执行。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">[root@RS2 ~]<span class="comment"># cat lvs-client.sh</span></div><div class="line"><span class="comment">#!/bin/bask</span></div><div class="line"><span class="comment"># 752119102@qq.com</span></div><div class="line"><span class="comment">#</span></div><div class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></div><div class="line">VIP=(</div><div class="line">192.168.41.249</div><div class="line">)</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>()&#123;</div><div class="line"> <span class="keyword">for</span> ((i=0;i&lt;`<span class="built_in">echo</span> <span class="variable">$&#123;#VIP[*]&#125;</span>`;i++))</div><div class="line"> <span class="keyword">do</span></div><div class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span> <span class="variable">$&#123;VIP[$i]&#125;</span></div><div class="line"> ifconfig lo:<span class="variable">$&#123;i&#125;</span> <span class="variable">$&#123;VIP[$i]&#125;</span> netmask 255.255.255.255 up</div><div class="line"> route add -host <span class="variable">$&#123;VIP[$i]&#125;</span> dev lo</div><div class="line"> <span class="keyword">done</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">stop</span></span>()&#123;</div><div class="line"> <span class="keyword">for</span> ((i=0;i&lt;<span class="variable">$&#123;#VIP[*]&#125;</span>;i++))</div><div class="line"> <span class="keyword">do</span></div><div class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span> <span class="variable">$&#123;VIP[$i]&#125;</span></div><div class="line"> ifconfig lo:<span class="variable">$&#123;i&#125;</span> <span class="variable">$&#123;VIP[$i]&#125;</span> netmask 255.255.255.255 up</div><div class="line"> route del -host <span class="variable">$&#123;VIP[$i]&#125;</span> dev lo:<span class="variable">$&#123;i&#125;</span></div><div class="line"> <span class="keyword">done</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line"> start)</div><div class="line"> start</div><div class="line"> <span class="built_in">exit</span></div><div class="line"> ;;</div><div class="line"> stop)</div><div class="line"> stop</div><div class="line"> <span class="built_in">exit</span></div><div class="line"> ;;</div><div class="line"> *)</div><div class="line"> <span class="built_in">echo</span> <span class="string">"You must use <span class="variable">$0</span>:stop|start"</span></div><div class="line"> ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
<h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果测试部成功可以按照三角的排查原理来进行排查，显示client到RS端是否能通讯，LB到RS能否通讯，client到LB是否能通讯，client到VIP是否能够通讯。并且查看LVS的运行状态。一定要确保keepalived.conf这个配置文件是正确的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LVS/11. LVS原理详解及部署之四：keepalived介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/03/LVS/11. LVS原理详解及部署之四：keepalived介绍/" class="article-date">
  	<time datetime="2017-09-02T18:04:46.035Z" itemprop="datePublished">2017-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/03/LVS/11. LVS原理详解及部署之四：keepalived介绍/">
        LVS原理详解及部署之四：keepalived介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、keepalived原理介绍"><a href="#一、keepalived原理介绍" class="headerlink" title="一、keepalived原理介绍"></a>一、keepalived原理介绍</h2><h3 id="keepalived简介"><a href="#keepalived简介" class="headerlink" title="keepalived简介"></a>keepalived简介</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Keepalived的功能有点像是两个人互相看着一个工作，如果一个人离开岗位另外一个人就会接替，这个keepalived就是他们之间保持这样“替换机制”的工具。keepalived是一个类似于layer3, 4 &amp; 5交换机制的软件，也就是我们平时说的第3层、第4层和第5层交换。Keepalived的作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Keepalived服务主要有两大用途：heartbeat（高可用）&amp;failover（健康检测）</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Keepalived服务主要截图vrrp来完成这些工作的，以下我就来介绍下VRRP协议是怎样的工作的，那么基本上keepalived的工作原理就是如此。</p>
<h3 id="VRRP协议（VRRP-Virtual-Router-Redundancy-Protocol，虚拟路由冗余协议）"><a href="#VRRP协议（VRRP-Virtual-Router-Redundancy-Protocol，虚拟路由冗余协议）" class="headerlink" title="VRRP协议（VRRP Virtual Router Redundancy Protocol，虚拟路由冗余协议）"></a>VRRP协议（VRRP Virtual Router Redundancy Protocol，虚拟路由冗余协议）</h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>VRRP协议过程简述</strong>：VRRP 将局域网的一组路由器（包括一个Master 即活动路由器和若干个Backup 即备份路由器）组织成一个虚拟路由器，称之为一个备份组。这个虚拟的路由器拥有自己的IP 地址10.100.10.1（这个IP 地址可以和备份组内的某个路由器的接口地址相同，相同的则称为ip拥有者），备份组内的路由器也有自己的IP 地址（如Master的IP 地址为10.100.10.2，Backup 的IP 地址为10.100.10.3）。局域网内的主机仅仅知道这个虚拟路由器的IP 地址10.100.10.1，而并不知道具体的Master 路由器的IP 地址10.100.10.2 以及Backup 路由器的IP 地址10.100.10.3。[1]它们将自己的缺省路由下一跳地址设置为该虚拟路由器的IP 地址10.100.10.1。于是，网络内的主机就通过这个虚拟的路由器来与其它网络进行通信。如果备份组内的Master 路由器坏掉，Backup 路由器将会通过选举策略选出一个新的Master 路由器，继续向网络内的主机提供路由服务。从而实现网络内的主机不间断地与外部网络进行通信。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>VRRP原理</strong>：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一个VRRP路由器有唯一的标识：VRID，范围为0—255该路由器对外表现为唯一的虚拟MAC地址，地址的格式为00-00-5E-00-01-[VRID]主控路由器负责对ARP请求用该MAC地址做应答这样,无论如何切换，保证给终端设备的是唯一一致的IP和MAC地址，减少了切换对终端设备的影响[3]</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;VRRP控制报文只有一种：VRRP通告(advertisement)它使用IP多播数据包进行封装，组地址为224.0.0.18，发布范围只限于同一局域网内这保证了VRID在不同网络中可以重复使用为了减少网络带宽消耗只有主控路由器才可以周期性的发送VRRP通告报文备份路由器在连续三个通告间隔内收不到VRRP或收到优先级为0的通告后启动新的一轮VRRP选举[3]</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在VRRP路由器组中，按优先级选举主控路由器，VRRP协议中优先级范围是0—255若VRRP路由器的IP地址和虚拟路由器的接口IP地址相同，则称该虚拟路由器作VRRP组中的IP地址所有者；IP地址所有者自动具有最高优先级：255优先级0一般用在IP地址所有者主动放弃主控者角色时使用可配置的优先级范围为1—254优先级的配置原则可以依据链路的速度和成本路由器性能和可靠性以及其它管理策略设定主控路由器的选举中，高优先级的虚拟路由器获胜，因此，如果在VRRP组中有IP地址所有者，则它总是作为主控路由的角色出现对于相同优先级的候选路由器，按照IP地址大小顺序选举VRRP还提供了优先级抢占策略，如果配置了该策略，高优先级的备份路由器便会剥夺当前低优先级的主控路由器而成为新的主控路由器[3]</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;为了保证VRRP协议的安全性，提供了两种安全认证措施：明文认证和IP头认证明文认证方式要求：在加入一个VRRP路由器组时，必须同时提供相同的VRID和明文密码适合于避免在局域网内的配置错误，但不能防止通过网络监听方式获得密码IP头认证的方式提供了更高的安全性，能够防止报文重放和修改等攻击。</p>
<h2 id="二、部署keepalived作为web服务器的HA"><a href="#二、部署keepalived作为web服务器的HA" class="headerlink" title="二、部署keepalived作为web服务器的HA"></a>二、部署keepalived作为web服务器的HA</h2><ol>
<li>部署两台apache web服务器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install httpd -y </div><div class="line">/etc/init.d/httpd start</div></pre></td></tr></table></figure>
<ol>
<li>分别安装keepalived软件</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下载安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http://www.keepalived.org/software/keepalived-1.2.8.tar.gz</div><div class="line">tar -zxf keepalived-1.2.8.tar.gz</div><div class="line"><span class="built_in">cd</span> keepalived-1.2.8</div><div class="line">ll</div><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;配置keepalived的自启动&amp;拷贝keepalived的执行程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp /usr/<span class="built_in">local</span>/keepalive/sbin/keepalived/ /usr/sbin/</div><div class="line">cp cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin//usr/<span class="built_in">local</span>/keepalived/sbin/keepalived</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/</div></pre></td></tr></table></figure>
<ol>
<li>编辑主web和备web的keepalived配置文件</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主web服务器的配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@localhost keepalived-1.2.8]<span class="comment"># cat /etc/keepalived.conf </span></div><div class="line">! Configuration File <span class="keyword">for</span> keepalived</div><div class="line">global_defs &#123;</div><div class="line"> notification_email &#123; <span class="comment">#设置报警邮件地址，可多行每行一个。</span></div><div class="line"> 752119102@qq.com</div><div class="line"> &#125;</div><div class="line"> notification_email_from keepalived@localhost <span class="comment">#设置邮件的发送地址</span></div><div class="line"> smtp_server 127.0.0.1 <span class="comment">#设置SMTP server地址</span></div><div class="line"> smtp_connect_timeout 30 <span class="comment">#设置SMTP 超时时间</span></div><div class="line"> router_id LVS_DEVEL <span class="comment">#运行keepalived机器的一个标识</span></div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123; <span class="comment">#定义一个vrrp实例，不同实例的实例编号不一样。</span></div><div class="line"> state MASTER <span class="comment">#定义在keepalived的角色MASTER表示为主服务器，BACKUP为备服务器。</span></div><div class="line"> interface eth0 <span class="comment">#指定HA检测的网络接口</span></div><div class="line"> virtual_router_id 51 <span class="comment">#虚拟路由标示，同一个实例里的路由标示相同，且唯一。MASTER和BACKUP的路由标识一样，且唯一。</span></div><div class="line"> priority 100 <span class="comment">#定义此服务器在此虚拟路由器中的优先级，优先级大权限高</span></div><div class="line"> advert_int 1 <span class="comment">#检测时间间隔</span></div><div class="line"> authentication &#123; <span class="comment">#设置验证类型和密码，主从的密码必须相同，要不两者不通讯。</span></div><div class="line"> auth_type PASS</div><div class="line"> auth_pass 1111</div><div class="line"> &#125;</div><div class="line"> virtual_ipaddress &#123; <span class="comment">#设置虚拟IP地址，可以设置多个虚拟IP地址。</span></div><div class="line"> 192.168.41.249</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;备web服务器的配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># cat /etc/keepalived.conf</span></div><div class="line">! Configuration File <span class="keyword">for</span> keepalived</div><div class="line">global_defs &#123;</div><div class="line"> notification_email &#123;</div><div class="line"> 752119102@qq.com</div><div class="line"> &#125;</div><div class="line"> notification_email_from keepalive@localhost</div><div class="line"> smtp_server 127.0.0.1</div><div class="line"> smtp_connect_timeout 30</div><div class="line"> router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line"> state BACKUP</div><div class="line"> interface eth0</div><div class="line"> virtual_router_id 51</div><div class="line"> priority 50</div><div class="line"> advert_int 1</div><div class="line"> authentication &#123;</div><div class="line"> auth_type PASS</div><div class="line"> auth_pass 1111</div><div class="line"> &#125;</div><div class="line"> virtual_ipaddress &#123;</div><div class="line"> 192.168.41.249</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;启动keepalived服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/keepalived start</div><div class="line">/etc/init.d/keepalived stop</div></pre></td></tr></table></figure>
<ol>
<li>查看keepalived日志信息</li>
</ol>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;主web服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Jan 14 20:27:41 localhost Keepalived_vrrp[20840]: Opening file <span class="string">'/etc/keepalived/keepalived.conf'</span>.</div><div class="line">Jan 14 20:27:41 localhost Keepalived_vrrp[20840]: Configuration is using : 36304 Bytes</div><div class="line">Jan 14 20:27:41 localhost Keepalived_vrrp[20840]: Using LinkWatch kernel netlink reflector...</div><div class="line">Jan 14 20:27:41 localhost Keepalived[20837]: Starting VRRP child process, pid=20840</div><div class="line">Jan 14 20:27:41 localhost Keepalived_vrrp[20840]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(11,12)]</div><div class="line">Jan 14 20:27:42 localhost Keepalived_vrrp[20840]: VRRP_Instance(VI_1) Transition to MASTER STATE</div><div class="line">Jan 14 20:27:43 localhost Keepalived_vrrp[20840]: VRRP_Instance(VI_1) Entering MASTER STATE</div><div class="line">Jan 14 20:27:43 localhost Keepalived_vrrp[20840]: VRRP_Instance(VI_1) setting protocol VIPs.</div><div class="line">Jan 14 20:27:43 localhost Keepalived_vrrp[20840]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 <span class="keyword">for</span> 192.168.41.249</div><div class="line">Jan 14 20:27:43 localhost Keepalived_vrrp[20840]: Netlink reflector reports IP 192.168.41.249 added</div><div class="line">Jan 14 20:27:43 localhost avahi-daemon[3207]: Registering new address record <span class="keyword">for</span> 192.168.41.249 on eth0.</div><div class="line">Jan 14 20:27:43 localhost Keepalived_healthcheckers[20839]: Netlink reflector reports IP 192.168.41.249 added</div><div class="line">Jan 14 20:27:44 localhost avahi-daemon[3207]: Invalid query packet.</div><div class="line">Jan 14 20:27:46 localhost last message repeated 8 <span class="built_in">times</span></div><div class="line">Jan 14 20:27:48 localhost Keepalived_vrrp[20840]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 <span class="keyword">for</span> 192.168.41.249</div><div class="line">Jan 14 20:27:48 localhost avahi-daemon[3207]: Invalid query packet.</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;备web服务器日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Jan 14 19:55:26 localhost Keepalived_vrrp[19423]: Opening file <span class="string">'/etc/keepalived/keepalived.conf'</span>.</div><div class="line">Jan 14 19:55:26 localhost Keepalived_vrrp[19423]: Configuration is using : 36302 Bytes</div><div class="line">Jan 14 19:55:26 localhost Keepalived_vrrp[19423]: Using LinkWatch kernel netlink reflector...</div><div class="line">Jan 14 19:55:26 localhost Keepalived[19420]: Starting VRRP child process, pid=19423</div><div class="line">Jan 14 19:55:26 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Entering BACKUP STATE</div><div class="line">Jan 14 19:55:26 localhost Keepalived_vrrp[19423]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(11,12)]</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当主web服务器的keepalived停掉后，及主keepalived重新启动时的日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Jan 14 20:25:57 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Transition to MASTER STATE</div><div class="line">Jan 14 20:25:58 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Entering MASTER STATE</div><div class="line">Jan 14 20:25:58 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) setting protocol VIPs.</div><div class="line">Jan 14 20:25:58 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 <span class="keyword">for</span> 192.168.41.249</div><div class="line">Jan 14 20:25:58 localhost Keepalived_vrrp[19423]: Netlink reflector reports IP 192.168.41.249 added</div><div class="line">Jan 14 20:25:58 localhost Keepalived_healthcheckers[19422]: Netlink reflector reports IP 192.168.41.249 added</div><div class="line">Jan 14 20:26:03 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 <span class="keyword">for</span> 192.168.41.249</div><div class="line"><span class="comment">###主keepalived重新启动后</span></div><div class="line">Jan 14 20:27:42 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Received higher prio advert</div><div class="line">Jan 14 20:27:42 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) Entering BACKUP STATE</div><div class="line">Jan 14 20:27:42 localhost Keepalived_vrrp[19423]: VRRP_Instance(VI_1) removing protocol VIPs.</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;并且通过tcpdump vrrp能够看到两者之间的通讯</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]<span class="comment"># tcpdump vrrp</span></div><div class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</div><div class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes</div><div class="line">20:38:58.657600 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:38:59.658287 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:39:00.659280 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:39:01.660358 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:39:02.661203 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:39:03.662205 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div><div class="line">20:39:04.663129 IP 192.168.41.33 &gt; vrrp.mcast.net: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</div></pre></td></tr></table></figure>
<h2 id="三、脚本实现监控httpd服务"><a href="#三、脚本实现监控httpd服务" class="headerlink" title="三、脚本实现监控httpd服务"></a>三、脚本实现监控httpd服务</h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;目前keepalived能够实现当我们的主web宕机或者网络出现故障时进行切换，但如果仅是httpd进程出现故障，所以我们就需要写一点实时监控httpd进程状态的脚本，即如果进程出现问题我们就进行切换。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span></div><div class="line"><span class="keyword">do</span></div><div class="line"> httpdpid=`ps -C httpd --no-heading |wc -l`</div><div class="line"> <span class="keyword">if</span> [ <span class="variable">$httpdpid</span> -eq 0 ];<span class="keyword">then</span></div><div class="line"> /etc/init.d/httpd start</div><div class="line"> sleep 5</div><div class="line"> httpdpid=`ps -C httpd --no-heading |wc -l`</div><div class="line"> <span class="keyword">if</span> [ <span class="variable">$httpdpid</span> -eq 0 ];<span class="keyword">then</span></div><div class="line"> /etc/init.d/keepalive stop</div><div class="line"> <span class="keyword">fi</span></div><div class="line"> <span class="keyword">fi</span></div><div class="line"> sleep 5</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;即当我们的httpd进程被停止了，并且无法重启我们会将keepalived进行停止，让备web服务器进行接管，成为主WEB服务器提供服务。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;到此我们已经能够轻松的部署keepalived让它作为web服务器的HA.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LVS/">LVS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/27/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/29/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 失落的乐章
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: ,
		mathjax: ,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



  </div>
</body>
</html>